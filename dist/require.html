<html><head><meta charset="UTF-8"><script>(function () {
function resolve() {
document.body.removeAttribute('unresolved');
}
if (window.WebComponents) {
addEventListener('WebComponentsReady', resolve);
} else {
if (document.readyState === 'interactive' || document.readyState === 'complete') {
resolve();
} else {
addEventListener('DOMContentLoaded', resolve);
}
}
}());
window.Polymer = {
Settings: function () {
var user = window.Polymer || {};
location.search.slice(1).split('&').forEach(function (o) {
o = o.split('=');
o[0] && (user[o[0]] = o[1] || true);
});
var wantShadow = user.dom === 'shadow';
var hasShadow = Boolean(Element.prototype.createShadowRoot);
var nativeShadow = hasShadow && !window.ShadowDOMPolyfill;
var useShadow = wantShadow && hasShadow;
var hasNativeImports = Boolean('import' in document.createElement('link'));
var useNativeImports = hasNativeImports;
var useNativeCustomElements = !window.CustomElements || window.CustomElements.useNative;
return {
wantShadow: wantShadow,
hasShadow: hasShadow,
nativeShadow: nativeShadow,
useShadow: useShadow,
useNativeShadow: useShadow && nativeShadow,
useNativeImports: useNativeImports,
useNativeCustomElements: useNativeCustomElements
};
}()
};
(function () {
var userPolymer = window.Polymer;
window.Polymer = function (prototype) {
if (typeof prototype === 'function') {
prototype = prototype.prototype;
}
if (!prototype) {
prototype = {};
}
var factory = desugar(prototype);
prototype = factory.prototype;
var options = { prototype: prototype };
if (prototype.extends) {
options.extends = prototype.extends;
}
Polymer.telemetry._registrate(prototype);
document.registerElement(prototype.is, options);
return factory;
};
var desugar = function (prototype) {
var base = Polymer.Base;
if (prototype.extends) {
base = Polymer.Base._getExtendedPrototype(prototype.extends);
}
prototype = Polymer.Base.chainObject(prototype, base);
prototype.registerCallback();
return prototype.constructor;
};
window.Polymer = Polymer;
if (userPolymer) {
for (var i in userPolymer) {
Polymer[i] = userPolymer[i];
}
}
Polymer.Class = desugar;
}());
Polymer.telemetry = {
registrations: [],
_regLog: function (prototype) {
console.log('[' + prototype.is + ']: registered');
},
_registrate: function (prototype) {
this.registrations.push(prototype);
Polymer.log && this._regLog(prototype);
},
dumpRegistrations: function () {
this.registrations.forEach(this._regLog);
}
};
Object.defineProperty(window, 'currentImport', {
enumerable: true,
configurable: true,
get: function () {
return (document._currentScript || document.currentScript).ownerDocument;
}
});
Polymer.RenderStatus = {
_ready: false,
_callbacks: [],
whenReady: function (cb) {
if (this._ready) {
cb();
} else {
this._callbacks.push(cb);
}
},
_makeReady: function () {
this._ready = true;
this._callbacks.forEach(function (cb) {
cb();
});
this._callbacks = [];
},
_catchFirstRender: function () {
requestAnimationFrame(function () {
Polymer.RenderStatus._makeReady();
});
}
};
if (window.HTMLImports) {
HTMLImports.whenReady(function () {
Polymer.RenderStatus._catchFirstRender();
});
} else {
Polymer.RenderStatus._catchFirstRender();
}
Polymer.ImportStatus = Polymer.RenderStatus;
Polymer.ImportStatus.whenLoaded = Polymer.ImportStatus.whenReady;
Polymer.Base = {
__isPolymerInstance__: true,
_addFeature: function (feature) {
this.extend(this, feature);
},
registerCallback: function () {
this._desugarBehaviors();
this._doBehavior('beforeRegister');
this._registerFeatures();
this._doBehavior('registered');
},
createdCallback: function () {
Polymer.telemetry.instanceCount++;
this.root = this;
this._doBehavior('created');
this._initFeatures();
},
attachedCallback: function () {
Polymer.RenderStatus.whenReady(function () {
this.isAttached = true;
this._doBehavior('attached');
}.bind(this));
},
detachedCallback: function () {
this.isAttached = false;
this._doBehavior('detached');
},
attributeChangedCallback: function (name) {
this._attributeChangedImpl(name);
this._doBehavior('attributeChanged', arguments);
},
_attributeChangedImpl: function (name) {
this._setAttributeToProperty(this, name);
},
extend: function (prototype, api) {
if (prototype && api) {
Object.getOwnPropertyNames(api).forEach(function (n) {
this.copyOwnProperty(n, api, prototype);
}, this);
}
return prototype || api;
},
mixin: function (target, source) {
for (var i in source) {
target[i] = source[i];
}
return target;
},
copyOwnProperty: function (name, source, target) {
var pd = Object.getOwnPropertyDescriptor(source, name);
if (pd) {
Object.defineProperty(target, name, pd);
}
},
_log: console.log.apply.bind(console.log, console),
_warn: console.warn.apply.bind(console.warn, console),
_error: console.error.apply.bind(console.error, console),
_logf: function () {
return this._logPrefix.concat([this.is]).concat(Array.prototype.slice.call(arguments, 0));
}
};
Polymer.Base._logPrefix = function () {
var color = window.chrome || /firefox/i.test(navigator.userAgent);
return color ? [
'%c[%s::%s]:',
'font-weight: bold; background-color:#EEEE00;'
] : ['[%s::%s]:'];
}();
Polymer.Base.chainObject = function (object, inherited) {
if (object && inherited && object !== inherited) {
if (!Object.__proto__) {
object = Polymer.Base.extend(Object.create(inherited), object);
}
object.__proto__ = inherited;
}
return object;
};
Polymer.Base = Polymer.Base.chainObject(Polymer.Base, HTMLElement.prototype);
if (window.CustomElements) {
Polymer.instanceof = CustomElements.instanceof;
} else {
Polymer.instanceof = function (obj, ctor) {
return obj instanceof ctor;
};
}
Polymer.isInstance = function (obj) {
return Boolean(obj && obj.__isPolymerInstance__);
};
Polymer.telemetry.instanceCount = 0;
(function () {
var modules = {};
var lcModules = {};
var findModule = function (id) {
return modules[id] || lcModules[id.toLowerCase()];
};
var DomModule = function () {
return document.createElement('dom-module');
};
DomModule.prototype = Object.create(HTMLElement.prototype);
Polymer.Base.extend(DomModule.prototype, {
constructor: DomModule,
createdCallback: function () {
this.register();
},
register: function (id) {
var id = id || this.id || this.getAttribute('name') || this.getAttribute('is');
if (id) {
this.id = id;
modules[id] = this;
lcModules[id.toLowerCase()] = this;
}
},
import: function (id, selector) {
if (id) {
var m = findModule(id);
if (!m) {
forceDocumentUpgrade();
m = findModule(id);
}
if (m && selector) {
m = m.querySelector(selector);
}
return m;
}
}
});
var cePolyfill = window.CustomElements && !CustomElements.useNative;
document.registerElement('dom-module', DomModule);
function forceDocumentUpgrade() {
if (cePolyfill) {
var script = document._currentScript || document.currentScript;
var doc = script && script.ownerDocument;
if (doc) {
CustomElements.upgradeAll(doc);
}
}
}
}());
Polymer.Base._addFeature({
_prepIs: function () {
if (!this.is) {
var module = (document._currentScript || document.currentScript).parentNode;
if (module.localName === 'dom-module') {
var id = module.id || module.getAttribute('name') || module.getAttribute('is');
this.is = id;
}
}
if (this.is) {
this.is = this.is.toLowerCase();
}
}
});
Polymer.Base._addFeature({
behaviors: [],
_desugarBehaviors: function () {
if (this.behaviors.length) {
this.behaviors = this._desugarSomeBehaviors(this.behaviors);
}
},
_desugarSomeBehaviors: function (behaviors) {
behaviors = this._flattenBehaviorsList(behaviors);
for (var i = behaviors.length - 1; i >= 0; i--) {
this._mixinBehavior(behaviors[i]);
}
return behaviors;
},
_flattenBehaviorsList: function (behaviors) {
var flat = [];
behaviors.forEach(function (b) {
if (b instanceof Array) {
flat = flat.concat(this._flattenBehaviorsList(b));
} else if (b) {
flat.push(b);
} else {
this._warn(this._logf('_flattenBehaviorsList', 'behavior is null, check for missing or 404 import'));
}
}, this);
return flat;
},
_mixinBehavior: function (b) {
Object.getOwnPropertyNames(b).forEach(function (n) {
switch (n) {
case 'hostAttributes':
case 'registered':
case 'properties':
case 'observers':
case 'listeners':
case 'created':
case 'attached':
case 'detached':
case 'attributeChanged':
case 'configure':
case 'ready':
break;
default:
if (!this.hasOwnProperty(n)) {
this.copyOwnProperty(n, b, this);
}
break;
}
}, this);
},
_prepBehaviors: function () {
this._prepFlattenedBehaviors(this.behaviors);
},
_prepFlattenedBehaviors: function (behaviors) {
for (var i = 0, l = behaviors.length; i < l; i++) {
this._prepBehavior(behaviors[i]);
}
this._prepBehavior(this);
},
_doBehavior: function (name, args) {
this.behaviors.forEach(function (b) {
this._invokeBehavior(b, name, args);
}, this);
this._invokeBehavior(this, name, args);
},
_invokeBehavior: function (b, name, args) {
var fn = b[name];
if (fn) {
fn.apply(this, args || Polymer.nar);
}
},
_marshalBehaviors: function () {
this.behaviors.forEach(function (b) {
this._marshalBehavior(b);
}, this);
this._marshalBehavior(this);
}
});
Polymer.Base._addFeature({
_getExtendedPrototype: function (tag) {
return this._getExtendedNativePrototype(tag);
},
_nativePrototypes: {},
_getExtendedNativePrototype: function (tag) {
var p = this._nativePrototypes[tag];
if (!p) {
var np = this.getNativePrototype(tag);
p = this.extend(Object.create(np), Polymer.Base);
this._nativePrototypes[tag] = p;
}
return p;
},
getNativePrototype: function (tag) {
return Object.getPrototypeOf(document.createElement(tag));
}
});
Polymer.Base._addFeature({
_prepConstructor: function () {
this._factoryArgs = this.extends ? [
this.extends,
this.is
] : [this.is];
var ctor = function () {
return this._factory(arguments);
};
if (this.hasOwnProperty('extends')) {
ctor.extends = this.extends;
}
Object.defineProperty(this, 'constructor', {
value: ctor,
writable: true,
configurable: true
});
ctor.prototype = this;
},
_factory: function (args) {
var elt = document.createElement.apply(document, this._factoryArgs);
if (this.factoryImpl) {
this.factoryImpl.apply(elt, args);
}
return elt;
}
});
Polymer.nob = Object.create(null);
Polymer.Base._addFeature({
properties: {},
getPropertyInfo: function (property) {
var info = this._getPropertyInfo(property, this.properties);
if (!info) {
this.behaviors.some(function (b) {
return info = this._getPropertyInfo(property, b.properties);
}, this);
}
return info || Polymer.nob;
},
_getPropertyInfo: function (property, properties) {
var p = properties && properties[property];
if (typeof p === 'function') {
p = properties[property] = { type: p };
}
if (p) {
p.defined = true;
}
return p;
}
});
Polymer.CaseMap = {
_caseMap: {},
dashToCamelCase: function (dash) {
var mapped = Polymer.CaseMap._caseMap[dash];
if (mapped) {
return mapped;
}
if (dash.indexOf('-') < 0) {
return Polymer.CaseMap._caseMap[dash] = dash;
}
return Polymer.CaseMap._caseMap[dash] = dash.replace(/-([a-z])/g, function (m) {
return m[1].toUpperCase();
});
},
camelToDashCase: function (camel) {
var mapped = Polymer.CaseMap._caseMap[camel];
if (mapped) {
return mapped;
}
return Polymer.CaseMap._caseMap[camel] = camel.replace(/([a-z][A-Z])/g, function (g) {
return g[0] + '-' + g[1].toLowerCase();
});
}
};
Polymer.Base._addFeature({
_prepAttributes: function () {
this._aggregatedAttributes = {};
},
_addHostAttributes: function (attributes) {
if (attributes) {
this.mixin(this._aggregatedAttributes, attributes);
}
},
_marshalHostAttributes: function () {
this._applyAttributes(this, this._aggregatedAttributes);
},
_applyAttributes: function (node, attr$) {
for (var n in attr$) {
if (!this.hasAttribute(n) && n !== 'class') {
this.serializeValueToAttribute(attr$[n], n, this);
}
}
},
_marshalAttributes: function () {
this._takeAttributesToModel(this);
},
_takeAttributesToModel: function (model) {
for (var i = 0, l = this.attributes.length; i < l; i++) {
this._setAttributeToProperty(model, this.attributes[i].name);
}
},
_setAttributeToProperty: function (model, attrName) {
if (!this._serializing) {
var propName = Polymer.CaseMap.dashToCamelCase(attrName);
var info = this.getPropertyInfo(propName);
if (info.defined || this._propertyEffects && this._propertyEffects[propName]) {
var val = this.getAttribute(attrName);
model[propName] = this.deserialize(val, info.type);
}
}
},
_serializing: false,
reflectPropertyToAttribute: function (name) {
this._serializing = true;
this.serializeValueToAttribute(this[name], Polymer.CaseMap.camelToDashCase(name));
this._serializing = false;
},
serializeValueToAttribute: function (value, attribute, node) {
var str = this.serialize(value);
(node || this)[str === undefined ? 'removeAttribute' : 'setAttribute'](attribute, str);
},
deserialize: function (value, type) {
switch (type) {
case Number:
value = Number(value);
break;
case Boolean:
value = value !== null;
break;
case Object:
try {
value = JSON.parse(value);
} catch (x) {
}
break;
case Array:
try {
value = JSON.parse(value);
} catch (x) {
value = null;
console.warn('Polymer::Attributes: couldn`t decode Array as JSON');
}
break;
case Date:
value = new Date(value);
break;
case String:
default:
break;
}
return value;
},
serialize: function (value) {
switch (typeof value) {
case 'boolean':
return value ? '' : undefined;
case 'object':
if (value instanceof Date) {
return value;
} else if (value) {
try {
return JSON.stringify(value);
} catch (x) {
return '';
}
}
default:
return value != null ? value : undefined;
}
}
});
Polymer.Base._addFeature({
_setupDebouncers: function () {
this._debouncers = {};
},
debounce: function (jobName, callback, wait) {
return this._debouncers[jobName] = Polymer.Debounce.call(this, this._debouncers[jobName], callback, wait);
},
isDebouncerActive: function (jobName) {
var debouncer = this._debouncers[jobName];
return debouncer && debouncer.finish;
},
flushDebouncer: function (jobName) {
var debouncer = this._debouncers[jobName];
if (debouncer) {
debouncer.complete();
}
},
cancelDebouncer: function (jobName) {
var debouncer = this._debouncers[jobName];
if (debouncer) {
debouncer.stop();
}
}
});
Polymer.version = '1.1.5';
Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepAttributes();
this._prepBehaviors();
this._prepConstructor();
},
_prepBehavior: function (b) {
this._addHostAttributes(b.hostAttributes);
},
_marshalBehavior: function (b) {
},
_initFeatures: function () {
this._marshalHostAttributes();
this._setupDebouncers();
this._marshalBehaviors();
}
});</script>

<script>Polymer.Base._addFeature({
_prepTemplate: function () {
this._template = this._template || Polymer.DomModule.import(this.is, 'template');
if (this._template && this._template.hasAttribute('is')) {
this._warn(this._logf('_prepTemplate', 'top-level Polymer template ' + 'must not be a type-extension, found', this._template, 'Move inside simple <template>.'));
}
if (this._template && !this._template.content && HTMLTemplateElement.bootstrap) {
HTMLTemplateElement.decorate(this._template);
HTMLTemplateElement.bootstrap(this._template.content);
}
},
_stampTemplate: function () {
if (this._template) {
this.root = this.instanceTemplate(this._template);
}
},
instanceTemplate: function (template) {
var dom = document.importNode(template._content || template.content, true);
return dom;
}
});
(function () {
var baseAttachedCallback = Polymer.Base.attachedCallback;
Polymer.Base._addFeature({
_hostStack: [],
ready: function () {
},
_pushHost: function (host) {
this.dataHost = host = host || Polymer.Base._hostStack[Polymer.Base._hostStack.length - 1];
if (host && host._clients) {
host._clients.push(this);
}
this._beginHost();
},
_beginHost: function () {
Polymer.Base._hostStack.push(this);
if (!this._clients) {
this._clients = [];
}
},
_popHost: function () {
Polymer.Base._hostStack.pop();
},
_tryReady: function () {
if (this._canReady()) {
this._ready();
}
},
_canReady: function () {
return !this.dataHost || this.dataHost._clientsReadied;
},
_ready: function () {
this._beforeClientsReady();
this._setupRoot();
this._readyClients();
this._afterClientsReady();
this._readySelf();
},
_readyClients: function () {
this._beginDistribute();
var c$ = this._clients;
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
c._ready();
}
this._finishDistribute();
this._clientsReadied = true;
this._clients = null;
},
_readySelf: function () {
this._doBehavior('ready');
this._readied = true;
if (this._attachedPending) {
this._attachedPending = false;
this.attachedCallback();
}
},
_beforeClientsReady: function () {
},
_afterClientsReady: function () {
},
_beforeAttached: function () {
},
attachedCallback: function () {
if (this._readied) {
this._beforeAttached();
baseAttachedCallback.call(this);
} else {
this._attachedPending = true;
}
}
});
}());
Polymer.ArraySplice = function () {
function newSplice(index, removed, addedCount) {
return {
index: index,
removed: removed,
addedCount: addedCount
};
}
var EDIT_LEAVE = 0;
var EDIT_UPDATE = 1;
var EDIT_ADD = 2;
var EDIT_DELETE = 3;
function ArraySplice() {
}
ArraySplice.prototype = {
calcEditDistances: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var rowCount = oldEnd - oldStart + 1;
var columnCount = currentEnd - currentStart + 1;
var distances = new Array(rowCount);
for (var i = 0; i < rowCount; i++) {
distances[i] = new Array(columnCount);
distances[i][0] = i;
}
for (var j = 0; j < columnCount; j++)
distances[0][j] = j;
for (var i = 1; i < rowCount; i++) {
for (var j = 1; j < columnCount; j++) {
if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))
distances[i][j] = distances[i - 1][j - 1];
else {
var north = distances[i - 1][j] + 1;
var west = distances[i][j - 1] + 1;
distances[i][j] = north < west ? north : west;
}
}
}
return distances;
},
spliceOperationsFromEditDistances: function (distances) {
var i = distances.length - 1;
var j = distances[0].length - 1;
var current = distances[i][j];
var edits = [];
while (i > 0 || j > 0) {
if (i == 0) {
edits.push(EDIT_ADD);
j--;
continue;
}
if (j == 0) {
edits.push(EDIT_DELETE);
i--;
continue;
}
var northWest = distances[i - 1][j - 1];
var west = distances[i - 1][j];
var north = distances[i][j - 1];
var min;
if (west < north)
min = west < northWest ? west : northWest;
else
min = north < northWest ? north : northWest;
if (min == northWest) {
if (northWest == current) {
edits.push(EDIT_LEAVE);
} else {
edits.push(EDIT_UPDATE);
current = northWest;
}
i--;
j--;
} else if (min == west) {
edits.push(EDIT_DELETE);
i--;
current = west;
} else {
edits.push(EDIT_ADD);
j--;
current = north;
}
}
edits.reverse();
return edits;
},
calcSplices: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var prefixCount = 0;
var suffixCount = 0;
var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
if (currentStart == 0 && oldStart == 0)
prefixCount = this.sharedPrefix(current, old, minLength);
if (currentEnd == current.length && oldEnd == old.length)
suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
currentStart += prefixCount;
oldStart += prefixCount;
currentEnd -= suffixCount;
oldEnd -= suffixCount;
if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
return [];
if (currentStart == currentEnd) {
var splice = newSplice(currentStart, [], 0);
while (oldStart < oldEnd)
splice.removed.push(old[oldStart++]);
return [splice];
} else if (oldStart == oldEnd)
return [newSplice(currentStart, [], currentEnd - currentStart)];
var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
var splice = undefined;
var splices = [];
var index = currentStart;
var oldIndex = oldStart;
for (var i = 0; i < ops.length; i++) {
switch (ops[i]) {
case EDIT_LEAVE:
if (splice) {
splices.push(splice);
splice = undefined;
}
index++;
oldIndex++;
break;
case EDIT_UPDATE:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
case EDIT_ADD:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
break;
case EDIT_DELETE:
if (!splice)
splice = newSplice(index, [], 0);
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
}
}
if (splice) {
splices.push(splice);
}
return splices;
},
sharedPrefix: function (current, old, searchLength) {
for (var i = 0; i < searchLength; i++)
if (!this.equals(current[i], old[i]))
return i;
return searchLength;
},
sharedSuffix: function (current, old, searchLength) {
var index1 = current.length;
var index2 = old.length;
var count = 0;
while (count < searchLength && this.equals(current[--index1], old[--index2]))
count++;
return count;
},
calculateSplices: function (current, previous) {
return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
},
equals: function (currentValue, previousValue) {
return currentValue === previousValue;
}
};
return new ArraySplice();
}();
Polymer.EventApi = function () {
var Settings = Polymer.Settings;
var EventApi = function (event) {
this.event = event;
};
if (Settings.useShadow) {
EventApi.prototype = {
get rootTarget() {
return this.event.path[0];
},
get localTarget() {
return this.event.target;
},
get path() {
return this.event.path;
}
};
} else {
EventApi.prototype = {
get rootTarget() {
return this.event.target;
},
get localTarget() {
var current = this.event.currentTarget;
var currentRoot = current && Polymer.dom(current).getOwnerRoot();
var p$ = this.path;
for (var i = 0; i < p$.length; i++) {
if (Polymer.dom(p$[i]).getOwnerRoot() === currentRoot) {
return p$[i];
}
}
},
get path() {
if (!this.event._path) {
var path = [];
var o = this.rootTarget;
while (o) {
path.push(o);
o = Polymer.dom(o).parentNode || o.host;
}
path.push(window);
this.event._path = path;
}
return this.event._path;
}
};
}
var factory = function (event) {
if (!event.__eventApi) {
event.__eventApi = new EventApi(event);
}
return event.__eventApi;
};
return { factory: factory };
}();
Polymer.domInnerHTML = function () {
var escapeAttrRegExp = /[&\u00A0"]/g;
var escapeDataRegExp = /[&\u00A0<>]/g;
function escapeReplace(c) {
switch (c) {
case '&':
return '&amp;';
case '<':
return '&lt;';
case '>':
return '&gt;';
case '"':
return '&quot;';
case '\xA0':
return '&nbsp;';
}
}
function escapeAttr(s) {
return s.replace(escapeAttrRegExp, escapeReplace);
}
function escapeData(s) {
return s.replace(escapeDataRegExp, escapeReplace);
}
function makeSet(arr) {
var set = {};
for (var i = 0; i < arr.length; i++) {
set[arr[i]] = true;
}
return set;
}
var voidElements = makeSet([
'area',
'base',
'br',
'col',
'command',
'embed',
'hr',
'img',
'input',
'keygen',
'link',
'meta',
'param',
'source',
'track',
'wbr'
]);
var plaintextParents = makeSet([
'style',
'script',
'xmp',
'iframe',
'noembed',
'noframes',
'plaintext',
'noscript'
]);
function getOuterHTML(node, parentNode, composed) {
switch (node.nodeType) {
case Node.ELEMENT_NODE:
var tagName = node.localName;
var s = '<' + tagName;
var attrs = node.attributes;
for (var i = 0, attr; attr = attrs[i]; i++) {
s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
}
s += '>';
if (voidElements[tagName]) {
return s;
}
return s + getInnerHTML(node, composed) + '</' + tagName + '>';
case Node.TEXT_NODE:
var data = node.data;
if (parentNode && plaintextParents[parentNode.localName]) {
return data;
}
return escapeData(data);
case Node.COMMENT_NODE:
return '<!--' + node.data + '-->';
default:
console.error(node);
throw new Error('not implemented');
}
}
function getInnerHTML(node, composed) {
if (node instanceof HTMLTemplateElement)
node = node.content;
var s = '';
var c$ = Polymer.dom(node).childNodes;
c$ = composed ? node._composedChildren : c$;
for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
s += getOuterHTML(child, node, composed);
}
return s;
}
return { getInnerHTML: getInnerHTML };
}();
Polymer.DomApi = function () {
'use strict';
var Settings = Polymer.Settings;
var getInnerHTML = Polymer.domInnerHTML.getInnerHTML;
var nativeInsertBefore = Element.prototype.insertBefore;
var nativeRemoveChild = Element.prototype.removeChild;
var nativeAppendChild = Element.prototype.appendChild;
var nativeCloneNode = Element.prototype.cloneNode;
var nativeImportNode = Document.prototype.importNode;
var DomApi = function (node) {
this.node = node;
if (this.patch) {
this.patch();
}
};
if (window.wrap && Settings.useShadow && !Settings.useNativeShadow) {
DomApi = function (node) {
this.node = wrap(node);
if (this.patch) {
this.patch();
}
};
}
DomApi.prototype = {
flush: function () {
Polymer.dom.flush();
},
_lazyDistribute: function (host) {
if (host.shadyRoot && host.shadyRoot._distributionClean) {
host.shadyRoot._distributionClean = false;
Polymer.dom.addDebouncer(host.debounce('_distribute', host._distributeContent));
}
},
appendChild: function (node) {
return this._addNode(node);
},
insertBefore: function (node, ref_node) {
return this._addNode(node, ref_node);
},
_addNode: function (node, ref_node) {
this._removeNodeFromHost(node, true);
var addedInsertionPoint;
var root = this.getOwnerRoot();
if (root) {
addedInsertionPoint = this._maybeAddInsertionPoint(node, this.node);
}
if (this._nodeHasLogicalChildren(this.node)) {
if (ref_node) {
var children = this.childNodes;
var index = children.indexOf(ref_node);
if (index < 0) {
throw Error('The ref_node to be inserted before is not a child ' + 'of this node');
}
}
this._addLogicalInfo(node, this.node, index);
}
this._addNodeToHost(node);
if (!this._maybeDistribute(node, this.node) && !this._tryRemoveUndistributedNode(node)) {
if (ref_node) {
ref_node = ref_node.localName === CONTENT ? this._firstComposedNode(ref_node) : ref_node;
}
var container = this.node._isShadyRoot ? this.node.host : this.node;
addToComposedParent(container, node, ref_node);
if (ref_node) {
nativeInsertBefore.call(container, node, ref_node);
} else {
nativeAppendChild.call(container, node);
}
}
if (addedInsertionPoint) {
this._updateInsertionPoints(root.host);
}
return node;
},
removeChild: function (node) {
if (factory(node).parentNode !== this.node) {
console.warn('The node to be removed is not a child of this node', node);
}
this._removeNodeFromHost(node);
if (!this._maybeDistribute(node, this.node)) {
var container = this.node._isShadyRoot ? this.node.host : this.node;
if (container === node.parentNode) {
removeFromComposedParent(container, node);
nativeRemoveChild.call(container, node);
}
}
return node;
},
replaceChild: function (node, ref_node) {
this.insertBefore(node, ref_node);
this.removeChild(ref_node);
return node;
},
_hasCachedOwnerRoot: function (node) {
return Boolean(node._ownerShadyRoot !== undefined);
},
getOwnerRoot: function () {
return this._ownerShadyRootForNode(this.node);
},
_ownerShadyRootForNode: function (node) {
if (!node) {
return;
}
if (node._ownerShadyRoot === undefined) {
var root;
if (node._isShadyRoot) {
root = node;
} else {
var parent = Polymer.dom(node).parentNode;
if (parent) {
root = parent._isShadyRoot ? parent : this._ownerShadyRootForNode(parent);
} else {
root = null;
}
}
node._ownerShadyRoot = root;
}
return node._ownerShadyRoot;
},
_maybeDistribute: function (node, parent) {
var fragContent = node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent && Polymer.dom(node).querySelector(CONTENT);
var wrappedContent = fragContent && Polymer.dom(fragContent).parentNode.nodeType !== Node.DOCUMENT_FRAGMENT_NODE;
var hasContent = fragContent || node.localName === CONTENT;
if (hasContent) {
var root = this._ownerShadyRootForNode(parent);
if (root) {
var host = root.host;
this._lazyDistribute(host);
}
}
var parentNeedsDist = this._parentNeedsDistribution(parent);
if (parentNeedsDist) {
this._lazyDistribute(parent);
}
return parentNeedsDist || hasContent && !wrappedContent;
},
_maybeAddInsertionPoint: function (node, parent) {
var added;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent) {
var c$ = factory(node).querySelectorAll(CONTENT);
for (var i = 0, n, np, na; i < c$.length && (n = c$[i]); i++) {
np = factory(n).parentNode;
if (np === node) {
np = parent;
}
na = this._maybeAddInsertionPoint(n, np);
added = added || na;
}
} else if (node.localName === CONTENT) {
saveLightChildrenIfNeeded(parent);
saveLightChildrenIfNeeded(node);
added = true;
}
return added;
},
_tryRemoveUndistributedNode: function (node) {
if (this.node.shadyRoot) {
var parent = getComposedParent(node);
if (parent) {
nativeRemoveChild.call(parent, node);
}
return true;
}
},
_updateInsertionPoints: function (host) {
var i$ = host.shadyRoot._insertionPoints = factory(host.shadyRoot).querySelectorAll(CONTENT);
for (var i = 0, c; i < i$.length; i++) {
c = i$[i];
saveLightChildrenIfNeeded(c);
saveLightChildrenIfNeeded(factory(c).parentNode);
}
},
_nodeHasLogicalChildren: function (node) {
return Boolean(node._lightChildren !== undefined);
},
_parentNeedsDistribution: function (parent) {
return parent && parent.shadyRoot && hasInsertionPoint(parent.shadyRoot);
},
_removeNodeFromHost: function (node, ensureComposedRemoval) {
var hostNeedsDist;
var root;
var parent = node._lightParent;
if (parent) {
factory(node)._distributeParent();
root = this._ownerShadyRootForNode(node);
if (root) {
root.host._elementRemove(node);
hostNeedsDist = this._removeDistributedChildren(root, node);
}
this._removeLogicalInfo(node, node._lightParent);
}
this._removeOwnerShadyRoot(node);
if (root && hostNeedsDist) {
this._updateInsertionPoints(root.host);
this._lazyDistribute(root.host);
} else if (ensureComposedRemoval) {
removeFromComposedParent(getComposedParent(node), node);
}
},
_removeDistributedChildren: function (root, container) {
var hostNeedsDist;
var ip$ = root._insertionPoints;
for (var i = 0; i < ip$.length; i++) {
var content = ip$[i];
if (this._contains(container, content)) {
var dc$ = factory(content).getDistributedNodes();
for (var j = 0; j < dc$.length; j++) {
hostNeedsDist = true;
var node = dc$[j];
var parent = node.parentNode;
if (parent) {
removeFromComposedParent(parent, node);
nativeRemoveChild.call(parent, node);
}
}
}
}
return hostNeedsDist;
},
_contains: function (container, node) {
while (node) {
if (node == container) {
return true;
}
node = factory(node).parentNode;
}
},
_addNodeToHost: function (node) {
var root = this.getOwnerRoot();
if (root) {
root.host._elementAdd(node);
}
},
_addLogicalInfo: function (node, container, index) {
var children = factory(container).childNodes;
index = index === undefined ? children.length : index;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
var c$ = Array.prototype.slice.call(node.childNodes);
for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
children.splice(index++, 0, n);
n._lightParent = container;
}
} else {
children.splice(index, 0, node);
node._lightParent = container;
}
},
_removeLogicalInfo: function (node, container) {
var children = factory(container).childNodes;
var index = children.indexOf(node);
if (index < 0 || container !== node._lightParent) {
throw Error('The node to be removed is not a child of this node');
}
children.splice(index, 1);
node._lightParent = null;
},
_removeOwnerShadyRoot: function (node) {
if (this._hasCachedOwnerRoot(node)) {
var c$ = factory(node).childNodes;
for (var i = 0, l = c$.length, n; i < l && (n = c$[i]); i++) {
this._removeOwnerShadyRoot(n);
}
}
node._ownerShadyRoot = undefined;
},
_firstComposedNode: function (content) {
var n$ = factory(content).getDistributedNodes();
for (var i = 0, l = n$.length, n, p$; i < l && (n = n$[i]); i++) {
p$ = factory(n).getDestinationInsertionPoints();
if (p$[p$.length - 1] === content) {
return n;
}
}
},
querySelector: function (selector) {
return this.querySelectorAll(selector)[0];
},
querySelectorAll: function (selector) {
return this._query(function (n) {
return matchesSelector.call(n, selector);
}, this.node);
},
_query: function (matcher, node) {
node = node || this.node;
var list = [];
this._queryElements(factory(node).childNodes, matcher, list);
return list;
},
_queryElements: function (elements, matcher, list) {
for (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++) {
if (c.nodeType === Node.ELEMENT_NODE) {
this._queryElement(c, matcher, list);
}
}
},
_queryElement: function (node, matcher, list) {
if (matcher(node)) {
list.push(node);
}
this._queryElements(factory(node).childNodes, matcher, list);
},
getDestinationInsertionPoints: function () {
return this.node._destinationInsertionPoints || [];
},
getDistributedNodes: function () {
return this.node._distributedNodes || [];
},
queryDistributedElements: function (selector) {
var c$ = this.childNodes;
var list = [];
this._distributedFilter(selector, c$, list);
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.localName === CONTENT) {
this._distributedFilter(selector, factory(c).getDistributedNodes(), list);
}
}
return list;
},
_distributedFilter: function (selector, list, results) {
results = results || [];
for (var i = 0, l = list.length, d; i < l && (d = list[i]); i++) {
if (d.nodeType === Node.ELEMENT_NODE && d.localName !== CONTENT && matchesSelector.call(d, selector)) {
results.push(d);
}
}
return results;
},
_clear: function () {
while (this.childNodes.length) {
this.removeChild(this.childNodes[0]);
}
},
setAttribute: function (name, value) {
this.node.setAttribute(name, value);
this._distributeParent();
},
removeAttribute: function (name) {
this.node.removeAttribute(name);
this._distributeParent();
},
_distributeParent: function () {
if (this._parentNeedsDistribution(this.parentNode)) {
this._lazyDistribute(this.parentNode);
}
},
cloneNode: function (deep) {
var n = nativeCloneNode.call(this.node, false);
if (deep) {
var c$ = this.childNodes;
var d = factory(n);
for (var i = 0, nc; i < c$.length; i++) {
nc = factory(c$[i]).cloneNode(true);
d.appendChild(nc);
}
}
return n;
},
importNode: function (externalNode, deep) {
var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
var n = nativeImportNode.call(doc, externalNode, false);
if (deep) {
var c$ = factory(externalNode).childNodes;
var d = factory(n);
for (var i = 0, nc; i < c$.length; i++) {
nc = factory(doc).importNode(c$[i], true);
d.appendChild(nc);
}
}
return n;
}
};
Object.defineProperty(DomApi.prototype, 'classList', {
get: function () {
if (!this._classList) {
this._classList = new DomApi.ClassList(this);
}
return this._classList;
},
configurable: true
});
DomApi.ClassList = function (host) {
this.domApi = host;
this.node = host.node;
};
DomApi.ClassList.prototype = {
add: function () {
this.node.classList.add.apply(this.node.classList, arguments);
this.domApi._distributeParent();
},
remove: function () {
this.node.classList.remove.apply(this.node.classList, arguments);
this.domApi._distributeParent();
},
toggle: function () {
this.node.classList.toggle.apply(this.node.classList, arguments);
this.domApi._distributeParent();
},
contains: function () {
return this.node.classList.contains.apply(this.node.classList, arguments);
}
};
if (!Settings.useShadow) {
Object.defineProperties(DomApi.prototype, {
childNodes: {
get: function () {
var c$ = getLightChildren(this.node);
return Array.isArray(c$) ? c$ : Array.prototype.slice.call(c$);
},
configurable: true
},
children: {
get: function () {
return Array.prototype.filter.call(this.childNodes, function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
},
configurable: true
},
parentNode: {
get: function () {
return this.node._lightParent || getComposedParent(this.node);
},
configurable: true
},
firstChild: {
get: function () {
return this.childNodes[0];
},
configurable: true
},
lastChild: {
get: function () {
var c$ = this.childNodes;
return c$[c$.length - 1];
},
configurable: true
},
nextSibling: {
get: function () {
var c$ = this.parentNode && factory(this.parentNode).childNodes;
if (c$) {
return c$[Array.prototype.indexOf.call(c$, this.node) + 1];
}
},
configurable: true
},
previousSibling: {
get: function () {
var c$ = this.parentNode && factory(this.parentNode).childNodes;
if (c$) {
return c$[Array.prototype.indexOf.call(c$, this.node) - 1];
}
},
configurable: true
},
firstElementChild: {
get: function () {
return this.children[0];
},
configurable: true
},
lastElementChild: {
get: function () {
var c$ = this.children;
return c$[c$.length - 1];
},
configurable: true
},
nextElementSibling: {
get: function () {
var c$ = this.parentNode && factory(this.parentNode).children;
if (c$) {
return c$[Array.prototype.indexOf.call(c$, this.node) + 1];
}
},
configurable: true
},
previousElementSibling: {
get: function () {
var c$ = this.parentNode && factory(this.parentNode).children;
if (c$) {
return c$[Array.prototype.indexOf.call(c$, this.node) - 1];
}
},
configurable: true
},
textContent: {
get: function () {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
return this.node.textContent;
} else {
var tc = [];
for (var i = 0, cn = this.childNodes, c; c = cn[i]; i++) {
if (c.nodeType !== Node.COMMENT_NODE) {
tc.push(c.textContent);
}
}
return tc.join('');
}
},
set: function (text) {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
this.node.textContent = text;
} else {
this._clear();
if (text) {
this.appendChild(document.createTextNode(text));
}
}
},
configurable: true
},
innerHTML: {
get: function () {
var nt = this.node.nodeType;
if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
return null;
} else {
return getInnerHTML(this.node);
}
},
set: function (text) {
var nt = this.node.nodeType;
if (nt !== Node.TEXT_NODE || nt !== Node.COMMENT_NODE) {
this._clear();
var d = document.createElement('div');
d.innerHTML = text;
var c$ = Array.prototype.slice.call(d.childNodes);
for (var i = 0; i < c$.length; i++) {
this.appendChild(c$[i]);
}
}
},
configurable: true
}
});
DomApi.prototype._getComposedInnerHTML = function () {
return getInnerHTML(this.node, true);
};
} else {
var forwardMethods = [
'cloneNode',
'appendChild',
'insertBefore',
'removeChild',
'replaceChild'
];
forwardMethods.forEach(function (name) {
DomApi.prototype[name] = function () {
return this.node[name].apply(this.node, arguments);
};
});
DomApi.prototype.querySelectorAll = function (selector) {
return Array.prototype.slice.call(this.node.querySelectorAll(selector));
};
DomApi.prototype.getOwnerRoot = function () {
var n = this.node;
while (n) {
if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n.host) {
return n;
}
n = n.parentNode;
}
};
DomApi.prototype.importNode = function (externalNode, deep) {
var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
return doc.importNode(externalNode, deep);
};
DomApi.prototype.getDestinationInsertionPoints = function () {
var n$ = this.node.getDestinationInsertionPoints && this.node.getDestinationInsertionPoints();
return n$ ? Array.prototype.slice.call(n$) : [];
};
DomApi.prototype.getDistributedNodes = function () {
var n$ = this.node.getDistributedNodes && this.node.getDistributedNodes();
return n$ ? Array.prototype.slice.call(n$) : [];
};
DomApi.prototype._distributeParent = function () {
};
Object.defineProperties(DomApi.prototype, {
childNodes: {
get: function () {
return Array.prototype.slice.call(this.node.childNodes);
},
configurable: true
},
children: {
get: function () {
return Array.prototype.slice.call(this.node.children);
},
configurable: true
},
textContent: {
get: function () {
return this.node.textContent;
},
set: function (value) {
return this.node.textContent = value;
},
configurable: true
},
innerHTML: {
get: function () {
return this.node.innerHTML;
},
set: function (value) {
return this.node.innerHTML = value;
},
configurable: true
}
});
var forwardProperties = [
'parentNode',
'firstChild',
'lastChild',
'nextSibling',
'previousSibling',
'firstElementChild',
'lastElementChild',
'nextElementSibling',
'previousElementSibling'
];
forwardProperties.forEach(function (name) {
Object.defineProperty(DomApi.prototype, name, {
get: function () {
return this.node[name];
},
configurable: true
});
});
}
var CONTENT = 'content';
var factory = function (node, patch) {
node = node || document;
if (!node.__domApi) {
node.__domApi = new DomApi(node, patch);
}
return node.__domApi;
};
Polymer.dom = function (obj, patch) {
if (obj instanceof Event) {
return Polymer.EventApi.factory(obj);
} else {
return factory(obj, patch);
}
};
Polymer.Base.extend(Polymer.dom, {
_flushGuard: 0,
_FLUSH_MAX: 100,
_needsTakeRecords: !Polymer.Settings.useNativeCustomElements,
_debouncers: [],
_finishDebouncer: null,
flush: function () {
for (var i = 0; i < this._debouncers.length; i++) {
this._debouncers[i].complete();
}
if (this._finishDebouncer) {
this._finishDebouncer.complete();
}
this._flushPolyfills();
if (this._debouncers.length && this._flushGuard < this._FLUSH_MAX) {
this._flushGuard++;
this.flush();
} else {
if (this._flushGuard >= this._FLUSH_MAX) {
console.warn('Polymer.dom.flush aborted. Flush may not be complete.');
}
this._flushGuard = 0;
}
},
_flushPolyfills: function () {
if (this._needsTakeRecords) {
CustomElements.takeRecords();
}
},
addDebouncer: function (debouncer) {
this._debouncers.push(debouncer);
this._finishDebouncer = Polymer.Debounce(this._finishDebouncer, this._finishFlush);
},
_finishFlush: function () {
Polymer.dom._debouncers = [];
}
});
function getLightChildren(node) {
var children = node._lightChildren;
return children ? children : node.childNodes;
}
function getComposedChildren(node) {
if (!node._composedChildren) {
node._composedChildren = Array.prototype.slice.call(node.childNodes);
}
return node._composedChildren;
}
function addToComposedParent(parent, node, ref_node) {
var children = getComposedChildren(parent);
var i = ref_node ? children.indexOf(ref_node) : -1;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
var fragChildren = getComposedChildren(node);
for (var j = 0; j < fragChildren.length; j++) {
addNodeToComposedChildren(fragChildren[j], parent, children, i + j);
}
node._composedChildren = null;
} else {
addNodeToComposedChildren(node, parent, children, i);
}
}
function getComposedParent(node) {
return node.__patched ? node._composedParent : node.parentNode;
}
function addNodeToComposedChildren(node, parent, children, i) {
node._composedParent = parent;
children.splice(i >= 0 ? i : children.length, 0, node);
}
function removeFromComposedParent(parent, node) {
node._composedParent = null;
if (parent) {
var children = getComposedChildren(parent);
var i = children.indexOf(node);
if (i >= 0) {
children.splice(i, 1);
}
}
}
function saveLightChildrenIfNeeded(node) {
if (!node._lightChildren) {
var c$ = Array.prototype.slice.call(node.childNodes);
for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
child._lightParent = child._lightParent || node;
}
node._lightChildren = c$;
}
}
function hasInsertionPoint(root) {
return Boolean(root && root._insertionPoints.length);
}
var p = Element.prototype;
var matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
return {
getLightChildren: getLightChildren,
getComposedParent: getComposedParent,
getComposedChildren: getComposedChildren,
removeFromComposedParent: removeFromComposedParent,
saveLightChildrenIfNeeded: saveLightChildrenIfNeeded,
matchesSelector: matchesSelector,
hasInsertionPoint: hasInsertionPoint,
ctor: DomApi,
factory: factory
};
}();
(function () {
Polymer.Base._addFeature({
_prepShady: function () {
this._useContent = this._useContent || Boolean(this._template);
},
_poolContent: function () {
if (this._useContent) {
saveLightChildrenIfNeeded(this);
}
},
_setupRoot: function () {
if (this._useContent) {
this._createLocalRoot();
if (!this.dataHost) {
upgradeLightChildren(this._lightChildren);
}
}
},
_createLocalRoot: function () {
this.shadyRoot = this.root;
this.shadyRoot._distributionClean = false;
this.shadyRoot._isShadyRoot = true;
this.shadyRoot._dirtyRoots = [];
var i$ = this.shadyRoot._insertionPoints = !this._notes || this._notes._hasContent ? this.shadyRoot.querySelectorAll('content') : [];
saveLightChildrenIfNeeded(this.shadyRoot);
for (var i = 0, c; i < i$.length; i++) {
c = i$[i];
saveLightChildrenIfNeeded(c);
saveLightChildrenIfNeeded(c.parentNode);
}
this.shadyRoot.host = this;
},
get domHost() {
var root = Polymer.dom(this).getOwnerRoot();
return root && root.host;
},
distributeContent: function (updateInsertionPoints) {
if (this.shadyRoot) {
var dom = Polymer.dom(this);
if (updateInsertionPoints) {
dom._updateInsertionPoints(this);
}
var host = getTopDistributingHost(this);
dom._lazyDistribute(host);
}
},
_distributeContent: function () {
if (this._useContent && !this.shadyRoot._distributionClean) {
this._beginDistribute();
this._distributeDirtyRoots();
this._finishDistribute();
}
},
_beginDistribute: function () {
if (this._useContent && hasInsertionPoint(this.shadyRoot)) {
this._resetDistribution();
this._distributePool(this.shadyRoot, this._collectPool());
}
},
_distributeDirtyRoots: function () {
var c$ = this.shadyRoot._dirtyRoots;
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
c._distributeContent();
}
this.shadyRoot._dirtyRoots = [];
},
_finishDistribute: function () {
if (this._useContent) {
this.shadyRoot._distributionClean = true;
if (hasInsertionPoint(this.shadyRoot)) {
this._composeTree();
} else {
if (!this.shadyRoot._hasDistributed) {
this.textContent = '';
this._composedChildren = null;
this.appendChild(this.shadyRoot);
} else {
var children = this._composeNode(this);
this._updateChildNodes(this, children);
}
}
this.shadyRoot._hasDistributed = true;
}
},
elementMatches: function (selector, node) {
node = node || this;
return matchesSelector.call(node, selector);
},
_resetDistribution: function () {
var children = getLightChildren(this);
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (child._destinationInsertionPoints) {
child._destinationInsertionPoints = undefined;
}
if (isInsertionPoint(child)) {
clearDistributedDestinationInsertionPoints(child);
}
}
var root = this.shadyRoot;
var p$ = root._insertionPoints;
for (var j = 0; j < p$.length; j++) {
p$[j]._distributedNodes = [];
}
},
_collectPool: function () {
var pool = [];
var children = getLightChildren(this);
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (isInsertionPoint(child)) {
pool.push.apply(pool, child._distributedNodes);
} else {
pool.push(child);
}
}
return pool;
},
_distributePool: function (node, pool) {
var p$ = node._insertionPoints;
for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
this._distributeInsertionPoint(p, pool);
maybeRedistributeParent(p, this);
}
},
_distributeInsertionPoint: function (content, pool) {
var anyDistributed = false;
for (var i = 0, l = pool.length, node; i < l; i++) {
node = pool[i];
if (!node) {
continue;
}
if (this._matchesContentSelect(node, content)) {
distributeNodeInto(node, content);
pool[i] = undefined;
anyDistributed = true;
}
}
if (!anyDistributed) {
var children = getLightChildren(content);
for (var j = 0; j < children.length; j++) {
distributeNodeInto(children[j], content);
}
}
},
_composeTree: function () {
this._updateChildNodes(this, this._composeNode(this));
var p$ = this.shadyRoot._insertionPoints;
for (var i = 0, l = p$.length, p, parent; i < l && (p = p$[i]); i++) {
parent = p._lightParent || p.parentNode;
if (!parent._useContent && parent !== this && parent !== this.shadyRoot) {
this._updateChildNodes(parent, this._composeNode(parent));
}
}
},
_composeNode: function (node) {
var children = [];
var c$ = getLightChildren(node.shadyRoot || node);
for (var i = 0; i < c$.length; i++) {
var child = c$[i];
if (isInsertionPoint(child)) {
var distributedNodes = child._distributedNodes;
for (var j = 0; j < distributedNodes.length; j++) {
var distributedNode = distributedNodes[j];
if (isFinalDestination(child, distributedNode)) {
children.push(distributedNode);
}
}
} else {
children.push(child);
}
}
return children;
},
_updateChildNodes: function (container, children) {
var composed = getComposedChildren(container);
var splices = Polymer.ArraySplice.calculateSplices(children, composed);
for (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
if (getComposedParent(n) === container) {
remove(n);
}
composed.splice(s.index + d, 1);
}
d -= s.addedCount;
}
for (var i = 0, s, next; i < splices.length && (s = splices[i]); i++) {
next = composed[s.index];
for (var j = s.index, n; j < s.index + s.addedCount; j++) {
n = children[j];
insertBefore(container, n, next);
composed.splice(j, 0, n);
}
}
ensureComposedParent(container, children);
},
_matchesContentSelect: function (node, contentElement) {
var select = contentElement.getAttribute('select');
if (!select) {
return true;
}
select = select.trim();
if (!select) {
return true;
}
if (!(node instanceof Element)) {
return false;
}
var validSelectors = /^(:not\()?[*.#[a-zA-Z_|]/;
if (!validSelectors.test(select)) {
return false;
}
return this.elementMatches(select, node);
},
_elementAdd: function () {
},
_elementRemove: function () {
}
});
var saveLightChildrenIfNeeded = Polymer.DomApi.saveLightChildrenIfNeeded;
var getLightChildren = Polymer.DomApi.getLightChildren;
var matchesSelector = Polymer.DomApi.matchesSelector;
var hasInsertionPoint = Polymer.DomApi.hasInsertionPoint;
var getComposedChildren = Polymer.DomApi.getComposedChildren;
var getComposedParent = Polymer.DomApi.getComposedParent;
var removeFromComposedParent = Polymer.DomApi.removeFromComposedParent;
function distributeNodeInto(child, insertionPoint) {
insertionPoint._distributedNodes.push(child);
var points = child._destinationInsertionPoints;
if (!points) {
child._destinationInsertionPoints = [insertionPoint];
} else {
points.push(insertionPoint);
}
}
function clearDistributedDestinationInsertionPoints(content) {
var e$ = content._distributedNodes;
if (e$) {
for (var i = 0; i < e$.length; i++) {
var d = e$[i]._destinationInsertionPoints;
if (d) {
d.splice(d.indexOf(content) + 1, d.length);
}
}
}
}
function maybeRedistributeParent(content, host) {
var parent = content._lightParent;
if (parent && parent.shadyRoot && hasInsertionPoint(parent.shadyRoot) && parent.shadyRoot._distributionClean) {
parent.shadyRoot._distributionClean = false;
host.shadyRoot._dirtyRoots.push(parent);
}
}
function isFinalDestination(insertionPoint, node) {
var points = node._destinationInsertionPoints;
return points && points[points.length - 1] === insertionPoint;
}
function isInsertionPoint(node) {
return node.localName == 'content';
}
var nativeInsertBefore = Element.prototype.insertBefore;
var nativeRemoveChild = Element.prototype.removeChild;
function insertBefore(parentNode, newChild, refChild) {
var newChildParent = getComposedParent(newChild);
if (newChildParent !== parentNode) {
removeFromComposedParent(newChildParent, newChild);
}
remove(newChild);
nativeInsertBefore.call(parentNode, newChild, refChild || null);
newChild._composedParent = parentNode;
}
function remove(node) {
var parentNode = getComposedParent(node);
if (parentNode) {
node._composedParent = null;
nativeRemoveChild.call(parentNode, node);
}
}
function ensureComposedParent(parent, children) {
for (var i = 0, n; i < children.length; i++) {
children[i]._composedParent = parent;
}
}
function getTopDistributingHost(host) {
while (host && hostNeedsRedistribution(host)) {
host = host.domHost;
}
return host;
}
function hostNeedsRedistribution(host) {
var c$ = Polymer.dom(host).children;
for (var i = 0, c; i < c$.length; i++) {
c = c$[i];
if (c.localName === 'content') {
return host.domHost;
}
}
}
var needsUpgrade = window.CustomElements && !CustomElements.useNative;
function upgradeLightChildren(children) {
if (needsUpgrade && children) {
for (var i = 0; i < children.length; i++) {
CustomElements.upgrade(children[i]);
}
}
}
}());
if (Polymer.Settings.useShadow) {
Polymer.Base._addFeature({
_poolContent: function () {
},
_beginDistribute: function () {
},
distributeContent: function () {
},
_distributeContent: function () {
},
_finishDistribute: function () {
},
_createLocalRoot: function () {
this.createShadowRoot();
this.shadowRoot.appendChild(this.root);
this.root = this.shadowRoot;
}
});
}
Polymer.DomModule = document.createElement('dom-module');
Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepAttributes();
this._prepBehaviors();
this._prepConstructor();
this._prepTemplate();
this._prepShady();
},
_prepBehavior: function (b) {
this._addHostAttributes(b.hostAttributes);
},
_initFeatures: function () {
this._poolContent();
this._pushHost();
this._stampTemplate();
this._popHost();
this._marshalHostAttributes();
this._setupDebouncers();
this._marshalBehaviors();
this._tryReady();
},
_marshalBehavior: function (b) {
}
});</script>

<script>Polymer.nar = [];
Polymer.Annotations = {
parseAnnotations: function (template) {
var list = [];
var content = template._content || template.content;
this._parseNodeAnnotations(content, list);
return list;
},
_parseNodeAnnotations: function (node, list) {
return node.nodeType === Node.TEXT_NODE ? this._parseTextNodeAnnotation(node, list) : this._parseElementAnnotations(node, list);
},
_testEscape: function (value) {
var escape = value.slice(0, 2);
if (escape === '{{' || escape === '[[') {
return escape;
}
},
_parseTextNodeAnnotation: function (node, list) {
var v = node.textContent;
var escape = this._testEscape(v);
if (escape) {
node.textContent = ' ';
var annote = {
bindings: [{
kind: 'text',
mode: escape[0],
value: v.slice(2, -2).trim()
}]
};
list.push(annote);
return annote;
}
},
_parseElementAnnotations: function (element, list) {
var annote = {
bindings: [],
events: []
};
if (element.localName === 'content') {
list._hasContent = true;
}
this._parseChildNodesAnnotations(element, annote, list);
if (element.attributes) {
this._parseNodeAttributeAnnotations(element, annote, list);
if (this.prepElement) {
this.prepElement(element);
}
}
if (annote.bindings.length || annote.events.length || annote.id) {
list.push(annote);
}
return annote;
},
_parseChildNodesAnnotations: function (root, annote, list, callback) {
if (root.firstChild) {
for (var i = 0, node = root.firstChild; node; node = node.nextSibling, i++) {
if (node.localName === 'template' && !node.hasAttribute('preserve-content')) {
this._parseTemplate(node, i, list, annote);
}
if (node.nodeType === Node.TEXT_NODE) {
var n = node.nextSibling;
while (n && n.nodeType === Node.TEXT_NODE) {
node.textContent += n.textContent;
root.removeChild(n);
n = n.nextSibling;
}
}
var childAnnotation = this._parseNodeAnnotations(node, list, callback);
if (childAnnotation) {
childAnnotation.parent = annote;
childAnnotation.index = i;
}
}
}
},
_parseTemplate: function (node, index, list, parent) {
var content = document.createDocumentFragment();
content._notes = this.parseAnnotations(node);
content.appendChild(node.content);
list.push({
bindings: Polymer.nar,
events: Polymer.nar,
templateContent: content,
parent: parent,
index: index
});
},
_parseNodeAttributeAnnotations: function (node, annotation) {
for (var i = node.attributes.length - 1, a; a = node.attributes[i]; i--) {
var n = a.name, v = a.value;
if (n === 'id' && !this._testEscape(v)) {
annotation.id = v;
} else if (n.slice(0, 3) === 'on-') {
node.removeAttribute(n);
annotation.events.push({
name: n.slice(3),
value: v
});
} else {
var b = this._parseNodeAttributeAnnotation(node, n, v);
if (b) {
annotation.bindings.push(b);
}
}
}
},
_parseNodeAttributeAnnotation: function (node, n, v) {
var escape = this._testEscape(v);
if (escape) {
var customEvent;
var name = n;
var mode = escape[0];
v = v.slice(2, -2).trim();
var not = false;
if (v[0] == '!') {
v = v.substring(1);
not = true;
}
var kind = 'property';
if (n[n.length - 1] == '$') {
name = n.slice(0, -1);
kind = 'attribute';
}
var notifyEvent, colon;
if (mode == '{' && (colon = v.indexOf('::')) > 0) {
notifyEvent = v.substring(colon + 2);
v = v.substring(0, colon);
customEvent = true;
}
if (node.localName == 'input' && n == 'value') {
node.setAttribute(n, '');
}
node.removeAttribute(n);
if (kind === 'property') {
name = Polymer.CaseMap.dashToCamelCase(name);
}
return {
kind: kind,
mode: mode,
name: name,
value: v,
negate: not,
event: notifyEvent,
customEvent: customEvent
};
}
},
_localSubTree: function (node, host) {
return node === host ? node.childNodes : node._lightChildren || node.childNodes;
},
findAnnotatedNode: function (root, annote) {
var parent = annote.parent && Polymer.Annotations.findAnnotatedNode(root, annote.parent);
return !parent ? root : Polymer.Annotations._localSubTree(parent, root)[annote.index];
}
};
(function () {
function resolveCss(cssText, ownerDocument) {
return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
return pre + '\'' + resolve(url.replace(/["']/g, ''), ownerDocument) + '\'' + post;
});
}
function resolveAttrs(element, ownerDocument) {
for (var name in URL_ATTRS) {
var a$ = URL_ATTRS[name];
for (var i = 0, l = a$.length, a, at, v; i < l && (a = a$[i]); i++) {
if (name === '*' || element.localName === name) {
at = element.attributes[a];
v = at && at.value;
if (v && v.search(BINDING_RX) < 0) {
at.value = a === 'style' ? resolveCss(v, ownerDocument) : resolve(v, ownerDocument);
}
}
}
}
}
function resolve(url, ownerDocument) {
if (url && url[0] === '#') {
return url;
}
var resolver = getUrlResolver(ownerDocument);
resolver.href = url;
return resolver.href || url;
}
var tempDoc;
var tempDocBase;
function resolveUrl(url, baseUri) {
if (!tempDoc) {
tempDoc = document.implementation.createHTMLDocument('temp');
tempDocBase = tempDoc.createElement('base');
tempDoc.head.appendChild(tempDocBase);
}
tempDocBase.href = baseUri;
return resolve(url, tempDoc);
}
function getUrlResolver(ownerDocument) {
return ownerDocument.__urlResolver || (ownerDocument.__urlResolver = ownerDocument.createElement('a'));
}
var CSS_URL_RX = /(url\()([^)]*)(\))/g;
var URL_ATTRS = {
'*': [
'href',
'src',
'style',
'url'
],
form: ['action']
};
var BINDING_RX = /\{\{|\[\[/;
Polymer.ResolveUrl = {
resolveCss: resolveCss,
resolveAttrs: resolveAttrs,
resolveUrl: resolveUrl
};
}());
Polymer.Base._addFeature({
_prepAnnotations: function () {
if (!this._template) {
this._notes = [];
} else {
Polymer.Annotations.prepElement = this._prepElement.bind(this);
if (this._template._content && this._template._content._notes) {
this._notes = this._template._content._notes;
} else {
this._notes = Polymer.Annotations.parseAnnotations(this._template);
}
this._processAnnotations(this._notes);
Polymer.Annotations.prepElement = null;
}
},
_processAnnotations: function (notes) {
for (var i = 0; i < notes.length; i++) {
var note = notes[i];
for (var j = 0; j < note.bindings.length; j++) {
var b = note.bindings[j];
b.signature = this._parseMethod(b.value);
if (!b.signature) {
b.model = this._modelForPath(b.value);
}
}
if (note.templateContent) {
this._processAnnotations(note.templateContent._notes);
var pp = note.templateContent._parentProps = this._discoverTemplateParentProps(note.templateContent._notes);
var bindings = [];
for (var prop in pp) {
bindings.push({
index: note.index,
kind: 'property',
mode: '{',
name: '_parent_' + prop,
model: prop,
value: prop
});
}
note.bindings = note.bindings.concat(bindings);
}
}
},
_discoverTemplateParentProps: function (notes) {
var pp = {};
notes.forEach(function (n) {
n.bindings.forEach(function (b) {
if (b.signature) {
var args = b.signature.args;
for (var k = 0; k < args.length; k++) {
pp[args[k].model] = true;
}
} else {
pp[b.model] = true;
}
});
if (n.templateContent) {
var tpp = n.templateContent._parentProps;
Polymer.Base.mixin(pp, tpp);
}
});
return pp;
},
_prepElement: function (element) {
Polymer.ResolveUrl.resolveAttrs(element, this._template.ownerDocument);
},
_findAnnotatedNode: Polymer.Annotations.findAnnotatedNode,
_marshalAnnotationReferences: function () {
if (this._template) {
this._marshalIdNodes();
this._marshalAnnotatedNodes();
this._marshalAnnotatedListeners();
}
},
_configureAnnotationReferences: function () {
this._configureTemplateContent();
},
_configureTemplateContent: function () {
this._notes.forEach(function (note, i) {
if (note.templateContent) {
this._nodes[i]._content = note.templateContent;
}
}, this);
},
_marshalIdNodes: function () {
this.$ = {};
this._notes.forEach(function (a) {
if (a.id) {
this.$[a.id] = this._findAnnotatedNode(this.root, a);
}
}, this);
},
_marshalAnnotatedNodes: function () {
if (this._nodes) {
this._nodes = this._nodes.map(function (a) {
return this._findAnnotatedNode(this.root, a);
}, this);
}
},
_marshalAnnotatedListeners: function () {
this._notes.forEach(function (a) {
if (a.events && a.events.length) {
var node = this._findAnnotatedNode(this.root, a);
a.events.forEach(function (e) {
this.listen(node, e.name, e.value);
}, this);
}
}, this);
}
});
Polymer.Base._addFeature({
listeners: {},
_listenListeners: function (listeners) {
var node, name, key;
for (key in listeners) {
if (key.indexOf('.') < 0) {
node = this;
name = key;
} else {
name = key.split('.');
node = this.$[name[0]];
name = name[1];
}
this.listen(node, name, listeners[key]);
}
},
listen: function (node, eventName, methodName) {
var handler = this._recallEventHandler(this, eventName, node, methodName);
if (!handler) {
handler = this._createEventHandler(node, eventName, methodName);
}
if (handler._listening) {
return;
}
this._listen(node, eventName, handler);
handler._listening = true;
},
_boundListenerKey: function (eventName, methodName) {
return eventName + ':' + methodName;
},
_recordEventHandler: function (host, eventName, target, methodName, handler) {
var hbl = host.__boundListeners;
if (!hbl) {
hbl = host.__boundListeners = new WeakMap();
}
var bl = hbl.get(target);
if (!bl) {
bl = {};
hbl.set(target, bl);
}
var key = this._boundListenerKey(eventName, methodName);
bl[key] = handler;
},
_recallEventHandler: function (host, eventName, target, methodName) {
var hbl = host.__boundListeners;
if (!hbl) {
return;
}
var bl = hbl.get(target);
if (!bl) {
return;
}
var key = this._boundListenerKey(eventName, methodName);
return bl[key];
},
_createEventHandler: function (node, eventName, methodName) {
var host = this;
var handler = function (e) {
if (host[methodName]) {
host[methodName](e, e.detail);
} else {
host._warn(host._logf('_createEventHandler', 'listener method `' + methodName + '` not defined'));
}
};
handler._listening = false;
this._recordEventHandler(host, eventName, node, methodName, handler);
return handler;
},
unlisten: function (node, eventName, methodName) {
var handler = this._recallEventHandler(this, eventName, node, methodName);
if (handler) {
this._unlisten(node, eventName, handler);
handler._listening = false;
}
},
_listen: function (node, eventName, handler) {
node.addEventListener(eventName, handler);
},
_unlisten: function (node, eventName, handler) {
node.removeEventListener(eventName, handler);
}
});
(function () {
'use strict';
var HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
var GESTURE_KEY = '__polymerGestures';
var HANDLED_OBJ = '__polymerGesturesHandled';
var TOUCH_ACTION = '__polymerGesturesTouchAction';
var TAP_DISTANCE = 25;
var TRACK_DISTANCE = 5;
var TRACK_LENGTH = 2;
var MOUSE_TIMEOUT = 2500;
var MOUSE_EVENTS = [
'mousedown',
'mousemove',
'mouseup',
'click'
];
var MOUSE_WHICH_TO_BUTTONS = [
0,
1,
4,
2
];
var MOUSE_HAS_BUTTONS = function () {
try {
return new MouseEvent('test', { buttons: 1 }).buttons === 1;
} catch (e) {
return false;
}
}();
var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);
var mouseCanceller = function (mouseEvent) {
mouseEvent[HANDLED_OBJ] = { skip: true };
if (mouseEvent.type === 'click') {
var path = Polymer.dom(mouseEvent).path;
for (var i = 0; i < path.length; i++) {
if (path[i] === POINTERSTATE.mouse.target) {
return;
}
}
mouseEvent.preventDefault();
mouseEvent.stopPropagation();
}
};
function setupTeardownMouseCanceller(setup) {
for (var i = 0, en; i < MOUSE_EVENTS.length; i++) {
en = MOUSE_EVENTS[i];
if (setup) {
document.addEventListener(en, mouseCanceller, true);
} else {
document.removeEventListener(en, mouseCanceller, true);
}
}
}
function ignoreMouse() {
if (IS_TOUCH_ONLY) {
return;
}
if (!POINTERSTATE.mouse.mouseIgnoreJob) {
setupTeardownMouseCanceller(true);
}
var unset = function () {
setupTeardownMouseCanceller();
POINTERSTATE.mouse.target = null;
POINTERSTATE.mouse.mouseIgnoreJob = null;
};
POINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debounce(POINTERSTATE.mouse.mouseIgnoreJob, unset, MOUSE_TIMEOUT);
}
function hasLeftMouseButton(ev) {
var type = ev.type;
if (MOUSE_EVENTS.indexOf(type) === -1) {
return false;
}
if (type === 'mousemove') {
var buttons = ev.buttons === undefined ? 1 : ev.buttons;
if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
}
return Boolean(buttons & 1);
} else {
var button = ev.button === undefined ? 0 : ev.button;
return button === 0;
}
}
function isSyntheticClick(ev) {
if (ev.type === 'click') {
if (ev.detail === 0) {
return true;
}
var t = Gestures.findOriginalTarget(ev);
var bcr = t.getBoundingClientRect();
var x = ev.pageX, y = ev.pageY;
return !(x >= bcr.left && x <= bcr.right && (y >= bcr.top && y <= bcr.bottom));
}
return false;
}
var POINTERSTATE = {
mouse: {
target: null,
mouseIgnoreJob: null
},
touch: {
x: 0,
y: 0,
id: -1,
scrollDecided: false
}
};
function firstTouchAction(ev) {
var path = Polymer.dom(ev).path;
var ta = 'auto';
for (var i = 0, n; i < path.length; i++) {
n = path[i];
if (n[TOUCH_ACTION]) {
ta = n[TOUCH_ACTION];
break;
}
}
return ta;
}
function trackDocument(stateObj, movefn, upfn) {
stateObj.movefn = movefn;
stateObj.upfn = upfn;
document.addEventListener('mousemove', movefn);
document.addEventListener('mouseup', upfn);
}
function untrackDocument(stateObj) {
document.removeEventListener('mousemove', stateObj.movefn);
document.removeEventListener('mouseup', stateObj.upfn);
}
var Gestures = {
gestures: {},
recognizers: [],
deepTargetFind: function (x, y) {
var node = document.elementFromPoint(x, y);
var next = node;
while (next && next.shadowRoot) {
next = next.shadowRoot.elementFromPoint(x, y);
if (next) {
node = next;
}
}
return node;
},
findOriginalTarget: function (ev) {
if (ev.path) {
return ev.path[0];
}
return ev.target;
},
handleNative: function (ev) {
var handled;
var type = ev.type;
var node = ev.currentTarget;
var gobj = node[GESTURE_KEY];
var gs = gobj[type];
if (!gs) {
return;
}
if (!ev[HANDLED_OBJ]) {
ev[HANDLED_OBJ] = {};
if (type.slice(0, 5) === 'touch') {
var t = ev.changedTouches[0];
if (type === 'touchstart') {
if (ev.touches.length === 1) {
POINTERSTATE.touch.id = t.identifier;
}
}
if (POINTERSTATE.touch.id !== t.identifier) {
return;
}
if (!HAS_NATIVE_TA) {
if (type === 'touchstart' || type === 'touchmove') {
Gestures.handleTouchAction(ev);
}
}
if (type === 'touchend') {
POINTERSTATE.mouse.target = Polymer.dom(ev).rootTarget;
ignoreMouse(true);
}
}
}
handled = ev[HANDLED_OBJ];
if (handled.skip) {
return;
}
var recognizers = Gestures.recognizers;
for (var i = 0, r; i < recognizers.length; i++) {
r = recognizers[i];
if (gs[r.name] && !handled[r.name]) {
if (r.flow && r.flow.start.indexOf(ev.type) > -1) {
if (r.reset) {
r.reset();
}
}
}
}
for (var i = 0, r; i < recognizers.length; i++) {
r = recognizers[i];
if (gs[r.name] && !handled[r.name]) {
handled[r.name] = true;
r[type](ev);
}
}
},
handleTouchAction: function (ev) {
var t = ev.changedTouches[0];
var type = ev.type;
if (type === 'touchstart') {
POINTERSTATE.touch.x = t.clientX;
POINTERSTATE.touch.y = t.clientY;
POINTERSTATE.touch.scrollDecided = false;
} else if (type === 'touchmove') {
if (POINTERSTATE.touch.scrollDecided) {
return;
}
POINTERSTATE.touch.scrollDecided = true;
var ta = firstTouchAction(ev);
var prevent = false;
var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
if (!ev.cancelable) {
} else if (ta === 'none') {
prevent = true;
} else if (ta === 'pan-x') {
prevent = dy > dx;
} else if (ta === 'pan-y') {
prevent = dx > dy;
}
if (prevent) {
ev.preventDefault();
} else {
Gestures.prevent('track');
}
}
},
add: function (node, evType, handler) {
var recognizer = this.gestures[evType];
var deps = recognizer.deps;
var name = recognizer.name;
var gobj = node[GESTURE_KEY];
if (!gobj) {
node[GESTURE_KEY] = gobj = {};
}
for (var i = 0, dep, gd; i < deps.length; i++) {
dep = deps[i];
if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1) {
continue;
}
gd = gobj[dep];
if (!gd) {
gobj[dep] = gd = { _count: 0 };
}
if (gd._count === 0) {
node.addEventListener(dep, this.handleNative);
}
gd[name] = (gd[name] || 0) + 1;
gd._count = (gd._count || 0) + 1;
}
node.addEventListener(evType, handler);
if (recognizer.touchAction) {
this.setTouchAction(node, recognizer.touchAction);
}
},
remove: function (node, evType, handler) {
var recognizer = this.gestures[evType];
var deps = recognizer.deps;
var name = recognizer.name;
var gobj = node[GESTURE_KEY];
if (gobj) {
for (var i = 0, dep, gd; i < deps.length; i++) {
dep = deps[i];
gd = gobj[dep];
if (gd && gd[name]) {
gd[name] = (gd[name] || 1) - 1;
gd._count = (gd._count || 1) - 1;
if (gd._count === 0) {
node.removeEventListener(dep, this.handleNative);
}
}
}
}
node.removeEventListener(evType, handler);
},
register: function (recog) {
this.recognizers.push(recog);
for (var i = 0; i < recog.emits.length; i++) {
this.gestures[recog.emits[i]] = recog;
}
},
findRecognizerByEvent: function (evName) {
for (var i = 0, r; i < this.recognizers.length; i++) {
r = this.recognizers[i];
for (var j = 0, n; j < r.emits.length; j++) {
n = r.emits[j];
if (n === evName) {
return r;
}
}
}
return null;
},
setTouchAction: function (node, value) {
if (HAS_NATIVE_TA) {
node.style.touchAction = value;
}
node[TOUCH_ACTION] = value;
},
fire: function (target, type, detail) {
var ev = Polymer.Base.fire(type, detail, {
node: target,
bubbles: true,
cancelable: true
});
if (ev.defaultPrevented) {
var se = detail.sourceEvent;
if (se && se.preventDefault) {
se.preventDefault();
}
}
},
prevent: function (evName) {
var recognizer = this.findRecognizerByEvent(evName);
if (recognizer.info) {
recognizer.info.prevent = true;
}
}
};
Gestures.register({
name: 'downup',
deps: [
'mousedown',
'touchstart',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'mouseup',
'touchend'
]
},
emits: [
'down',
'up'
],
info: {
movefn: function () {
},
upfn: function () {
}
},
reset: function () {
untrackDocument(this.info);
},
mousedown: function (e) {
if (!hasLeftMouseButton(e)) {
return;
}
var t = Gestures.findOriginalTarget(e);
var self = this;
var movefn = function movefn(e) {
if (!hasLeftMouseButton(e)) {
self.fire('up', t, e);
untrackDocument(self.info);
}
};
var upfn = function upfn(e) {
if (hasLeftMouseButton(e)) {
self.fire('up', t, e);
}
untrackDocument(self.info);
};
trackDocument(this.info, movefn, upfn);
this.fire('down', t, e);
},
touchstart: function (e) {
this.fire('down', Gestures.findOriginalTarget(e), e.changedTouches[0]);
},
touchend: function (e) {
this.fire('up', Gestures.findOriginalTarget(e), e.changedTouches[0]);
},
fire: function (type, target, event) {
var self = this;
Gestures.fire(target, type, {
x: event.clientX,
y: event.clientY,
sourceEvent: event,
prevent: Gestures.prevent.bind(Gestures)
});
}
});
Gestures.register({
name: 'track',
touchAction: 'none',
deps: [
'mousedown',
'touchstart',
'touchmove',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'mouseup',
'touchend'
]
},
emits: ['track'],
info: {
x: 0,
y: 0,
state: 'start',
started: false,
moves: [],
addMove: function (move) {
if (this.moves.length > TRACK_LENGTH) {
this.moves.shift();
}
this.moves.push(move);
},
movefn: function () {
},
upfn: function () {
},
prevent: false
},
reset: function () {
this.info.state = 'start';
this.info.started = false;
this.info.moves = [];
this.info.x = 0;
this.info.y = 0;
this.info.prevent = false;
untrackDocument(this.info);
},
hasMovedEnough: function (x, y) {
if (this.info.prevent) {
return false;
}
if (this.info.started) {
return true;
}
var dx = Math.abs(this.info.x - x);
var dy = Math.abs(this.info.y - y);
return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
},
mousedown: function (e) {
if (!hasLeftMouseButton(e)) {
return;
}
var t = Gestures.findOriginalTarget(e);
var self = this;
var movefn = function movefn(e) {
var x = e.clientX, y = e.clientY;
if (self.hasMovedEnough(x, y)) {
self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
self.info.addMove({
x: x,
y: y
});
if (!hasLeftMouseButton(e)) {
self.info.state = 'end';
untrackDocument(self.info);
}
self.fire(t, e);
self.info.started = true;
}
};
var upfn = function upfn(e) {
if (self.info.started) {
Gestures.prevent('tap');
movefn(e);
}
untrackDocument(self.info);
};
trackDocument(this.info, movefn, upfn);
this.info.x = e.clientX;
this.info.y = e.clientY;
},
touchstart: function (e) {
var ct = e.changedTouches[0];
this.info.x = ct.clientX;
this.info.y = ct.clientY;
},
touchmove: function (e) {
var t = Gestures.findOriginalTarget(e);
var ct = e.changedTouches[0];
var x = ct.clientX, y = ct.clientY;
if (this.hasMovedEnough(x, y)) {
this.info.addMove({
x: x,
y: y
});
this.fire(t, ct);
this.info.state = 'track';
this.info.started = true;
}
},
touchend: function (e) {
var t = Gestures.findOriginalTarget(e);
var ct = e.changedTouches[0];
if (this.info.started) {
Gestures.prevent('tap');
this.info.state = 'end';
this.info.addMove({
x: ct.clientX,
y: ct.clientY
});
this.fire(t, ct);
}
},
fire: function (target, touch) {
var secondlast = this.info.moves[this.info.moves.length - 2];
var lastmove = this.info.moves[this.info.moves.length - 1];
var dx = lastmove.x - this.info.x;
var dy = lastmove.y - this.info.y;
var ddx, ddy = 0;
if (secondlast) {
ddx = lastmove.x - secondlast.x;
ddy = lastmove.y - secondlast.y;
}
return Gestures.fire(target, 'track', {
state: this.info.state,
x: touch.clientX,
y: touch.clientY,
dx: dx,
dy: dy,
ddx: ddx,
ddy: ddy,
sourceEvent: touch,
hover: function () {
return Gestures.deepTargetFind(touch.clientX, touch.clientY);
}
});
}
});
Gestures.register({
name: 'tap',
deps: [
'mousedown',
'click',
'touchstart',
'touchend'
],
flow: {
start: [
'mousedown',
'touchstart'
],
end: [
'click',
'touchend'
]
},
emits: ['tap'],
info: {
x: NaN,
y: NaN,
prevent: false
},
reset: function () {
this.info.x = NaN;
this.info.y = NaN;
this.info.prevent = false;
},
save: function (e) {
this.info.x = e.clientX;
this.info.y = e.clientY;
},
mousedown: function (e) {
if (hasLeftMouseButton(e)) {
this.save(e);
}
},
click: function (e) {
if (hasLeftMouseButton(e)) {
this.forward(e);
}
},
touchstart: function (e) {
this.save(e.changedTouches[0]);
},
touchend: function (e) {
this.forward(e.changedTouches[0]);
},
forward: function (e) {
var dx = Math.abs(e.clientX - this.info.x);
var dy = Math.abs(e.clientY - this.info.y);
var t = Gestures.findOriginalTarget(e);
if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
if (!this.info.prevent) {
Gestures.fire(t, 'tap', {
x: e.clientX,
y: e.clientY,
sourceEvent: e
});
}
}
}
});
var DIRECTION_MAP = {
x: 'pan-x',
y: 'pan-y',
none: 'none',
all: 'auto'
};
Polymer.Base._addFeature({
_listen: function (node, eventName, handler) {
if (Gestures.gestures[eventName]) {
Gestures.add(node, eventName, handler);
} else {
node.addEventListener(eventName, handler);
}
},
_unlisten: function (node, eventName, handler) {
if (Gestures.gestures[eventName]) {
Gestures.remove(node, eventName, handler);
} else {
node.removeEventListener(eventName, handler);
}
},
setScrollDirection: function (direction, node) {
node = node || this;
Gestures.setTouchAction(node, DIRECTION_MAP[direction] || 'auto');
}
});
Polymer.Gestures = Gestures;
}());
Polymer.Async = {
_currVal: 0,
_lastVal: 0,
_callbacks: [],
_twiddleContent: 0,
_twiddle: document.createTextNode(''),
run: function (callback, waitTime) {
if (waitTime > 0) {
return ~setTimeout(callback, waitTime);
} else {
this._twiddle.textContent = this._twiddleContent++;
this._callbacks.push(callback);
return this._currVal++;
}
},
cancel: function (handle) {
if (handle < 0) {
clearTimeout(~handle);
} else {
var idx = handle - this._lastVal;
if (idx >= 0) {
if (!this._callbacks[idx]) {
throw 'invalid async handle: ' + handle;
}
this._callbacks[idx] = null;
}
}
},
_atEndOfMicrotask: function () {
var len = this._callbacks.length;
for (var i = 0; i < len; i++) {
var cb = this._callbacks[i];
if (cb) {
try {
cb();
} catch (e) {
i++;
this._callbacks.splice(0, i);
this._lastVal += i;
this._twiddle.textContent = this._twiddleContent++;
throw e;
}
}
}
this._callbacks.splice(0, len);
this._lastVal += len;
}
};
new (window.MutationObserver || JsMutationObserver)(Polymer.Async._atEndOfMicrotask.bind(Polymer.Async)).observe(Polymer.Async._twiddle, { characterData: true });
Polymer.Debounce = function () {
var Async = Polymer.Async;
var Debouncer = function (context) {
this.context = context;
this.boundComplete = this.complete.bind(this);
};
Debouncer.prototype = {
go: function (callback, wait) {
var h;
this.finish = function () {
Async.cancel(h);
};
h = Async.run(this.boundComplete, wait);
this.callback = callback;
},
stop: function () {
if (this.finish) {
this.finish();
this.finish = null;
}
},
complete: function () {
if (this.finish) {
this.stop();
this.callback.call(this.context);
}
}
};
function debounce(debouncer, callback, wait) {
if (debouncer) {
debouncer.stop();
} else {
debouncer = new Debouncer(this);
}
debouncer.go(callback, wait);
return debouncer;
}
return debounce;
}();
Polymer.Base._addFeature({
$$: function (slctr) {
return Polymer.dom(this.root).querySelector(slctr);
},
toggleClass: function (name, bool, node) {
node = node || this;
if (arguments.length == 1) {
bool = !node.classList.contains(name);
}
if (bool) {
Polymer.dom(node).classList.add(name);
} else {
Polymer.dom(node).classList.remove(name);
}
},
toggleAttribute: function (name, bool, node) {
node = node || this;
if (arguments.length == 1) {
bool = !node.hasAttribute(name);
}
if (bool) {
Polymer.dom(node).setAttribute(name, '');
} else {
Polymer.dom(node).removeAttribute(name);
}
},
classFollows: function (name, toElement, fromElement) {
if (fromElement) {
Polymer.dom(fromElement).classList.remove(name);
}
if (toElement) {
Polymer.dom(toElement).classList.add(name);
}
},
attributeFollows: function (name, toElement, fromElement) {
if (fromElement) {
Polymer.dom(fromElement).removeAttribute(name);
}
if (toElement) {
Polymer.dom(toElement).setAttribute(name, '');
}
},
getContentChildNodes: function (slctr) {
var content = Polymer.dom(this.root).querySelector(slctr || 'content');
return content ? Polymer.dom(content).getDistributedNodes() : [];
},
getContentChildren: function (slctr) {
return this.getContentChildNodes(slctr).filter(function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
},
fire: function (type, detail, options) {
options = options || Polymer.nob;
var node = options.node || this;
var detail = detail === null || detail === undefined ? Polymer.nob : detail;
var bubbles = options.bubbles === undefined ? true : options.bubbles;
var cancelable = Boolean(options.cancelable);
var event = new CustomEvent(type, {
bubbles: Boolean(bubbles),
cancelable: cancelable,
detail: detail
});
node.dispatchEvent(event);
return event;
},
async: function (callback, waitTime) {
return Polymer.Async.run(callback.bind(this), waitTime);
},
cancelAsync: function (handle) {
Polymer.Async.cancel(handle);
},
arrayDelete: function (path, item) {
var index;
if (Array.isArray(path)) {
index = path.indexOf(item);
if (index >= 0) {
return path.splice(index, 1);
}
} else {
var arr = this.get(path);
index = arr.indexOf(item);
if (index >= 0) {
return this.splice(path, index, 1);
}
}
},
transform: function (transform, node) {
node = node || this;
node.style.webkitTransform = transform;
node.style.transform = transform;
},
translate3d: function (x, y, z, node) {
node = node || this;
this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
},
importHref: function (href, onload, onerror) {
var l = document.createElement('link');
l.rel = 'import';
l.href = href;
if (onload) {
l.onload = onload.bind(this);
}
if (onerror) {
l.onerror = onerror.bind(this);
}
document.head.appendChild(l);
return l;
},
create: function (tag, props) {
var elt = document.createElement(tag);
if (props) {
for (var n in props) {
elt[n] = props[n];
}
}
return elt;
},
isLightDescendant: function (node) {
return this.contains(node) && Polymer.dom(this).getOwnerRoot() === Polymer.dom(node).getOwnerRoot();
},
isLocalDescendant: function (node) {
return this.root === Polymer.dom(node).getOwnerRoot();
}
});
Polymer.Bind = {
prepareModel: function (model) {
model._propertyEffects = {};
model._bindListeners = [];
Polymer.Base.mixin(model, this._modelApi);
},
_modelApi: {
_notifyChange: function (property) {
var eventName = Polymer.CaseMap.camelToDashCase(property) + '-changed';
Polymer.Base.fire(eventName, { value: this[property] }, {
bubbles: false,
node: this
});
},
_propertySetter: function (property, value, effects, fromAbove) {
var old = this.__data__[property];
if (old !== value && (old === old || value === value)) {
this.__data__[property] = value;
if (typeof value == 'object') {
this._clearPath(property);
}
if (this._propertyChanged) {
this._propertyChanged(property, value, old);
}
if (effects) {
this._effectEffects(property, value, effects, old, fromAbove);
}
}
return old;
},
__setProperty: function (property, value, quiet, node) {
node = node || this;
var effects = node._propertyEffects && node._propertyEffects[property];
if (effects) {
node._propertySetter(property, value, effects, quiet);
} else {
node[property] = value;
}
},
_effectEffects: function (property, value, effects, old, fromAbove) {
effects.forEach(function (fx) {
var fn = Polymer.Bind['_' + fx.kind + 'Effect'];
if (fn) {
fn.call(this, property, value, fx.effect, old, fromAbove);
}
}, this);
},
_clearPath: function (path) {
for (var prop in this.__data__) {
if (prop.indexOf(path + '.') === 0) {
this.__data__[prop] = undefined;
}
}
}
},
ensurePropertyEffects: function (model, property) {
var fx = model._propertyEffects[property];
if (!fx) {
fx = model._propertyEffects[property] = [];
}
return fx;
},
addPropertyEffect: function (model, property, kind, effect) {
var fx = this.ensurePropertyEffects(model, property);
fx.push({
kind: kind,
effect: effect
});
},
createBindings: function (model) {
var fx$ = model._propertyEffects;
if (fx$) {
for (var n in fx$) {
var fx = fx$[n];
fx.sort(this._sortPropertyEffects);
this._createAccessors(model, n, fx);
}
}
},
_sortPropertyEffects: function () {
var EFFECT_ORDER = {
'compute': 0,
'annotation': 1,
'computedAnnotation': 2,
'reflect': 3,
'notify': 4,
'observer': 5,
'complexObserver': 6,
'function': 7
};
return function (a, b) {
return EFFECT_ORDER[a.kind] - EFFECT_ORDER[b.kind];
};
}(),
_createAccessors: function (model, property, effects) {
var defun = {
get: function () {
return this.__data__[property];
}
};
var setter = function (value) {
this._propertySetter(property, value, effects);
};
var info = model.getPropertyInfo && model.getPropertyInfo(property);
if (info && info.readOnly) {
if (!info.computed) {
model['_set' + this.upper(property)] = setter;
}
} else {
defun.set = setter;
}
Object.defineProperty(model, property, defun);
},
upper: function (name) {
return name[0].toUpperCase() + name.substring(1);
},
_addAnnotatedListener: function (model, index, property, path, event) {
var fn = this._notedListenerFactory(property, path, this._isStructured(path), this._isEventBogus);
var eventName = event || Polymer.CaseMap.camelToDashCase(property) + '-changed';
model._bindListeners.push({
index: index,
property: property,
path: path,
changedFn: fn,
event: eventName
});
},
_isStructured: function (path) {
return path.indexOf('.') > 0;
},
_isEventBogus: function (e, target) {
return e.path && e.path[0] !== target;
},
_notedListenerFactory: function (property, path, isStructured, bogusTest) {
return function (e, target) {
if (!bogusTest(e, target)) {
if (e.detail && e.detail.path) {
this.notifyPath(this._fixPath(path, property, e.detail.path), e.detail.value);
} else {
var value = target[property];
if (!isStructured) {
this[path] = target[property];
} else {
if (this.__data__[path] != value) {
this.set(path, value);
}
}
}
}
};
},
prepareInstance: function (inst) {
inst.__data__ = Object.create(null);
},
setupBindListeners: function (inst) {
inst._bindListeners.forEach(function (info) {
var node = inst._nodes[info.index];
node.addEventListener(info.event, inst._notifyListener.bind(inst, info.changedFn));
});
}
};
Polymer.Base.extend(Polymer.Bind, {
_shouldAddListener: function (effect) {
return effect.name && effect.mode === '{' && !effect.negate && effect.kind != 'attribute';
},
_annotationEffect: function (source, value, effect) {
if (source != effect.value) {
value = this.get(effect.value);
this.__data__[effect.value] = value;
}
var calc = effect.negate ? !value : value;
if (!effect.customEvent || this._nodes[effect.index][effect.name] !== calc) {
return this._applyEffectValue(calc, effect);
}
},
_reflectEffect: function (source) {
this.reflectPropertyToAttribute(source);
},
_notifyEffect: function (source, value, effect, old, fromAbove) {
if (!fromAbove) {
this._notifyChange(source);
}
},
_functionEffect: function (source, value, fn, old, fromAbove) {
fn.call(this, source, value, old, fromAbove);
},
_observerEffect: function (source, value, effect, old) {
var fn = this[effect.method];
if (fn) {
fn.call(this, value, old);
} else {
this._warn(this._logf('_observerEffect', 'observer method `' + effect.method + '` not defined'));
}
},
_complexObserverEffect: function (source, value, effect) {
var fn = this[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
fn.apply(this, args);
}
} else {
this._warn(this._logf('_complexObserverEffect', 'observer method `' + effect.method + '` not defined'));
}
},
_computeEffect: function (source, value, effect) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
var fn = this[effect.method];
if (fn) {
this.__setProperty(effect.property, fn.apply(this, args));
} else {
this._warn(this._logf('_computeEffect', 'compute method `' + effect.method + '` not defined'));
}
}
},
_annotatedComputationEffect: function (source, value, effect) {
var computedHost = this._rootDataHost || this;
var fn = computedHost[effect.method];
if (fn) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
var computedvalue = fn.apply(computedHost, args);
if (effect.negate) {
computedvalue = !computedvalue;
}
this._applyEffectValue(computedvalue, effect);
}
} else {
computedHost._warn(computedHost._logf('_annotatedComputationEffect', 'compute method `' + effect.method + '` not defined'));
}
},
_marshalArgs: function (model, effect, path, value) {
var values = [];
var args = effect.args;
for (var i = 0, l = args.length; i < l; i++) {
var arg = args[i];
var name = arg.name;
var v;
if (arg.literal) {
v = arg.value;
} else if (arg.structured) {
v = Polymer.Base.get(name, model);
} else {
v = model[name];
}
if (args.length > 1 && v === undefined) {
return;
}
if (arg.wildcard) {
var baseChanged = name.indexOf(path + '.') === 0;
var matches = effect.trigger.name.indexOf(name) === 0 && !baseChanged;
values[i] = {
path: matches ? path : name,
value: matches ? value : v,
base: v
};
} else {
values[i] = v;
}
}
return values;
}
});
Polymer.Base._addFeature({
_addPropertyEffect: function (property, kind, effect) {
Polymer.Bind.addPropertyEffect(this, property, kind, effect);
},
_prepEffects: function () {
Polymer.Bind.prepareModel(this);
this._addAnnotationEffects(this._notes);
},
_prepBindings: function () {
Polymer.Bind.createBindings(this);
},
_addPropertyEffects: function (properties) {
if (properties) {
for (var p in properties) {
var prop = properties[p];
if (prop.observer) {
this._addObserverEffect(p, prop.observer);
}
if (prop.computed) {
prop.readOnly = true;
this._addComputedEffect(p, prop.computed);
}
if (prop.notify) {
this._addPropertyEffect(p, 'notify');
}
if (prop.reflectToAttribute) {
this._addPropertyEffect(p, 'reflect');
}
if (prop.readOnly) {
Polymer.Bind.ensurePropertyEffects(this, p);
}
}
}
},
_addComputedEffect: function (name, expression) {
var sig = this._parseMethod(expression);
sig.args.forEach(function (arg) {
this._addPropertyEffect(arg.model, 'compute', {
method: sig.method,
args: sig.args,
trigger: arg,
property: name
});
}, this);
},
_addObserverEffect: function (property, observer) {
this._addPropertyEffect(property, 'observer', {
method: observer,
property: property
});
},
_addComplexObserverEffects: function (observers) {
if (observers) {
observers.forEach(function (observer) {
this._addComplexObserverEffect(observer);
}, this);
}
},
_addComplexObserverEffect: function (observer) {
var sig = this._parseMethod(observer);
sig.args.forEach(function (arg) {
this._addPropertyEffect(arg.model, 'complexObserver', {
method: sig.method,
args: sig.args,
trigger: arg
});
}, this);
},
_addAnnotationEffects: function (notes) {
this._nodes = [];
notes.forEach(function (note) {
var index = this._nodes.push(note) - 1;
note.bindings.forEach(function (binding) {
this._addAnnotationEffect(binding, index);
}, this);
}, this);
},
_addAnnotationEffect: function (note, index) {
if (Polymer.Bind._shouldAddListener(note)) {
Polymer.Bind._addAnnotatedListener(this, index, note.name, note.value, note.event);
}
if (note.signature) {
this._addAnnotatedComputationEffect(note, index);
} else {
note.index = index;
this._addPropertyEffect(note.model, 'annotation', note);
}
},
_addAnnotatedComputationEffect: function (note, index) {
var sig = note.signature;
if (sig.static) {
this.__addAnnotatedComputationEffect('__static__', index, note, sig, null);
} else {
sig.args.forEach(function (arg) {
if (!arg.literal) {
this.__addAnnotatedComputationEffect(arg.model, index, note, sig, arg);
}
}, this);
}
},
__addAnnotatedComputationEffect: function (property, index, note, sig, trigger) {
this._addPropertyEffect(property, 'annotatedComputation', {
index: index,
kind: note.kind,
property: note.name,
negate: note.negate,
method: sig.method,
args: sig.args,
trigger: trigger
});
},
_parseMethod: function (expression) {
var m = expression.match(/([^\s]+)\((.*)\)/);
if (m) {
var sig = {
method: m[1],
static: true
};
if (m[2].trim()) {
var args = m[2].replace(/\\,/g, '&comma;').split(',');
return this._parseArgs(args, sig);
} else {
sig.args = Polymer.nar;
return sig;
}
}
},
_parseArgs: function (argList, sig) {
sig.args = argList.map(function (rawArg) {
var arg = this._parseArg(rawArg);
if (!arg.literal) {
sig.static = false;
}
return arg;
}, this);
return sig;
},
_parseArg: function (rawArg) {
var arg = rawArg.trim().replace(/&comma;/g, ',').replace(/\\(.)/g, '$1');
var a = {
name: arg,
model: this._modelForPath(arg)
};
var fc = arg[0];
if (fc === '-') {
fc = arg[1];
}
if (fc >= '0' && fc <= '9') {
fc = '#';
}
switch (fc) {
case '\'':
case '"':
a.value = arg.slice(1, -1);
a.literal = true;
break;
case '#':
a.value = Number(arg);
a.literal = true;
break;
}
if (!a.literal) {
a.structured = arg.indexOf('.') > 0;
if (a.structured) {
a.wildcard = arg.slice(-2) == '.*';
if (a.wildcard) {
a.name = arg.slice(0, -2);
}
}
}
return a;
},
_marshalInstanceEffects: function () {
Polymer.Bind.prepareInstance(this);
Polymer.Bind.setupBindListeners(this);
},
_applyEffectValue: function (value, info) {
var node = this._nodes[info.index];
var property = info.property || info.name || 'textContent';
if (info.kind == 'attribute') {
this.serializeValueToAttribute(value, property, node);
} else {
if (property === 'className') {
value = this._scopeElementClass(node, value);
}
if (property === 'textContent' || node.localName == 'input' && property == 'value') {
value = value == undefined ? '' : value;
}
return node[property] = value;
}
},
_executeStaticEffects: function () {
if (this._propertyEffects.__static__) {
this._effectEffects('__static__', null, this._propertyEffects.__static__);
}
}
});
Polymer.Base._addFeature({
_setupConfigure: function (initialConfig) {
this._config = {};
for (var i in initialConfig) {
if (initialConfig[i] !== undefined) {
this._config[i] = initialConfig[i];
}
}
this._handlers = [];
},
_marshalAttributes: function () {
this._takeAttributesToModel(this._config);
},
_attributeChangedImpl: function (name) {
var model = this._clientsReadied ? this : this._config;
this._setAttributeToProperty(model, name);
},
_configValue: function (name, value) {
this._config[name] = value;
},
_beforeClientsReady: function () {
this._configure();
},
_configure: function () {
this._configureAnnotationReferences();
this._aboveConfig = this.mixin({}, this._config);
var config = {};
this.behaviors.forEach(function (b) {
this._configureProperties(b.properties, config);
}, this);
this._configureProperties(this.properties, config);
this._mixinConfigure(config, this._aboveConfig);
this._config = config;
this._distributeConfig(this._config);
},
_configureProperties: function (properties, config) {
for (var i in properties) {
var c = properties[i];
if (c.value !== undefined) {
var value = c.value;
if (typeof value == 'function') {
value = value.call(this, this._config);
}
config[i] = value;
}
}
},
_mixinConfigure: function (a, b) {
for (var prop in b) {
if (!this.getPropertyInfo(prop).readOnly) {
a[prop] = b[prop];
}
}
},
_distributeConfig: function (config) {
var fx$ = this._propertyEffects;
if (fx$) {
for (var p in config) {
var fx = fx$[p];
if (fx) {
for (var i = 0, l = fx.length, x; i < l && (x = fx[i]); i++) {
if (x.kind === 'annotation') {
var node = this._nodes[x.effect.index];
if (node._configValue) {
var value = p === x.effect.value ? config[p] : this.get(x.effect.value, config);
node._configValue(x.effect.name, value);
}
}
}
}
}
}
},
_afterClientsReady: function () {
this._executeStaticEffects();
this._applyConfig(this._config, this._aboveConfig);
this._flushHandlers();
},
_applyConfig: function (config, aboveConfig) {
for (var n in config) {
if (this[n] === undefined) {
this.__setProperty(n, config[n], n in aboveConfig);
}
}
},
_notifyListener: function (fn, e) {
if (!this._clientsReadied) {
this._queueHandler([
fn,
e,
e.target
]);
} else {
return fn.call(this, e, e.target);
}
},
_queueHandler: function (args) {
this._handlers.push(args);
},
_flushHandlers: function () {
var h$ = this._handlers;
for (var i = 0, l = h$.length, h; i < l && (h = h$[i]); i++) {
h[0].call(this, h[1], h[2]);
}
this._handlers = [];
}
});
(function () {
'use strict';
Polymer.Base._addFeature({
notifyPath: function (path, value, fromAbove) {
var old = this._propertySetter(path, value);
if (old !== value && (old === old || value === value)) {
this._pathEffector(path, value);
if (!fromAbove) {
this._notifyPath(path, value);
}
return true;
}
},
_getPathParts: function (path) {
if (Array.isArray(path)) {
var parts = [];
for (var i = 0; i < path.length; i++) {
var args = path[i].toString().split('.');
for (var j = 0; j < args.length; j++) {
parts.push(args[j]);
}
}
return parts;
} else {
return path.toString().split('.');
}
},
set: function (path, value, root) {
var prop = root || this;
var parts = this._getPathParts(path);
var array;
var last = parts[parts.length - 1];
if (parts.length > 1) {
for (var i = 0; i < parts.length - 1; i++) {
var part = parts[i];
prop = prop[part];
if (array && parseInt(part) == part) {
parts[i] = Polymer.Collection.get(array).getKey(prop);
}
if (!prop) {
return;
}
array = Array.isArray(prop) ? prop : null;
}
if (array && parseInt(last) == last) {
var coll = Polymer.Collection.get(array);
var old = prop[last];
var key = coll.getKey(old);
parts[i] = key;
coll.setItem(key, value);
}
prop[last] = value;
if (!root) {
this.notifyPath(parts.join('.'), value);
}
} else {
prop[path] = value;
}
},
get: function (path, root) {
var prop = root || this;
var parts = this._getPathParts(path);
var last = parts.pop();
while (parts.length) {
prop = prop[parts.shift()];
if (!prop) {
return;
}
}
return prop[last];
},
_pathEffector: function (path, value) {
var model = this._modelForPath(path);
var fx$ = this._propertyEffects[model];
if (fx$) {
fx$.forEach(function (fx) {
var fxFn = this['_' + fx.kind + 'PathEffect'];
if (fxFn) {
fxFn.call(this, path, value, fx.effect);
}
}, this);
}
if (this._boundPaths) {
this._notifyBoundPaths(path, value);
}
},
_annotationPathEffect: function (path, value, effect) {
if (effect.value === path || effect.value.indexOf(path + '.') === 0) {
Polymer.Bind._annotationEffect.call(this, path, value, effect);
} else if (path.indexOf(effect.value + '.') === 0 && !effect.negate) {
var node = this._nodes[effect.index];
if (node && node.notifyPath) {
var p = this._fixPath(effect.name, effect.value, path);
node.notifyPath(p, value, true);
}
}
},
_complexObserverPathEffect: function (path, value, effect) {
if (this._pathMatchesEffect(path, effect)) {
Polymer.Bind._complexObserverEffect.call(this, path, value, effect);
}
},
_computePathEffect: function (path, value, effect) {
if (this._pathMatchesEffect(path, effect)) {
Polymer.Bind._computeEffect.call(this, path, value, effect);
}
},
_annotatedComputationPathEffect: function (path, value, effect) {
if (this._pathMatchesEffect(path, effect)) {
Polymer.Bind._annotatedComputationEffect.call(this, path, value, effect);
}
},
_pathMatchesEffect: function (path, effect) {
var effectArg = effect.trigger.name;
return effectArg == path || effectArg.indexOf(path + '.') === 0 || effect.trigger.wildcard && path.indexOf(effectArg) === 0;
},
linkPaths: function (to, from) {
this._boundPaths = this._boundPaths || {};
if (from) {
this._boundPaths[to] = from;
} else {
this.unlinkPaths(to);
}
},
unlinkPaths: function (path) {
if (this._boundPaths) {
delete this._boundPaths[path];
}
},
_notifyBoundPaths: function (path, value) {
for (var a in this._boundPaths) {
var b = this._boundPaths[a];
if (path.indexOf(a + '.') == 0) {
this.notifyPath(this._fixPath(b, a, path), value);
} else if (path.indexOf(b + '.') == 0) {
this.notifyPath(this._fixPath(a, b, path), value);
}
}
},
_fixPath: function (property, root, path) {
return property + path.slice(root.length);
},
_notifyPath: function (path, value) {
var rootName = this._modelForPath(path);
var dashCaseName = Polymer.CaseMap.camelToDashCase(rootName);
var eventName = dashCaseName + this._EVENT_CHANGED;
this.fire(eventName, {
path: path,
value: value
}, { bubbles: false });
},
_modelForPath: function (path) {
var dot = path.indexOf('.');
return dot < 0 ? path : path.slice(0, dot);
},
_EVENT_CHANGED: '-changed',
_notifySplice: function (array, path, index, added, removed) {
var splices = [{
index: index,
addedCount: added,
removed: removed,
object: array,
type: 'splice'
}];
var change = {
keySplices: Polymer.Collection.applySplices(array, splices),
indexSplices: splices
};
this.set(path + '.splices', change);
if (added != removed.length) {
this.notifyPath(path + '.length', array.length);
}
change.keySplices = null;
change.indexSplices = null;
},
push: function (path) {
var array = this.get(path);
var args = Array.prototype.slice.call(arguments, 1);
var len = array.length;
var ret = array.push.apply(array, args);
if (args.length) {
this._notifySplice(array, path, len, args.length, []);
}
return ret;
},
pop: function (path) {
var array = this.get(path);
var hadLength = Boolean(array.length);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.pop.apply(array, args);
if (hadLength) {
this._notifySplice(array, path, array.length, 0, [ret]);
}
return ret;
},
splice: function (path, start, deleteCount) {
var array = this.get(path);
if (start < 0) {
start = array.length - Math.floor(-start);
} else {
start = Math.floor(start);
}
if (!start) {
start = 0;
}
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.splice.apply(array, args);
var addedCount = Math.max(args.length - 2, 0);
if (addedCount || ret.length) {
this._notifySplice(array, path, start, addedCount, ret);
}
return ret;
},
shift: function (path) {
var array = this.get(path);
var hadLength = Boolean(array.length);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.shift.apply(array, args);
if (hadLength) {
this._notifySplice(array, path, 0, 0, [ret]);
}
return ret;
},
unshift: function (path) {
var array = this.get(path);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.unshift.apply(array, args);
if (args.length) {
this._notifySplice(array, path, 0, args.length, []);
}
return ret;
},
prepareModelNotifyPath: function (model) {
this.mixin(model, {
fire: Polymer.Base.fire,
notifyPath: Polymer.Base.notifyPath,
_EVENT_CHANGED: Polymer.Base._EVENT_CHANGED,
_notifyPath: Polymer.Base._notifyPath,
_pathEffector: Polymer.Base._pathEffector,
_annotationPathEffect: Polymer.Base._annotationPathEffect,
_complexObserverPathEffect: Polymer.Base._complexObserverPathEffect,
_annotatedComputationPathEffect: Polymer.Base._annotatedComputationPathEffect,
_computePathEffect: Polymer.Base._computePathEffect,
_modelForPath: Polymer.Base._modelForPath,
_pathMatchesEffect: Polymer.Base._pathMatchesEffect,
_notifyBoundPaths: Polymer.Base._notifyBoundPaths
});
}
});
}());
Polymer.Base._addFeature({
resolveUrl: function (url) {
var module = Polymer.DomModule.import(this.is);
var root = '';
if (module) {
var assetPath = module.getAttribute('assetpath') || '';
root = Polymer.ResolveUrl.resolveUrl(assetPath, module.ownerDocument.baseURI);
}
return Polymer.ResolveUrl.resolveUrl(url, root);
}
});
Polymer.CssParse = function () {
var api = {
parse: function (text) {
text = this._clean(text);
return this._parseCss(this._lex(text), text);
},
_clean: function (cssText) {
return cssText.replace(this._rx.comments, '').replace(this._rx.port, '');
},
_lex: function (text) {
var root = {
start: 0,
end: text.length
};
var n = root;
for (var i = 0, s = 0, l = text.length; i < l; i++) {
switch (text[i]) {
case this.OPEN_BRACE:
if (!n.rules) {
n.rules = [];
}
var p = n;
var previous = p.rules[p.rules.length - 1];
n = {
start: i + 1,
parent: p,
previous: previous
};
p.rules.push(n);
break;
case this.CLOSE_BRACE:
n.end = i + 1;
n = n.parent || root;
break;
}
}
return root;
},
_parseCss: function (node, text) {
var t = text.substring(node.start, node.end - 1);
node.parsedCssText = node.cssText = t.trim();
if (node.parent) {
var ss = node.previous ? node.previous.end : node.parent.start;
t = text.substring(ss, node.start - 1);
t = t.substring(t.lastIndexOf(';') + 1);
var s = node.parsedSelector = node.selector = t.trim();
node.atRule = s.indexOf(this.AT_START) === 0;
if (node.atRule) {
if (s.indexOf(this.MEDIA_START) === 0) {
node.type = this.types.MEDIA_RULE;
} else if (s.match(this._rx.keyframesRule)) {
node.type = this.types.KEYFRAMES_RULE;
}
} else {
if (s.indexOf(this.VAR_START) === 0) {
node.type = this.types.MIXIN_RULE;
} else {
node.type = this.types.STYLE_RULE;
}
}
}
var r$ = node.rules;
if (r$) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
this._parseCss(r, text);
}
}
return node;
},
stringify: function (node, preserveProperties, text) {
text = text || '';
var cssText = '';
if (node.cssText || node.rules) {
var r$ = node.rules;
if (r$ && (preserveProperties || !this._hasMixinRules(r$))) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
cssText = this.stringify(r, preserveProperties, cssText);
}
} else {
cssText = preserveProperties ? node.cssText : this.removeCustomProps(node.cssText);
cssText = cssText.trim();
if (cssText) {
cssText = '  ' + cssText + '\n';
}
}
}
if (cssText) {
if (node.selector) {
text += node.selector + ' ' + this.OPEN_BRACE + '\n';
}
text += cssText;
if (node.selector) {
text += this.CLOSE_BRACE + '\n\n';
}
}
return text;
},
_hasMixinRules: function (rules) {
return rules[0].selector.indexOf(this.VAR_START) >= 0;
},
removeCustomProps: function (cssText) {
cssText = this.removeCustomPropAssignment(cssText);
return this.removeCustomPropApply(cssText);
},
removeCustomPropAssignment: function (cssText) {
return cssText.replace(this._rx.customProp, '').replace(this._rx.mixinProp, '');
},
removeCustomPropApply: function (cssText) {
return cssText.replace(this._rx.mixinApply, '').replace(this._rx.varApply, '');
},
types: {
STYLE_RULE: 1,
KEYFRAMES_RULE: 7,
MEDIA_RULE: 4,
MIXIN_RULE: 1000
},
OPEN_BRACE: '{',
CLOSE_BRACE: '}',
_rx: {
comments: /\/\*[^*]*\*+([^\/*][^*]*\*+)*\//gim,
port: /@import[^;]*;/gim,
customProp: /(?:^|[\s;])--[^;{]*?:[^{};]*?(?:[;\n]|$)/gim,
mixinProp: /(?:^|[\s;])--[^;{]*?:[^{;]*?{[^}]*?}(?:[;\n]|$)?/gim,
mixinApply: /@apply[\s]*\([^)]*?\)[\s]*(?:[;\n]|$)?/gim,
varApply: /[^;:]*?:[^;]*var[^;]*(?:[;\n]|$)?/gim,
keyframesRule: /^@[^\s]*keyframes/
},
VAR_START: '--',
MEDIA_START: '@media',
AT_START: '@'
};
return api;
}();
Polymer.StyleUtil = function () {
return {
MODULE_STYLES_SELECTOR: 'style, link[rel=import][type~=css], template',
INCLUDE_ATTR: 'include',
toCssText: function (rules, callback, preserveProperties) {
if (typeof rules === 'string') {
rules = this.parser.parse(rules);
}
if (callback) {
this.forEachStyleRule(rules, callback);
}
return this.parser.stringify(rules, preserveProperties);
},
forRulesInStyles: function (styles, callback) {
if (styles) {
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
this.forEachStyleRule(this.rulesForStyle(s), callback);
}
}
},
rulesForStyle: function (style) {
if (!style.__cssRules && style.textContent) {
style.__cssRules = this.parser.parse(style.textContent);
}
return style.__cssRules;
},
clearStyleRules: function (style) {
style.__cssRules = null;
},
forEachStyleRule: function (node, callback) {
if (!node) {
return;
}
var s = node.parsedSelector;
var skipRules = false;
if (node.type === this.ruleTypes.STYLE_RULE) {
callback(node);
} else if (node.type === this.ruleTypes.KEYFRAMES_RULE || node.type === this.ruleTypes.MIXIN_RULE) {
skipRules = true;
}
var r$ = node.rules;
if (r$ && !skipRules) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
this.forEachStyleRule(r, callback);
}
}
},
applyCss: function (cssText, moniker, target, afterNode) {
var style = document.createElement('style');
if (moniker) {
style.setAttribute('scope', moniker);
}
style.textContent = cssText;
target = target || document.head;
if (!afterNode) {
var n$ = target.querySelectorAll('style[scope]');
afterNode = n$[n$.length - 1];
}
target.insertBefore(style, afterNode && afterNode.nextSibling || target.firstChild);
return style;
},
cssFromModules: function (moduleIds, warnIfNotFound) {
var modules = moduleIds.trim().split(' ');
var cssText = '';
for (var i = 0; i < modules.length; i++) {
cssText += this.cssFromModule(modules[i], warnIfNotFound);
}
return cssText;
},
cssFromModule: function (moduleId, warnIfNotFound) {
var m = Polymer.DomModule.import(moduleId);
if (m && !m._cssText) {
m._cssText = this._cssFromElement(m);
}
if (!m && warnIfNotFound) {
console.warn('Could not find style data in module named', moduleId);
}
return m && m._cssText || '';
},
_cssFromElement: function (element) {
var cssText = '';
var content = element.content || element;
var e$ = Array.prototype.slice.call(content.querySelectorAll(this.MODULE_STYLES_SELECTOR));
for (var i = 0, e; i < e$.length; i++) {
e = e$[i];
if (e.localName === 'template') {
cssText += this._cssFromElement(e);
} else {
if (e.localName === 'style') {
var include = e.getAttribute(this.INCLUDE_ATTR);
if (include) {
cssText += this.cssFromModules(include, true);
}
e = e.__appliedElement || e;
e.parentNode.removeChild(e);
cssText += this.resolveCss(e.textContent, element.ownerDocument);
} else if (e.import && e.import.body) {
cssText += this.resolveCss(e.import.body.textContent, e.import);
}
}
}
return cssText;
},
resolveCss: Polymer.ResolveUrl.resolveCss,
parser: Polymer.CssParse,
ruleTypes: Polymer.CssParse.types
};
}();
Polymer.StyleTransformer = function () {
var nativeShadow = Polymer.Settings.useNativeShadow;
var styleUtil = Polymer.StyleUtil;
var api = {
dom: function (node, scope, useAttr, shouldRemoveScope) {
this._transformDom(node, scope || '', useAttr, shouldRemoveScope);
},
_transformDom: function (node, selector, useAttr, shouldRemoveScope) {
if (node.setAttribute) {
this.element(node, selector, useAttr, shouldRemoveScope);
}
var c$ = Polymer.dom(node).childNodes;
for (var i = 0; i < c$.length; i++) {
this._transformDom(c$[i], selector, useAttr, shouldRemoveScope);
}
},
element: function (element, scope, useAttr, shouldRemoveScope) {
if (useAttr) {
if (shouldRemoveScope) {
element.removeAttribute(SCOPE_NAME);
} else {
element.setAttribute(SCOPE_NAME, scope);
}
} else {
if (scope) {
if (element.classList) {
if (shouldRemoveScope) {
element.classList.remove(SCOPE_NAME);
element.classList.remove(scope);
} else {
element.classList.add(SCOPE_NAME);
element.classList.add(scope);
}
} else if (element.getAttribute) {
var c = element.getAttribute(CLASS);
if (shouldRemoveScope) {
if (c) {
element.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));
}
} else {
element.setAttribute(CLASS, c + (c ? ' ' : '') + SCOPE_NAME + ' ' + scope);
}
}
}
}
},
elementStyles: function (element, callback) {
var styles = element._styles;
var cssText = '';
for (var i = 0, l = styles.length, s, text; i < l && (s = styles[i]); i++) {
var rules = styleUtil.rulesForStyle(s);
cssText += nativeShadow ? styleUtil.toCssText(rules, callback) : this.css(rules, element.is, element.extends, callback, element._scopeCssViaAttr) + '\n\n';
}
return cssText.trim();
},
css: function (rules, scope, ext, callback, useAttr) {
var hostScope = this._calcHostScope(scope, ext);
scope = this._calcElementScope(scope, useAttr);
var self = this;
return styleUtil.toCssText(rules, function (rule) {
if (!rule.isScoped) {
self.rule(rule, scope, hostScope);
rule.isScoped = true;
}
if (callback) {
callback(rule, scope, hostScope);
}
});
},
_calcElementScope: function (scope, useAttr) {
if (scope) {
return useAttr ? CSS_ATTR_PREFIX + scope + CSS_ATTR_SUFFIX : CSS_CLASS_PREFIX + scope;
} else {
return '';
}
},
_calcHostScope: function (scope, ext) {
return ext ? '[is=' + scope + ']' : scope;
},
rule: function (rule, scope, hostScope) {
this._transformRule(rule, this._transformComplexSelector, scope, hostScope);
},
_transformRule: function (rule, transformer, scope, hostScope) {
var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);
for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
p$[i] = transformer.call(this, p, scope, hostScope);
}
rule.selector = rule.transformedSelector = p$.join(COMPLEX_SELECTOR_SEP);
},
_transformComplexSelector: function (selector, scope, hostScope) {
var stop = false;
var hostContext = false;
var self = this;
selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {
if (!stop) {
var info = self._transformCompoundSelector(s, c, scope, hostScope);
stop = stop || info.stop;
hostContext = hostContext || info.hostContext;
c = info.combinator;
s = info.value;
} else {
s = s.replace(SCOPE_JUMP, ' ');
}
return c + s;
});
if (hostContext) {
selector = selector.replace(HOST_CONTEXT_PAREN, function (m, pre, paren, post) {
return pre + paren + ' ' + hostScope + post + COMPLEX_SELECTOR_SEP + ' ' + pre + hostScope + paren + post;
});
}
return selector;
},
_transformCompoundSelector: function (selector, combinator, scope, hostScope) {
var jumpIndex = selector.search(SCOPE_JUMP);
var hostContext = false;
if (selector.indexOf(HOST_CONTEXT) >= 0) {
hostContext = true;
} else if (selector.indexOf(HOST) >= 0) {
selector = selector.replace(HOST_PAREN, function (m, host, paren) {
return hostScope + paren;
});
selector = selector.replace(HOST, hostScope);
} else if (jumpIndex !== 0) {
selector = scope ? this._transformSimpleSelector(selector, scope) : selector;
}
if (selector.indexOf(CONTENT) >= 0) {
combinator = '';
}
var stop;
if (jumpIndex >= 0) {
selector = selector.replace(SCOPE_JUMP, ' ');
stop = true;
}
return {
value: selector,
combinator: combinator,
stop: stop,
hostContext: hostContext
};
},
_transformSimpleSelector: function (selector, scope) {
var p$ = selector.split(PSEUDO_PREFIX);
p$[0] += scope;
return p$.join(PSEUDO_PREFIX);
},
documentRule: function (rule) {
rule.selector = rule.parsedSelector;
this.normalizeRootSelector(rule);
if (!nativeShadow) {
this._transformRule(rule, this._transformDocumentSelector);
}
},
normalizeRootSelector: function (rule) {
if (rule.selector === ROOT) {
rule.selector = 'body';
}
},
_transformDocumentSelector: function (selector) {
return selector.match(SCOPE_JUMP) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);
},
SCOPE_NAME: 'style-scope'
};
var SCOPE_NAME = api.SCOPE_NAME;
var SCOPE_DOC_SELECTOR = ':not([' + SCOPE_NAME + '])' + ':not(.' + SCOPE_NAME + ')';
var COMPLEX_SELECTOR_SEP = ',';
var SIMPLE_SELECTOR_SEP = /(^|[\s>+~]+)([^\s>+~]+)/g;
var HOST = ':host';
var ROOT = ':root';
var HOST_PAREN = /(\:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/g;
var HOST_CONTEXT = ':host-context';
var HOST_CONTEXT_PAREN = /(.*)(?:\:host-context)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))(.*)/;
var CONTENT = '::content';
var SCOPE_JUMP = /\:\:content|\:\:shadow|\/deep\//;
var CSS_CLASS_PREFIX = '.';
var CSS_ATTR_PREFIX = '[' + SCOPE_NAME + '~=';
var CSS_ATTR_SUFFIX = ']';
var PSEUDO_PREFIX = ':';
var CLASS = 'class';
return api;
}();
Polymer.StyleExtends = function () {
var styleUtil = Polymer.StyleUtil;
return {
hasExtends: function (cssText) {
return Boolean(cssText.match(this.rx.EXTEND));
},
transform: function (style) {
var rules = styleUtil.rulesForStyle(style);
var self = this;
styleUtil.forEachStyleRule(rules, function (rule) {
var map = self._mapRule(rule);
if (rule.parent) {
var m;
while (m = self.rx.EXTEND.exec(rule.cssText)) {
var extend = m[1];
var extendor = self._findExtendor(extend, rule);
if (extendor) {
self._extendRule(rule, extendor);
}
}
}
rule.cssText = rule.cssText.replace(self.rx.EXTEND, '');
});
return styleUtil.toCssText(rules, function (rule) {
if (rule.selector.match(self.rx.STRIP)) {
rule.cssText = '';
}
}, true);
},
_mapRule: function (rule) {
if (rule.parent) {
var map = rule.parent.map || (rule.parent.map = {});
var parts = rule.selector.split(',');
for (var i = 0, p; i < parts.length; i++) {
p = parts[i];
map[p.trim()] = rule;
}
return map;
}
},
_findExtendor: function (extend, rule) {
return rule.parent && rule.parent.map && rule.parent.map[extend] || this._findExtendor(extend, rule.parent);
},
_extendRule: function (target, source) {
if (target.parent !== source.parent) {
this._cloneAndAddRuleToParent(source, target.parent);
}
target.extends = target.extends || (target.extends = []);
target.extends.push(source);
source.selector = source.selector.replace(this.rx.STRIP, '');
source.selector = (source.selector && source.selector + ',\n') + target.selector;
if (source.extends) {
source.extends.forEach(function (e) {
this._extendRule(target, e);
}, this);
}
},
_cloneAndAddRuleToParent: function (rule, parent) {
rule = Object.create(rule);
rule.parent = parent;
if (rule.extends) {
rule.extends = rule.extends.slice();
}
parent.rules.push(rule);
},
rx: {
EXTEND: /@extends\(([^)]*)\)\s*?;/gim,
STRIP: /%[^,]*$/
}
};
}();
(function () {
var prepElement = Polymer.Base._prepElement;
var nativeShadow = Polymer.Settings.useNativeShadow;
var styleUtil = Polymer.StyleUtil;
var styleTransformer = Polymer.StyleTransformer;
var styleExtends = Polymer.StyleExtends;
Polymer.Base._addFeature({
_prepElement: function (element) {
if (this._encapsulateStyle) {
styleTransformer.element(element, this.is, this._scopeCssViaAttr);
}
prepElement.call(this, element);
},
_prepStyles: function () {
if (this._encapsulateStyle === undefined) {
this._encapsulateStyle = !nativeShadow && Boolean(this._template);
}
this._styles = this._collectStyles();
var cssText = styleTransformer.elementStyles(this);
if (cssText && this._template) {
var style = styleUtil.applyCss(cssText, this.is, nativeShadow ? this._template.content : null);
if (!nativeShadow) {
this._scopeStyle = style;
}
}
},
_collectStyles: function () {
var styles = [];
var cssText = '', m$ = this.styleModules;
if (m$) {
for (var i = 0, l = m$.length, m; i < l && (m = m$[i]); i++) {
cssText += styleUtil.cssFromModule(m);
}
}
cssText += styleUtil.cssFromModule(this.is);
if (cssText) {
var style = document.createElement('style');
style.textContent = cssText;
if (styleExtends.hasExtends(style.textContent)) {
cssText = styleExtends.transform(style);
}
styles.push(style);
}
return styles;
},
_elementAdd: function (node) {
if (this._encapsulateStyle) {
if (node.__styleScoped) {
node.__styleScoped = false;
} else {
styleTransformer.dom(node, this.is, this._scopeCssViaAttr);
}
}
},
_elementRemove: function (node) {
if (this._encapsulateStyle) {
styleTransformer.dom(node, this.is, this._scopeCssViaAttr, true);
}
},
scopeSubtree: function (container, shouldObserve) {
if (nativeShadow) {
return;
}
var self = this;
var scopify = function (node) {
if (node.nodeType === Node.ELEMENT_NODE) {
node.className = self._scopeElementClass(node, node.className);
var n$ = node.querySelectorAll('*');
Array.prototype.forEach.call(n$, function (n) {
n.className = self._scopeElementClass(n, n.className);
});
}
};
scopify(container);
if (shouldObserve) {
var mo = new MutationObserver(function (mxns) {
mxns.forEach(function (m) {
if (m.addedNodes) {
for (var i = 0; i < m.addedNodes.length; i++) {
scopify(m.addedNodes[i]);
}
}
});
});
mo.observe(container, {
childList: true,
subtree: true
});
return mo;
}
}
});
}());
Polymer.StyleProperties = function () {
'use strict';
var nativeShadow = Polymer.Settings.useNativeShadow;
var matchesSelector = Polymer.DomApi.matchesSelector;
var styleUtil = Polymer.StyleUtil;
var styleTransformer = Polymer.StyleTransformer;
return {
decorateStyles: function (styles) {
var self = this, props = {};
styleUtil.forRulesInStyles(styles, function (rule) {
self.decorateRule(rule);
self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);
});
var names = [];
for (var i in props) {
names.push(i);
}
return names;
},
decorateRule: function (rule) {
if (rule.propertyInfo) {
return rule.propertyInfo;
}
var info = {}, properties = {};
var hasProperties = this.collectProperties(rule, properties);
if (hasProperties) {
info.properties = properties;
rule.rules = null;
}
info.cssText = this.collectCssText(rule);
rule.propertyInfo = info;
return info;
},
collectProperties: function (rule, properties) {
var info = rule.propertyInfo;
if (info) {
if (info.properties) {
Polymer.Base.mixin(properties, info.properties);
return true;
}
} else {
var m, rx = this.rx.VAR_ASSIGN;
var cssText = rule.parsedCssText;
var any;
while (m = rx.exec(cssText)) {
properties[m[1]] = (m[2] || m[3]).trim();
any = true;
}
return any;
}
},
collectCssText: function (rule) {
var customCssText = '';
var cssText = rule.parsedCssText;
cssText = cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');
var parts = cssText.split(';');
for (var i = 0, p; i < parts.length; i++) {
p = parts[i];
if (p.match(this.rx.MIXIN_MATCH) || p.match(this.rx.VAR_MATCH)) {
customCssText += p + ';\n';
}
}
return customCssText;
},
collectPropertiesInCssText: function (cssText, props) {
var m;
while (m = this.rx.VAR_CAPTURE.exec(cssText)) {
props[m[1]] = true;
var def = m[2];
if (def && def.match(this.rx.IS_VAR)) {
props[def] = true;
}
}
},
reify: function (props) {
var names = Object.getOwnPropertyNames(props);
for (var i = 0, n; i < names.length; i++) {
n = names[i];
props[n] = this.valueForProperty(props[n], props);
}
},
valueForProperty: function (property, props) {
if (property) {
if (property.indexOf(';') >= 0) {
property = this.valueForProperties(property, props);
} else {
var self = this;
var fn = function (all, prefix, value, fallback) {
var propertyValue = self.valueForProperty(props[value], props) || (props[fallback] ? self.valueForProperty(props[fallback], props) : fallback);
return prefix + (propertyValue || '');
};
property = property.replace(this.rx.VAR_MATCH, fn);
}
}
return property && property.trim() || '';
},
valueForProperties: function (property, props) {
var parts = property.split(';');
for (var i = 0, p, m; i < parts.length; i++) {
if (p = parts[i]) {
m = p.match(this.rx.MIXIN_MATCH);
if (m) {
p = this.valueForProperty(props[m[1]], props);
} else {
var pp = p.split(':');
if (pp[1]) {
pp[1] = pp[1].trim();
pp[1] = this.valueForProperty(pp[1], props) || pp[1];
}
p = pp.join(':');
}
parts[i] = p && p.lastIndexOf(';') === p.length - 1 ? p.slice(0, -1) : p || '';
}
}
return parts.join(';');
},
applyProperties: function (rule, props) {
var output = '';
if (!rule.propertyInfo) {
this.decorateRule(rule);
}
if (rule.propertyInfo.cssText) {
output = this.valueForProperties(rule.propertyInfo.cssText, props);
}
rule.cssText = output;
},
propertyDataFromStyles: function (styles, element) {
var props = {}, self = this;
var o = [], i = 0;
styleUtil.forRulesInStyles(styles, function (rule) {
if (!rule.propertyInfo) {
self.decorateRule(rule);
}
if (element && rule.propertyInfo.properties && matchesSelector.call(element, rule.transformedSelector || rule.parsedSelector)) {
self.collectProperties(rule, props);
addToBitMask(i, o);
}
i++;
});
return {
properties: props,
key: o
};
},
scopePropertiesFromStyles: function (styles) {
if (!styles._scopeStyleProperties) {
styles._scopeStyleProperties = this.selectedPropertiesFromStyles(styles, this.SCOPE_SELECTORS);
}
return styles._scopeStyleProperties;
},
hostPropertiesFromStyles: function (styles) {
if (!styles._hostStyleProperties) {
styles._hostStyleProperties = this.selectedPropertiesFromStyles(styles, this.HOST_SELECTORS);
}
return styles._hostStyleProperties;
},
selectedPropertiesFromStyles: function (styles, selectors) {
var props = {}, self = this;
styleUtil.forRulesInStyles(styles, function (rule) {
if (!rule.propertyInfo) {
self.decorateRule(rule);
}
for (var i = 0; i < selectors.length; i++) {
if (rule.parsedSelector === selectors[i]) {
self.collectProperties(rule, props);
return;
}
}
});
return props;
},
transformStyles: function (element, properties, scopeSelector) {
var self = this;
var hostSelector = styleTransformer._calcHostScope(element.is, element.extends);
var rxHostSelector = element.extends ? '\\' + hostSelector.slice(0, -1) + '\\]' : hostSelector;
var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);
return styleTransformer.elementStyles(element, function (rule) {
self.applyProperties(rule, properties);
if (rule.cssText && !nativeShadow) {
self._scopeSelector(rule, hostRx, hostSelector, element._scopeCssViaAttr, scopeSelector);
}
});
},
_scopeSelector: function (rule, hostRx, hostSelector, viaAttr, scopeId) {
rule.transformedSelector = rule.transformedSelector || rule.selector;
var selector = rule.transformedSelector;
var scope = viaAttr ? '[' + styleTransformer.SCOPE_NAME + '~=' + scopeId + ']' : '.' + scopeId;
var parts = selector.split(',');
for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {
parts[i] = p.match(hostRx) ? p.replace(hostSelector, hostSelector + scope) : scope + ' ' + p;
}
rule.selector = parts.join(',');
},
applyElementScopeSelector: function (element, selector, old, viaAttr) {
var c = viaAttr ? element.getAttribute(styleTransformer.SCOPE_NAME) : element.className;
var v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;
if (c !== v) {
if (viaAttr) {
element.setAttribute(styleTransformer.SCOPE_NAME, v);
} else {
element.className = v;
}
}
},
applyElementStyle: function (element, properties, selector, style) {
var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);
var s = element._customStyle;
if (s && !nativeShadow && s !== style) {
s._useCount--;
if (s._useCount <= 0 && s.parentNode) {
s.parentNode.removeChild(s);
}
}
if (nativeShadow || (!style || !style.parentNode)) {
if (nativeShadow && element._customStyle) {
element._customStyle.textContent = cssText;
style = element._customStyle;
} else if (cssText) {
style = styleUtil.applyCss(cssText, selector, nativeShadow ? element.root : null, element._scopeStyle);
}
}
if (style) {
style._useCount = style._useCount || 0;
if (element._customStyle != style) {
style._useCount++;
}
element._customStyle = style;
}
return style;
},
mixinCustomStyle: function (props, customStyle) {
var v;
for (var i in customStyle) {
v = customStyle[i];
if (v || v === 0) {
props[i] = v;
}
}
},
rx: {
VAR_ASSIGN: /(?:^|[;\n]\s*)(--[\w-]*?):\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\n])|$)/gi,
MIXIN_MATCH: /(?:^|\W+)@apply[\s]*\(([^)]*)\)/i,
VAR_MATCH: /(^|\W+)var\([\s]*([^,)]*)[\s]*,?[\s]*((?:[^,)]*)|(?:[^;]*\([^;)]*\)))[\s]*?\)/gi,
VAR_CAPTURE: /\([\s]*(--[^,\s)]*)(?:,[\s]*(--[^,\s)]*))?(?:\)|,)/gi,
IS_VAR: /^--/,
BRACKETED: /\{[^}]*\}/g,
HOST_PREFIX: '(?:^|[^.#[:])',
HOST_SUFFIX: '($|[.:[\\s>+~])'
},
HOST_SELECTORS: [':host'],
SCOPE_SELECTORS: [':root'],
XSCOPE_NAME: 'x-scope'
};
function addToBitMask(n, bits) {
var o = parseInt(n / 32);
var v = 1 << n % 32;
bits[o] = (bits[o] || 0) | v;
}
}();
(function () {
Polymer.StyleCache = function () {
this.cache = {};
};
Polymer.StyleCache.prototype = {
MAX: 100,
store: function (is, data, keyValues, keyStyles) {
data.keyValues = keyValues;
data.styles = keyStyles;
var s$ = this.cache[is] = this.cache[is] || [];
s$.push(data);
if (s$.length > this.MAX) {
s$.shift();
}
},
retrieve: function (is, keyValues, keyStyles) {
var cache = this.cache[is];
if (cache) {
for (var i = cache.length - 1, data; i >= 0; i--) {
data = cache[i];
if (keyStyles === data.styles && this._objectsEqual(keyValues, data.keyValues)) {
return data;
}
}
}
},
clear: function () {
this.cache = {};
},
_objectsEqual: function (target, source) {
var t, s;
for (var i in target) {
t = target[i], s = source[i];
if (!(typeof t === 'object' && t ? this._objectsStrictlyEqual(t, s) : t === s)) {
return false;
}
}
if (Array.isArray(target)) {
return target.length === source.length;
}
return true;
},
_objectsStrictlyEqual: function (target, source) {
return this._objectsEqual(target, source) && this._objectsEqual(source, target);
}
};
}());
Polymer.StyleDefaults = function () {
var styleProperties = Polymer.StyleProperties;
var styleUtil = Polymer.StyleUtil;
var StyleCache = Polymer.StyleCache;
var api = {
_styles: [],
_properties: null,
customStyle: {},
_styleCache: new StyleCache(),
addStyle: function (style) {
this._styles.push(style);
this._properties = null;
},
get _styleProperties() {
if (!this._properties) {
styleProperties.decorateStyles(this._styles);
this._styles._scopeStyleProperties = null;
this._properties = styleProperties.scopePropertiesFromStyles(this._styles);
styleProperties.mixinCustomStyle(this._properties, this.customStyle);
styleProperties.reify(this._properties);
}
return this._properties;
},
_needsStyleProperties: function () {
},
_computeStyleProperties: function () {
return this._styleProperties;
},
updateStyles: function (properties) {
this._properties = null;
if (properties) {
Polymer.Base.mixin(this.customStyle, properties);
}
this._styleCache.clear();
for (var i = 0, s; i < this._styles.length; i++) {
s = this._styles[i];
s = s.__importElement || s;
s._apply();
}
}
};
return api;
}();
(function () {
'use strict';
var serializeValueToAttribute = Polymer.Base.serializeValueToAttribute;
var propertyUtils = Polymer.StyleProperties;
var styleTransformer = Polymer.StyleTransformer;
var styleUtil = Polymer.StyleUtil;
var styleDefaults = Polymer.StyleDefaults;
var nativeShadow = Polymer.Settings.useNativeShadow;
Polymer.Base._addFeature({
_prepStyleProperties: function () {
this._ownStylePropertyNames = this._styles ? propertyUtils.decorateStyles(this._styles) : [];
},
customStyle: {},
_setupStyleProperties: function () {
this.customStyle = {};
},
_needsStyleProperties: function () {
return Boolean(this._ownStylePropertyNames && this._ownStylePropertyNames.length);
},
_beforeAttached: function () {
if (!this._scopeSelector && this._needsStyleProperties()) {
this._updateStyleProperties();
}
},
_findStyleHost: function () {
var e = this, root;
while (root = Polymer.dom(e).getOwnerRoot()) {
if (Polymer.isInstance(root.host)) {
return root.host;
}
e = root.host;
}
return styleDefaults;
},
_updateStyleProperties: function () {
var info, scope = this._findStyleHost();
if (!scope._styleCache) {
scope._styleCache = new Polymer.StyleCache();
}
var scopeData = propertyUtils.propertyDataFromStyles(scope._styles, this);
scopeData.key.customStyle = this.customStyle;
info = scope._styleCache.retrieve(this.is, scopeData.key, this._styles);
var scopeCached = Boolean(info);
if (scopeCached) {
this._styleProperties = info._styleProperties;
} else {
this._computeStyleProperties(scopeData.properties);
}
this._computeOwnStyleProperties();
if (!scopeCached) {
info = styleCache.retrieve(this.is, this._ownStyleProperties, this._styles);
}
var globalCached = Boolean(info) && !scopeCached;
var style = this._applyStyleProperties(info);
if (!scopeCached) {
style = style && nativeShadow ? style.cloneNode(true) : style;
info = {
style: style,
_scopeSelector: this._scopeSelector,
_styleProperties: this._styleProperties
};
scopeData.key.customStyle = {};
this.mixin(scopeData.key.customStyle, this.customStyle);
scope._styleCache.store(this.is, info, scopeData.key, this._styles);
if (!globalCached) {
styleCache.store(this.is, Object.create(info), this._ownStyleProperties, this._styles);
}
}
},
_computeStyleProperties: function (scopeProps) {
var scope = this._findStyleHost();
if (!scope._styleProperties) {
scope._computeStyleProperties();
}
var props = Object.create(scope._styleProperties);
this.mixin(props, propertyUtils.hostPropertiesFromStyles(this._styles));
scopeProps = scopeProps || propertyUtils.propertyDataFromStyles(scope._styles, this).properties;
this.mixin(props, scopeProps);
this.mixin(props, propertyUtils.scopePropertiesFromStyles(this._styles));
propertyUtils.mixinCustomStyle(props, this.customStyle);
propertyUtils.reify(props);
this._styleProperties = props;
},
_computeOwnStyleProperties: function () {
var props = {};
for (var i = 0, n; i < this._ownStylePropertyNames.length; i++) {
n = this._ownStylePropertyNames[i];
props[n] = this._styleProperties[n];
}
this._ownStyleProperties = props;
},
_scopeCount: 0,
_applyStyleProperties: function (info) {
var oldScopeSelector = this._scopeSelector;
this._scopeSelector = info ? info._scopeSelector : this.is + '-' + this.__proto__._scopeCount++;
var style = propertyUtils.applyElementStyle(this, this._styleProperties, this._scopeSelector, info && info.style);
if (!nativeShadow) {
propertyUtils.applyElementScopeSelector(this, this._scopeSelector, oldScopeSelector, this._scopeCssViaAttr);
}
return style;
},
serializeValueToAttribute: function (value, attribute, node) {
node = node || this;
if (attribute === 'class' && !nativeShadow) {
var host = node === this ? this.domHost || this.dataHost : this;
if (host) {
value = host._scopeElementClass(node, value);
}
}
node = Polymer.dom(node);
serializeValueToAttribute.call(this, value, attribute, node);
},
_scopeElementClass: function (element, selector) {
if (!nativeShadow && !this._scopeCssViaAttr) {
selector += (selector ? ' ' : '') + SCOPE_NAME + ' ' + this.is + (element._scopeSelector ? ' ' + XSCOPE_NAME + ' ' + element._scopeSelector : '');
}
return selector;
},
updateStyles: function (properties) {
if (this.isAttached) {
if (properties) {
this.mixin(this.customStyle, properties);
}
if (this._needsStyleProperties()) {
this._updateStyleProperties();
} else {
this._styleProperties = null;
}
if (this._styleCache) {
this._styleCache.clear();
}
this._updateRootStyles();
}
},
_updateRootStyles: function (root) {
root = root || this.root;
var c$ = Polymer.dom(root)._query(function (e) {
return e.shadyRoot || e.shadowRoot;
});
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.updateStyles) {
c.updateStyles();
}
}
}
});
Polymer.updateStyles = function (properties) {
styleDefaults.updateStyles(properties);
Polymer.Base._updateRootStyles(document);
};
var styleCache = new Polymer.StyleCache();
Polymer.customStyleCache = styleCache;
var SCOPE_NAME = styleTransformer.SCOPE_NAME;
var XSCOPE_NAME = propertyUtils.XSCOPE_NAME;
}());
Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepAttributes();
this._prepConstructor();
this._prepTemplate();
this._prepStyles();
this._prepStyleProperties();
this._prepAnnotations();
this._prepEffects();
this._prepBehaviors();
this._prepBindings();
this._prepShady();
},
_prepBehavior: function (b) {
this._addPropertyEffects(b.properties);
this._addComplexObserverEffects(b.observers);
this._addHostAttributes(b.hostAttributes);
},
_initFeatures: function () {
this._poolContent();
this._setupConfigure();
this._setupStyleProperties();
this._pushHost();
this._stampTemplate();
this._popHost();
this._marshalAnnotationReferences();
this._setupDebouncers();
this._marshalInstanceEffects();
this._marshalHostAttributes();
this._marshalBehaviors();
this._marshalAttributes();
this._tryReady();
},
_marshalBehavior: function (b) {
this._listenListeners(b.listeners);
}
});
(function () {
var nativeShadow = Polymer.Settings.useNativeShadow;
var propertyUtils = Polymer.StyleProperties;
var styleUtil = Polymer.StyleUtil;
var cssParse = Polymer.CssParse;
var styleDefaults = Polymer.StyleDefaults;
var styleTransformer = Polymer.StyleTransformer;
Polymer({
is: 'custom-style',
extends: 'style',
properties: { include: String },
ready: function () {
this._tryApply();
},
attached: function () {
this._tryApply();
},
_tryApply: function () {
if (!this._appliesToDocument) {
if (this.parentNode && this.parentNode.localName !== 'dom-module') {
this._appliesToDocument = true;
var e = this.__appliedElement || this;
styleDefaults.addStyle(e);
if (e.textContent || this.include) {
this._apply();
} else {
var observer = new MutationObserver(function () {
observer.disconnect();
this._apply();
}.bind(this));
observer.observe(e, { childList: true });
}
}
}
},
_apply: function () {
var e = this.__appliedElement || this;
if (this.include) {
e.textContent = styleUtil.cssFromModules(this.include, true) + e.textContent;
}
if (e.textContent) {
styleUtil.forEachStyleRule(styleUtil.rulesForStyle(e), function (rule) {
styleTransformer.documentRule(rule);
});
this._applyCustomProperties(e);
}
},
_applyCustomProperties: function (element) {
this._computeStyleProperties();
var props = this._styleProperties;
var rules = styleUtil.rulesForStyle(element);
element.textContent = styleUtil.toCssText(rules, function (rule) {
var css = rule.cssText = rule.parsedCssText;
if (rule.propertyInfo && rule.propertyInfo.cssText) {
css = cssParse.removeCustomPropAssignment(css);
rule.cssText = propertyUtils.valueForProperties(css, props);
}
});
}
});
}());
Polymer.Templatizer = {
properties: { __hideTemplateChildren__: { observer: '_showHideChildren' } },
_instanceProps: Polymer.nob,
_parentPropPrefix: '_parent_',
templatize: function (template) {
this._templatized = template;
if (!template._content) {
template._content = template.content;
}
if (template._content._ctor) {
this.ctor = template._content._ctor;
this._prepParentProperties(this.ctor.prototype, template);
return;
}
var archetype = Object.create(Polymer.Base);
this._customPrepAnnotations(archetype, template);
this._prepParentProperties(archetype, template);
archetype._prepEffects();
this._customPrepEffects(archetype);
archetype._prepBehaviors();
archetype._prepBindings();
archetype._notifyPath = this._notifyPathImpl;
archetype._scopeElementClass = this._scopeElementClassImpl;
archetype.listen = this._listenImpl;
archetype._showHideChildren = this._showHideChildrenImpl;
var _constructor = this._constructorImpl;
var ctor = function TemplateInstance(model, host) {
_constructor.call(this, model, host);
};
ctor.prototype = archetype;
archetype.constructor = ctor;
template._content._ctor = ctor;
this.ctor = ctor;
},
_getRootDataHost: function () {
return this.dataHost && this.dataHost._rootDataHost || this.dataHost;
},
_showHideChildrenImpl: function (hide) {
var c = this._children;
for (var i = 0; i < c.length; i++) {
var n = c[i];
if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
if (n.nodeType === Node.TEXT_NODE) {
if (hide) {
n.__polymerTextContent__ = n.textContent;
n.textContent = '';
} else {
n.textContent = n.__polymerTextContent__;
}
} else if (n.style) {
if (hide) {
n.__polymerDisplay__ = n.style.display;
n.style.display = 'none';
} else {
n.style.display = n.__polymerDisplay__;
}
}
}
n.__hideTemplateChildren__ = hide;
}
},
_debounceTemplate: function (fn) {
Polymer.dom.addDebouncer(this.debounce('_debounceTemplate', fn));
},
_flushTemplates: function (debouncerExpired) {
Polymer.dom.flush();
},
_customPrepEffects: function (archetype) {
var parentProps = archetype._parentProps;
for (var prop in parentProps) {
archetype._addPropertyEffect(prop, 'function', this._createHostPropEffector(prop));
}
for (var prop in this._instanceProps) {
archetype._addPropertyEffect(prop, 'function', this._createInstancePropEffector(prop));
}
},
_customPrepAnnotations: function (archetype, template) {
archetype._template = template;
var c = template._content;
if (!c._notes) {
var rootDataHost = archetype._rootDataHost;
if (rootDataHost) {
Polymer.Annotations.prepElement = rootDataHost._prepElement.bind(rootDataHost);
}
c._notes = Polymer.Annotations.parseAnnotations(template);
Polymer.Annotations.prepElement = null;
this._processAnnotations(c._notes);
}
archetype._notes = c._notes;
archetype._parentProps = c._parentProps;
},
_prepParentProperties: function (archetype, template) {
var parentProps = this._parentProps = archetype._parentProps;
if (this._forwardParentProp && parentProps) {
var proto = archetype._parentPropProto;
var prop;
if (!proto) {
for (prop in this._instanceProps) {
delete parentProps[prop];
}
proto = archetype._parentPropProto = Object.create(null);
if (template != this) {
Polymer.Bind.prepareModel(proto);
Polymer.Base.prepareModelNotifyPath(proto);
}
for (prop in parentProps) {
var parentProp = this._parentPropPrefix + prop;
var effects = [
{
kind: 'function',
effect: this._createForwardPropEffector(prop)
},
{ kind: 'notify' }
];
Polymer.Bind._createAccessors(proto, parentProp, effects);
}
}
if (template != this) {
Polymer.Bind.prepareInstance(template);
template._forwardParentProp = this._forwardParentProp.bind(this);
}
this._extendTemplate(template, proto);
template._pathEffector = this._pathEffectorImpl.bind(this);
}
},
_createForwardPropEffector: function (prop) {
return function (source, value) {
this._forwardParentProp(prop, value);
};
},
_createHostPropEffector: function (prop) {
var prefix = this._parentPropPrefix;
return function (source, value) {
this.dataHost._templatized[prefix + prop] = value;
};
},
_createInstancePropEffector: function (prop) {
return function (source, value, old, fromAbove) {
if (!fromAbove) {
this.dataHost._forwardInstanceProp(this, prop, value);
}
};
},
_extendTemplate: function (template, proto) {
Object.getOwnPropertyNames(proto).forEach(function (n) {
var val = template[n];
var pd = Object.getOwnPropertyDescriptor(proto, n);
Object.defineProperty(template, n, pd);
if (val !== undefined) {
template._propertySetter(n, val);
}
});
},
_showHideChildren: function (hidden) {
},
_forwardInstancePath: function (inst, path, value) {
},
_forwardInstanceProp: function (inst, prop, value) {
},
_notifyPathImpl: function (path, value) {
var dataHost = this.dataHost;
var dot = path.indexOf('.');
var root = dot < 0 ? path : path.slice(0, dot);
dataHost._forwardInstancePath.call(dataHost, this, path, value);
if (root in dataHost._parentProps) {
dataHost._templatized.notifyPath(dataHost._parentPropPrefix + path, value);
}
},
_pathEffectorImpl: function (path, value, fromAbove) {
if (this._forwardParentPath) {
if (path.indexOf(this._parentPropPrefix) === 0) {
var subPath = path.substring(this._parentPropPrefix.length);
this._forwardParentPath(subPath, value);
}
}
Polymer.Base._pathEffector.call(this._templatized, path, value, fromAbove);
},
_constructorImpl: function (model, host) {
this._rootDataHost = host._getRootDataHost();
this._setupConfigure(model);
this._pushHost(host);
this.root = this.instanceTemplate(this._template);
this.root.__noContent = !this._notes._hasContent;
this.root.__styleScoped = true;
this._popHost();
this._marshalAnnotatedNodes();
this._marshalInstanceEffects();
this._marshalAnnotatedListeners();
var children = [];
for (var n = this.root.firstChild; n; n = n.nextSibling) {
children.push(n);
n._templateInstance = this;
}
this._children = children;
if (host.__hideTemplateChildren__) {
this._showHideChildren(true);
}
this._tryReady();
},
_listenImpl: function (node, eventName, methodName) {
var model = this;
var host = this._rootDataHost;
var handler = host._createEventHandler(node, eventName, methodName);
var decorated = function (e) {
e.model = model;
handler(e);
};
host._listen(node, eventName, decorated);
},
_scopeElementClassImpl: function (node, value) {
var host = this._rootDataHost;
if (host) {
return host._scopeElementClass(node, value);
}
},
stamp: function (model) {
model = model || {};
if (this._parentProps) {
var templatized = this._templatized;
for (var prop in this._parentProps) {
model[prop] = templatized[this._parentPropPrefix + prop];
}
}
return new this.ctor(model, this);
},
modelForElement: function (el) {
var model;
while (el) {
if (model = el._templateInstance) {
if (model.dataHost != this) {
el = model.dataHost;
} else {
return model;
}
} else {
el = el.parentNode;
}
}
}
};
Polymer({
is: 'dom-template',
extends: 'template',
behaviors: [Polymer.Templatizer],
ready: function () {
this.templatize(this);
}
});
Polymer._collections = new WeakMap();
Polymer.Collection = function (userArray) {
Polymer._collections.set(userArray, this);
this.userArray = userArray;
this.store = userArray.slice();
this.initMap();
};
Polymer.Collection.prototype = {
constructor: Polymer.Collection,
initMap: function () {
var omap = this.omap = new WeakMap();
var pmap = this.pmap = {};
var s = this.store;
for (var i = 0; i < s.length; i++) {
var item = s[i];
if (item && typeof item == 'object') {
omap.set(item, i);
} else {
pmap[item] = i;
}
}
},
add: function (item) {
var key = this.store.push(item) - 1;
if (item && typeof item == 'object') {
this.omap.set(item, key);
} else {
this.pmap[item] = key;
}
return key;
},
removeKey: function (key) {
this._removeFromMap(this.store[key]);
delete this.store[key];
},
_removeFromMap: function (item) {
if (item && typeof item == 'object') {
this.omap.delete(item);
} else {
delete this.pmap[item];
}
},
remove: function (item) {
var key = this.getKey(item);
this.removeKey(key);
return key;
},
getKey: function (item) {
if (item && typeof item == 'object') {
return this.omap.get(item);
} else {
return this.pmap[item];
}
},
getKeys: function () {
return Object.keys(this.store);
},
setItem: function (key, item) {
var old = this.store[key];
if (old) {
this._removeFromMap(old);
}
if (item && typeof item == 'object') {
this.omap.set(item, key);
} else {
this.pmap[item] = key;
}
this.store[key] = item;
},
getItem: function (key) {
return this.store[key];
},
getItems: function () {
var items = [], store = this.store;
for (var key in store) {
items.push(store[key]);
}
return items;
},
_applySplices: function (splices) {
var keyMap = {}, key, i;
splices.forEach(function (s) {
s.addedKeys = [];
for (i = 0; i < s.removed.length; i++) {
key = this.getKey(s.removed[i]);
keyMap[key] = keyMap[key] ? null : -1;
}
for (i = 0; i < s.addedCount; i++) {
var item = this.userArray[s.index + i];
key = this.getKey(item);
key = key === undefined ? this.add(item) : key;
keyMap[key] = keyMap[key] ? null : 1;
s.addedKeys.push(key);
}
}, this);
var removed = [];
var added = [];
for (var key in keyMap) {
if (keyMap[key] < 0) {
this.removeKey(key);
removed.push(key);
}
if (keyMap[key] > 0) {
added.push(key);
}
}
return [{
removed: removed,
added: added
}];
}
};
Polymer.Collection.get = function (userArray) {
return Polymer._collections.get(userArray) || new Polymer.Collection(userArray);
};
Polymer.Collection.applySplices = function (userArray, splices) {
var coll = Polymer._collections.get(userArray);
return coll ? coll._applySplices(splices) : null;
};
Polymer({
is: 'dom-repeat',
extends: 'template',
properties: {
items: { type: Array },
as: {
type: String,
value: 'item'
},
indexAs: {
type: String,
value: 'index'
},
sort: {
type: Function,
observer: '_sortChanged'
},
filter: {
type: Function,
observer: '_filterChanged'
},
observe: {
type: String,
observer: '_observeChanged'
},
delay: Number
},
behaviors: [Polymer.Templatizer],
observers: ['_itemsChanged(items.*)'],
created: function () {
this._instances = [];
},
detached: function () {
for (var i = 0; i < this._instances.length; i++) {
this._detachRow(i);
}
},
attached: function () {
var parentNode = Polymer.dom(this).parentNode;
for (var i = 0; i < this._instances.length; i++) {
Polymer.dom(parentNode).insertBefore(this._instances[i].root, this);
}
},
ready: function () {
this._instanceProps = { __key__: true };
this._instanceProps[this.as] = true;
this._instanceProps[this.indexAs] = true;
if (!this.ctor) {
this.templatize(this);
}
},
_sortChanged: function () {
var dataHost = this._getRootDataHost();
var sort = this.sort;
this._sortFn = sort && (typeof sort == 'function' ? sort : function () {
return dataHost[sort].apply(dataHost, arguments);
});
this._needFullRefresh = true;
if (this.items) {
this._debounceTemplate(this._render);
}
},
_filterChanged: function () {
var dataHost = this._getRootDataHost();
var filter = this.filter;
this._filterFn = filter && (typeof filter == 'function' ? filter : function () {
return dataHost[filter].apply(dataHost, arguments);
});
this._needFullRefresh = true;
if (this.items) {
this._debounceTemplate(this._render);
}
},
_observeChanged: function () {
this._observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
},
_itemsChanged: function (change) {
if (change.path == 'items') {
if (Array.isArray(this.items)) {
this.collection = Polymer.Collection.get(this.items);
} else if (!this.items) {
this.collection = null;
} else {
this._error(this._logf('dom-repeat', 'expected array for `items`,' + ' found', this.items));
}
this._keySplices = [];
this._indexSplices = [];
this._needFullRefresh = true;
this._debounceTemplate(this._render);
} else if (change.path == 'items.splices') {
this._keySplices = this._keySplices.concat(change.value.keySplices);
this._indexSplices = this._indexSplices.concat(change.value.indexSplices);
this._debounceTemplate(this._render);
} else {
var subpath = change.path.slice(6);
this._forwardItemPath(subpath, change.value);
this._checkObservedPaths(subpath);
}
},
_checkObservedPaths: function (path) {
if (this._observePaths) {
path = path.substring(path.indexOf('.') + 1);
var paths = this._observePaths;
for (var i = 0; i < paths.length; i++) {
if (path.indexOf(paths[i]) === 0) {
this._needFullRefresh = true;
if (this.delay) {
this.debounce('render', this._render, this.delay);
} else {
this._debounceTemplate(this._render);
}
return;
}
}
}
},
render: function () {
this._needFullRefresh = true;
this._debounceTemplate(this._render);
this._flushTemplates();
},
_render: function () {
var c = this.collection;
if (this._needFullRefresh) {
this._applyFullRefresh();
this._needFullRefresh = false;
} else {
if (this._sortFn) {
this._applySplicesUserSort(this._keySplices);
} else {
if (this._filterFn) {
this._applyFullRefresh();
} else {
this._applySplicesArrayOrder(this._indexSplices);
}
}
}
this._keySplices = [];
this._indexSplices = [];
var keyToIdx = this._keyToInstIdx = {};
for (var i = 0; i < this._instances.length; i++) {
var inst = this._instances[i];
keyToIdx[inst.__key__] = i;
inst.__setProperty(this.indexAs, i, true);
}
this.fire('dom-change');
},
_applyFullRefresh: function () {
var c = this.collection;
var keys;
if (this._sortFn) {
keys = c ? c.getKeys() : [];
} else {
keys = [];
var items = this.items;
if (items) {
for (var i = 0; i < items.length; i++) {
keys.push(c.getKey(items[i]));
}
}
}
if (this._filterFn) {
keys = keys.filter(function (a) {
return this._filterFn(c.getItem(a));
}, this);
}
if (this._sortFn) {
keys.sort(function (a, b) {
return this._sortFn(c.getItem(a), c.getItem(b));
}.bind(this));
}
for (var i = 0; i < keys.length; i++) {
var key = keys[i];
var inst = this._instances[i];
if (inst) {
inst.__setProperty('__key__', key, true);
inst.__setProperty(this.as, c.getItem(key), true);
} else {
this._instances.push(this._insertRow(i, key));
}
}
for (; i < this._instances.length; i++) {
this._detachRow(i);
}
this._instances.splice(keys.length, this._instances.length - keys.length);
},
_keySort: function (a, b) {
return this.collection.getKey(a) - this.collection.getKey(b);
},
_numericSort: function (a, b) {
return a - b;
},
_applySplicesUserSort: function (splices) {
var c = this.collection;
var instances = this._instances;
var keyMap = {};
var pool = [];
var sortFn = this._sortFn || this._keySort.bind(this);
splices.forEach(function (s) {
for (var i = 0; i < s.removed.length; i++) {
var key = s.removed[i];
keyMap[key] = keyMap[key] ? null : -1;
}
for (var i = 0; i < s.added.length; i++) {
var key = s.added[i];
keyMap[key] = keyMap[key] ? null : 1;
}
}, this);
var removedIdxs = [];
var addedKeys = [];
for (var key in keyMap) {
if (keyMap[key] === -1) {
removedIdxs.push(this._keyToInstIdx[key]);
}
if (keyMap[key] === 1) {
addedKeys.push(key);
}
}
if (removedIdxs.length) {
removedIdxs.sort(this._numericSort);
for (var i = removedIdxs.length - 1; i >= 0; i--) {
var idx = removedIdxs[i];
if (idx !== undefined) {
pool.push(this._detachRow(idx));
instances.splice(idx, 1);
}
}
}
if (addedKeys.length) {
if (this._filterFn) {
addedKeys = addedKeys.filter(function (a) {
return this._filterFn(c.getItem(a));
}, this);
}
addedKeys.sort(function (a, b) {
return this._sortFn(c.getItem(a), c.getItem(b));
}.bind(this));
var start = 0;
for (var i = 0; i < addedKeys.length; i++) {
start = this._insertRowUserSort(start, addedKeys[i], pool);
}
}
},
_insertRowUserSort: function (start, key, pool) {
var c = this.collection;
var item = c.getItem(key);
var end = this._instances.length - 1;
var idx = -1;
var sortFn = this._sortFn || this._keySort.bind(this);
while (start <= end) {
var mid = start + end >> 1;
var midKey = this._instances[mid].__key__;
var cmp = sortFn(c.getItem(midKey), item);
if (cmp < 0) {
start = mid + 1;
} else if (cmp > 0) {
end = mid - 1;
} else {
idx = mid;
break;
}
}
if (idx < 0) {
idx = end + 1;
}
this._instances.splice(idx, 0, this._insertRow(idx, key, pool));
return idx;
},
_applySplicesArrayOrder: function (splices) {
var pool = [];
var c = this.collection;
splices.forEach(function (s) {
for (var i = 0; i < s.removed.length; i++) {
var inst = this._detachRow(s.index + i);
if (!inst.isPlaceholder) {
pool.push(inst);
}
}
this._instances.splice(s.index, s.removed.length);
for (var i = 0; i < s.addedKeys.length; i++) {
var inst = {
isPlaceholder: true,
key: s.addedKeys[i]
};
this._instances.splice(s.index + i, 0, inst);
}
}, this);
for (var i = this._instances.length - 1; i >= 0; i--) {
var inst = this._instances[i];
if (inst.isPlaceholder) {
this._instances[i] = this._insertRow(i, inst.key, pool, true);
}
}
},
_detachRow: function (idx) {
var inst = this._instances[idx];
if (!inst.isPlaceholder) {
var parentNode = Polymer.dom(this).parentNode;
for (var i = 0; i < inst._children.length; i++) {
var el = inst._children[i];
Polymer.dom(inst.root).appendChild(el);
}
}
return inst;
},
_insertRow: function (idx, key, pool, replace) {
var inst;
if (inst = pool && pool.pop()) {
inst.__setProperty(this.as, this.collection.getItem(key), true);
inst.__setProperty('__key__', key, true);
} else {
inst = this._generateRow(idx, key);
}
var beforeRow = this._instances[replace ? idx + 1 : idx];
var beforeNode = beforeRow ? beforeRow._children[0] : this;
var parentNode = Polymer.dom(this).parentNode;
Polymer.dom(parentNode).insertBefore(inst.root, beforeNode);
return inst;
},
_generateRow: function (idx, key) {
var model = { __key__: key };
model[this.as] = this.collection.getItem(key);
model[this.indexAs] = idx;
var inst = this.stamp(model);
return inst;
},
_showHideChildren: function (hidden) {
for (var i = 0; i < this._instances.length; i++) {
this._instances[i]._showHideChildren(hidden);
}
},
_forwardInstanceProp: function (inst, prop, value) {
if (prop == this.as) {
var idx;
if (this._sortFn || this._filterFn) {
idx = this.items.indexOf(this.collection.getItem(inst.__key__));
} else {
idx = inst[this.indexAs];
}
this.set('items.' + idx, value);
}
},
_forwardInstancePath: function (inst, path, value) {
if (path.indexOf(this.as + '.') === 0) {
this.notifyPath('items.' + inst.__key__ + '.' + path.slice(this.as.length + 1), value);
}
},
_forwardParentProp: function (prop, value) {
this._instances.forEach(function (inst) {
inst.__setProperty(prop, value, true);
}, this);
},
_forwardParentPath: function (path, value) {
this._instances.forEach(function (inst) {
inst.notifyPath(path, value, true);
}, this);
},
_forwardItemPath: function (path, value) {
if (this._keyToInstIdx) {
var dot = path.indexOf('.');
var key = path.substring(0, dot < 0 ? path.length : dot);
var idx = this._keyToInstIdx[key];
var inst = this._instances[idx];
if (inst) {
if (dot >= 0) {
path = this.as + '.' + path.substring(dot + 1);
inst.notifyPath(path, value, true);
} else {
inst.__setProperty(this.as, value, true);
}
}
}
},
itemForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance[this.as];
},
keyForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance.__key__;
},
indexForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance[this.indexAs];
}
});
Polymer({
is: 'array-selector',
properties: {
items: {
type: Array,
observer: 'clearSelection'
},
multi: {
type: Boolean,
value: false,
observer: 'clearSelection'
},
selected: {
type: Object,
notify: true
},
selectedItem: {
type: Object,
notify: true
},
toggle: {
type: Boolean,
value: false
}
},
clearSelection: function () {
if (Array.isArray(this.selected)) {
for (var i = 0; i < this.selected.length; i++) {
this.unlinkPaths('selected.' + i);
}
} else {
this.unlinkPaths('selected');
}
if (this.multi) {
if (!this.selected || this.selected.length) {
this.selected = [];
this._selectedColl = Polymer.Collection.get(this.selected);
}
} else {
this.selected = null;
this._selectedColl = null;
}
this.selectedItem = null;
},
isSelected: function (item) {
if (this.multi) {
return this._selectedColl.getKey(item) !== undefined;
} else {
return this.selected == item;
}
},
deselect: function (item) {
if (this.multi) {
if (this.isSelected(item)) {
var skey = this._selectedColl.getKey(item);
this.arrayDelete('selected', item);
this.unlinkPaths('selected.' + skey);
}
} else {
this.selected = null;
this.selectedItem = null;
this.unlinkPaths('selected');
this.unlinkPaths('selectedItem');
}
},
select: function (item) {
var icol = Polymer.Collection.get(this.items);
var key = icol.getKey(item);
if (this.multi) {
if (this.isSelected(item)) {
if (this.toggle) {
this.deselect(item);
}
} else {
this.push('selected', item);
var skey = this._selectedColl.getKey(item);
this.linkPaths('selected.' + skey, 'items.' + key);
}
} else {
if (this.toggle && item == this.selected) {
this.deselect();
} else {
this.selected = item;
this.selectedItem = item;
this.linkPaths('selected', 'items.' + key);
this.linkPaths('selectedItem', 'items.' + key);
}
}
}
});
Polymer({
is: 'dom-if',
extends: 'template',
properties: {
'if': {
type: Boolean,
value: false,
observer: '_queueRender'
},
restamp: {
type: Boolean,
value: false,
observer: '_queueRender'
}
},
behaviors: [Polymer.Templatizer],
_queueRender: function () {
this._debounceTemplate(this._render);
},
detached: function () {
this._teardownInstance();
},
attached: function () {
if (this.if && this.ctor) {
this.async(this._ensureInstance);
}
},
render: function () {
this._flushTemplates();
},
_render: function () {
if (this.if) {
if (!this.ctor) {
this.templatize(this);
}
this._ensureInstance();
this._showHideChildren();
} else if (this.restamp) {
this._teardownInstance();
}
if (!this.restamp && this._instance) {
this._showHideChildren();
}
if (this.if != this._lastIf) {
this.fire('dom-change');
this._lastIf = this.if;
}
},
_ensureInstance: function () {
if (!this._instance) {
this._instance = this.stamp();
var root = this._instance.root;
var parent = Polymer.dom(Polymer.dom(this).parentNode);
parent.insertBefore(root, this);
}
},
_teardownInstance: function () {
if (this._instance) {
var c = this._instance._children;
if (c) {
var parent = Polymer.dom(Polymer.dom(c[0]).parentNode);
c.forEach(function (n) {
parent.removeChild(n);
});
}
this._instance = null;
}
},
_showHideChildren: function () {
var hidden = this.__hideTemplateChildren__ || !this.if;
if (this._instance) {
this._instance._showHideChildren(hidden);
}
},
_forwardParentProp: function (prop, value) {
if (this._instance) {
this._instance[prop] = value;
}
},
_forwardParentPath: function (path, value) {
if (this._instance) {
this._instance.notifyPath(path, value, true);
}
}
});
Polymer({
is: 'dom-bind',
extends: 'template',
created: function () {
Polymer.RenderStatus.whenReady(this._markImportsReady.bind(this));
},
_ensureReady: function () {
if (!this._readied) {
this._readySelf();
}
},
_markImportsReady: function () {
this._importsReady = true;
this._ensureReady();
},
_registerFeatures: function () {
this._prepConstructor();
},
_insertChildren: function () {
var parentDom = Polymer.dom(Polymer.dom(this).parentNode);
parentDom.insertBefore(this.root, this);
},
_removeChildren: function () {
if (this._children) {
for (var i = 0; i < this._children.length; i++) {
this.root.appendChild(this._children[i]);
}
}
},
_initFeatures: function () {
},
_scopeElementClass: function (element, selector) {
if (this.dataHost) {
return this.dataHost._scopeElementClass(element, selector);
} else {
return selector;
}
},
_prepConfigure: function () {
var config = {};
for (var prop in this._propertyEffects) {
config[prop] = this[prop];
}
this._setupConfigure = this._setupConfigure.bind(this, config);
},
attached: function () {
if (this._importsReady) {
this.render();
}
},
detached: function () {
this._removeChildren();
},
render: function () {
this._ensureReady();
if (!this._children) {
this._template = this;
this._prepAnnotations();
this._prepEffects();
this._prepBehaviors();
this._prepConfigure();
this._prepBindings();
Polymer.Base._initFeatures.call(this);
this._children = Array.prototype.slice.call(this.root.childNodes);
}
this._insertChildren();
this.fire('dom-change');
}
});</script>
<style>

  /*******************************
            Flex Layout
  *******************************/

  .layout.horizontal,
  .layout.horizontal-reverse,
  .layout.vertical,
  .layout.vertical-reverse {
    display: -ms-flexbox;
    display: -webkit-flex;
    display: flex;
  }

  .layout.inline {
    display: -ms-inline-flexbox;
    display: -webkit-inline-flex;
    display: inline-flex;
  }

  .layout.horizontal {
    -ms-flex-direction: row;
    -webkit-flex-direction: row;
    flex-direction: row;
  }

  .layout.horizontal-reverse {
    -ms-flex-direction: row-reverse;
    -webkit-flex-direction: row-reverse;
    flex-direction: row-reverse;
  }

  .layout.vertical {
    -ms-flex-direction: column;
    -webkit-flex-direction: column;
    flex-direction: column;
  }

  .layout.vertical-reverse {
    -ms-flex-direction: column-reverse;
    -webkit-flex-direction: column-reverse;
    flex-direction: column-reverse;
  }

  .layout.wrap {
    -ms-flex-wrap: wrap;
    -webkit-flex-wrap: wrap;
    flex-wrap: wrap;
  }

  .layout.wrap-reverse {
    -ms-flex-wrap: wrap-reverse;
    -webkit-flex-wrap: wrap-reverse;
    flex-wrap: wrap-reverse;
  }

  .flex-auto {
    -ms-flex: 1 1 auto;
    -webkit-flex: 1 1 auto;
    flex: 1 1 auto;
  }

  .flex-none {
    -ms-flex: none;
    -webkit-flex: none;
    flex: none;
  }

  .flex,
  .flex-1 {
    -ms-flex: 1;
    -webkit-flex: 1;
    flex: 1;
  }

  .flex-2 {
    -ms-flex: 2;
    -webkit-flex: 2;
    flex: 2;
  }

  .flex-3 {
    -ms-flex: 3;
    -webkit-flex: 3;
    flex: 3;
  }

  .flex-4 {
    -ms-flex: 4;
    -webkit-flex: 4;
    flex: 4;
  }

  .flex-5 {
    -ms-flex: 5;
    -webkit-flex: 5;
    flex: 5;
  }

  .flex-6 {
    -ms-flex: 6;
    -webkit-flex: 6;
    flex: 6;
  }

  .flex-7 {
    -ms-flex: 7;
    -webkit-flex: 7;
    flex: 7;
  }

  .flex-8 {
    -ms-flex: 8;
    -webkit-flex: 8;
    flex: 8;
  }

  .flex-9 {
    -ms-flex: 9;
    -webkit-flex: 9;
    flex: 9;
  }

  .flex-10 {
    -ms-flex: 10;
    -webkit-flex: 10;
    flex: 10;
  }

  .flex-11 {
    -ms-flex: 11;
    -webkit-flex: 11;
    flex: 11;
  }

  .flex-12 {
    -ms-flex: 12;
    -webkit-flex: 12;
    flex: 12;
  }

  /* alignment in cross axis */

  .layout.start {
    -ms-flex-align: start;
    -webkit-align-items: flex-start;
    align-items: flex-start;
  }

  .layout.center,
  .layout.center-center {
    -ms-flex-align: center;
    -webkit-align-items: center;
    align-items: center;
  }

  .layout.end {
    -ms-flex-align: end;
    -webkit-align-items: flex-end;
    align-items: flex-end;
  }

  /* alignment in main axis */

  .layout.start-justified {
    -ms-flex-pack: start;
    -webkit-justify-content: flex-start;
    justify-content: flex-start;
  }

  .layout.center-justified,
  .layout.center-center {
    -ms-flex-pack: center;
    -webkit-justify-content: center;
    justify-content: center;
  }

  .layout.end-justified {
    -ms-flex-pack: end;
    -webkit-justify-content: flex-end;
    justify-content: flex-end;
  }

  .layout.around-justified {
    -ms-flex-pack: around;
    -webkit-justify-content: space-around;
    justify-content: space-around;
  }

  .layout.justified {
    -ms-flex-pack: justify;
    -webkit-justify-content: space-between;
    justify-content: space-between;
  }

  /* self alignment */

  .self-start {
    -ms-align-self: flex-start;
    -webkit-align-self: flex-start;
    align-self: flex-start;
  }

  .self-center {
    -ms-align-self: center;
    -webkit-align-self: center;
    align-self: center;
  }

  .self-end {
    -ms-align-self: flex-end;
    -webkit-align-self: flex-end;
    align-self: flex-end;
  }

  .self-stretch {
    -ms-align-self: stretch;
    -webkit-align-self: stretch;
    align-self: stretch;
  }

  /*******************************
            Other Layout
  *******************************/

  .block {
    display: block;
  }

  /* IE 10 support for HTML5 hidden attr */
  [hidden] {
    display: none !important;
  }

  .invisible {
    visibility: hidden !important;
  }

  .relative {
    position: relative;
  }

  .fit {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }

  body.fullbleed {
    margin: 0;
    height: 100vh;
  }

  .scroll {
    -webkit-overflow-scrolling: touch;
    overflow: auto;
  }

  /* fixed position */

  .fixed-bottom,
  .fixed-left,
  .fixed-right,
  .fixed-top {
    position: fixed;
  }

  .fixed-top {
    top: 0;
    left: 0;
    right: 0;
  }

  .fixed-right {
    top: 0;
    right: 0;
    bottom: 0;
  }

  .fixed-bottom {
    right: 0;
    bottom: 0;
    left: 0;
  }

  .fixed-left {
    top: 0;
    bottom: 0;
    left: 0;
  }

</style><!--
`iron-media-query` can be used to data bind to a CSS media query.
The `query` property is a bare CSS media query.
The `query-matches` property is a boolean representing whether the page matches that media query.

Example:

    <iron-media-query query="(min-width: 600px)" query-matches="{{queryMatches}}"></iron-media-query>

@group Iron Elements
@demo demo/index.html
@hero hero.svg
@element iron-media-query
-->

<script>

  Polymer({

    is: 'iron-media-query',

    properties: {

      /**
       * The Boolean return value of the media query.
       */
      queryMatches: {
        type: Boolean,
        value: false,
        readOnly: true,
        notify: true
      },

      /**
       * The CSS media query to evaluate.
       */
      query: {
        type: String,
        observer: 'queryChanged'
      },

      _boundMQHandler: {
        value: function() {
          return this.queryHandler.bind(this);
        }
      }
    },

    attached: function() {
      this.queryChanged();
    },

    detached: function() {
      this._remove();
    },

    _add: function() {
      if (this._mq) {
        this._mq.addListener(this._boundMQHandler);
      }
    },

    _remove: function() {
      if (this._mq) {
        this._mq.removeListener(this._boundMQHandler);
      }
      this._mq = null;
    },

    queryChanged: function() {
      this._remove();
      var query = this.query;
      if (!query) {
        return;
      }
      if (query[0] !== '(') {
        query = '(' + query + ')';
      }
      this._mq = window.matchMedia(query);
      this._add();
      this.queryHandler(this._mq);
    },

    queryHandler: function(mq) {
      this._setQueryMatches(mq.matches);
    }

  });

</script>
<script>

  /**
   * @param {!Function} selectCallback
   * @constructor
   */
  Polymer.IronSelection = function(selectCallback) {
    this.selection = [];
    this.selectCallback = selectCallback;
  };

  Polymer.IronSelection.prototype = {

    /**
     * Retrieves the selected item(s).
     *
     * @method get
     * @returns Returns the selected item(s). If the multi property is true,
     * `get` will return an array, otherwise it will return
     * the selected item or undefined if there is no selection.
     */
    get: function() {
      return this.multi ? this.selection.slice() : this.selection[0];
    },

    /**
     * Clears all the selection except the ones indicated.
     *
     * @method clear
     * @param {Array} excludes items to be excluded.
     */
    clear: function(excludes) {
      this.selection.slice().forEach(function(item) {
        if (!excludes || excludes.indexOf(item) < 0) {
          this.setItemSelected(item, false);
        }
      }, this);
    },

    /**
     * Indicates if a given item is selected.
     *
     * @method isSelected
     * @param {*} item The item whose selection state should be checked.
     * @returns Returns true if `item` is selected.
     */
    isSelected: function(item) {
      return this.selection.indexOf(item) >= 0;
    },

    /**
     * Sets the selection state for a given item to either selected or deselected.
     *
     * @method setItemSelected
     * @param {*} item The item to select.
     * @param {boolean} isSelected True for selected, false for deselected.
     */
    setItemSelected: function(item, isSelected) {
      if (item != null) {
        if (isSelected) {
          this.selection.push(item);
        } else {
          var i = this.selection.indexOf(item);
          if (i >= 0) {
            this.selection.splice(i, 1);
          }
        }
        if (this.selectCallback) {
          this.selectCallback(item, isSelected);
        }
      }
    },

    /**
     * Sets the selection state for a given item. If the `multi` property
     * is true, then the selected state of `item` will be toggled; otherwise
     * the `item` will be selected.
     *
     * @method select
     * @param {*} item The item to select.
     */
    select: function(item) {
      if (this.multi) {
        this.toggle(item);
      } else if (this.get() !== item) {
        this.setItemSelected(this.get(), false);
        this.setItemSelected(item, true);
      }
    },

    /**
     * Toggles the selection state for `item`.
     *
     * @method toggle
     * @param {*} item The item to toggle.
     */
    toggle: function(item) {
      this.setItemSelected(item, !this.isSelected(item));
    }

  };

</script>
<script>

  /** @polymerBehavior */
  Polymer.IronSelectableBehavior = {

      /**
       * Fired when iron-selector is activated (selected or deselected).
       * It is fired before the selected items are changed.
       * Cancel the event to abort selection.
       *
       * @event iron-activate
       */

      /**
       * Fired when an item is selected
       *
       * @event iron-select
       */

      /**
       * Fired when an item is deselected
       *
       * @event iron-deselect
       */

      /**
       * Fired when the list of selectable items changes (e.g., items are
       * added or removed). The detail of the event is a list of mutation
       * records that describe what changed.
       *
       * @event iron-items-changed
       */

    properties: {

      /**
       * If you want to use the attribute value of an element for `selected` instead of the index,
       * set this to the name of the attribute.
       */
      attrForSelected: {
        type: String,
        value: null
      },

      /**
       * Gets or sets the selected element. The default is to use the index of the item.
       */
      selected: {
        type: String,
        notify: true
      },

      /**
       * Returns the currently selected item.
       */
      selectedItem: {
        type: Object,
        readOnly: true,
        notify: true
      },

      /**
       * The event that fires from items when they are selected. Selectable
       * will listen for this event from items and update the selection state.
       * Set to empty string to listen to no events.
       */
      activateEvent: {
        type: String,
        value: 'tap',
        observer: '_activateEventChanged'
      },

      /**
       * This is a CSS selector string.  If this is set, only items that match the CSS selector
       * are selectable.
       */
      selectable: String,

      /**
       * The class to set on elements when selected.
       */
      selectedClass: {
        type: String,
        value: 'iron-selected'
      },

      /**
       * The attribute to set on elements when selected.
       */
      selectedAttribute: {
        type: String,
        value: null
      },

      /**
       * The set of excluded elements where the key is the `localName`
       * of the element that will be ignored from the item list.
       *
       * @type {object}
       * @default {template: 1}
       */
      _excludedLocalNames: {
        type: Object,
        value: function() {
          return {
            'template': 1
          };
        }
      }
    },

    observers: [
      '_updateSelected(attrForSelected, selected)'
    ],

    created: function() {
      this._bindFilterItem = this._filterItem.bind(this);
      this._selection = new Polymer.IronSelection(this._applySelection.bind(this));
      // TODO(cdata): When polymer/polymer#2535 lands, we do not need to do this
      // book keeping anymore:
      this.__listeningForActivate = false;
    },

    attached: function() {
      this._observer = this._observeItems(this);
      this._contentObserver = this._observeContent(this);
      if (!this.selectedItem && this.selected) {
        this._updateSelected(this.attrForSelected,this.selected)
      }
      this._addListener(this.activateEvent);
    },

    detached: function() {
      if (this._observer) {
        this._observer.disconnect();
      }
      if (this._contentObserver) {
        this._contentObserver.disconnect();
      }
      this._removeListener(this.activateEvent);
    },

    /**
     * Returns an array of selectable items.
     *
     * @property items
     * @type Array
     */
    get items() {
      var nodes = Polymer.dom(this).queryDistributedElements(this.selectable || '*');
      return Array.prototype.filter.call(nodes, this._bindFilterItem);
    },

    /**
     * Returns the index of the given item.
     *
     * @method indexOf
     * @param {Object} item
     * @returns Returns the index of the item
     */
    indexOf: function(item) {
      return this.items.indexOf(item);
    },

    /**
     * Selects the given value.
     *
     * @method select
     * @param {string} value the value to select.
     */
    select: function(value) {
      this.selected = value;
    },

    /**
     * Selects the previous item.
     *
     * @method selectPrevious
     */
    selectPrevious: function() {
      var length = this.items.length;
      var index = (Number(this._valueToIndex(this.selected)) - 1 + length) % length;
      this.selected = this._indexToValue(index);
    },

    /**
     * Selects the next item.
     *
     * @method selectNext
     */
    selectNext: function() {
      var index = (Number(this._valueToIndex(this.selected)) + 1) % this.items.length;
      this.selected = this._indexToValue(index);
    },

    _addListener: function(eventName) {
      if (!this.isAttached || this.__listeningForActivate) {
        return;
      }

      this.__listeningForActivate = true;
      this.listen(this, eventName, '_activateHandler');
    },

    _removeListener: function(eventName) {
      this.unlisten(this, eventName, '_activateHandler');
      this.__listeningForActivate = false;
    },

    _activateEventChanged: function(eventName, old) {
      this._removeListener(old);
      this._addListener(eventName);
    },

    _updateSelected: function() {
      this._selectSelected(this.selected);
    },

    _selectSelected: function(selected) {
      this._selection.select(this._valueToItem(this.selected));
    },

    _filterItem: function(node) {
      return !this._excludedLocalNames[node.localName];
    },

    _valueToItem: function(value) {
      return (value == null) ? null : this.items[this._valueToIndex(value)];
    },

    _valueToIndex: function(value) {
      if (this.attrForSelected) {
        for (var i = 0, item; item = this.items[i]; i++) {
          if (this._valueForItem(item) == value) {
            return i;
          }
        }
      } else {
        return Number(value);
      }
    },

    _indexToValue: function(index) {
      if (this.attrForSelected) {
        var item = this.items[index];
        if (item) {
          return this._valueForItem(item);
        }
      } else {
        return index;
      }
    },

    _valueForItem: function(item) {
      return item[this.attrForSelected] || item.getAttribute(this.attrForSelected);
    },

    _applySelection: function(item, isSelected) {
      if (this.selectedClass) {
        this.toggleClass(this.selectedClass, isSelected, item);
      }
      if (this.selectedAttribute) {
        this.toggleAttribute(this.selectedAttribute, isSelected, item);
      }
      this._selectionChange();
      this.fire('iron-' + (isSelected ? 'select' : 'deselect'), {item: item});
    },

    _selectionChange: function() {
      this._setSelectedItem(this._selection.get());
    },

    // observe content changes under the given node.
    _observeContent: function(node) {
      var content = node.querySelector('content');
      if (content && content.parentElement === node) {
        return this._observeItems(node.domHost);
      }
    },

    // observe items change under the given node.
    _observeItems: function(node) {
      // TODO(cdata): Update this when we get distributed children changed.
      var observer = new MutationObserver(function(mutations) {
        // Let other interested parties know about the change so that
        // we don't have to recreate mutation observers everywher.
        this.fire('iron-items-changed', mutations, {
          bubbles: false,
          cancelable: false
        });

        if (this.selected != null) {
          this._updateSelected();
        }
      }.bind(this));
      observer.observe(node, {
        childList: true,
        subtree: true
      });
      return observer;
    },

    _activateHandler: function(e) {
      var t = e.target;
      var items = this.items;
      while (t && t != this) {
        var i = items.indexOf(t);
        if (i >= 0) {
          var value = this._indexToValue(i);
          this._itemActivate(value, t);
          return;
        }
        t = t.parentNode;
      }
    },

    _itemActivate: function(value, item) {
      if (!this.fire('iron-activate',
          {selected: value, item: item}, {cancelable: true}).defaultPrevented) {
        this.select(value);
      }
    }

  };

</script>
<script>
  /** @polymerBehavior Polymer.IronMultiSelectableBehavior */
  Polymer.IronMultiSelectableBehaviorImpl = {
    properties: {

      /**
       * If true, multiple selections are allowed.
       */
      multi: {
        type: Boolean,
        value: false,
        observer: 'multiChanged'
      },

      /**
       * Gets or sets the selected elements. This is used instead of `selected` when `multi`
       * is true.
       */
      selectedValues: {
        type: Array,
        notify: true
      },

      /**
       * Returns an array of currently selected items.
       */
      selectedItems: {
        type: Array,
        readOnly: true,
        notify: true
      },

    },

    observers: [
      '_updateSelected(attrForSelected, selectedValues)'
    ],

    /**
     * Selects the given value. If the `multi` property is true, then the selected state of the
     * `value` will be toggled; otherwise the `value` will be selected.
     *
     * @method select
     * @param {string} value the value to select.
     */
    select: function(value) {
      if (this.multi) {
        if (this.selectedValues) {
          this._toggleSelected(value);
        } else {
          this.selectedValues = [value];
        }
      } else {
        this.selected = value;
      }
    },

    multiChanged: function(multi) {
      this._selection.multi = multi;
    },

    _updateSelected: function() {
      if (this.multi) {
        this._selectMulti(this.selectedValues);
      } else {
        this._selectSelected(this.selected);
      }
    },

    _selectMulti: function(values) {
      this._selection.clear();
      if (values) {
        for (var i = 0; i < values.length; i++) {
          this._selection.setItemSelected(this._valueToItem(values[i]), true);
        }
      }
    },

    _selectionChange: function() {
      var s = this._selection.get();
      if (this.multi) {
        this._setSelectedItems(s);
      } else {
        this._setSelectedItems([s]);
        this._setSelectedItem(s);
      }
    },

    _toggleSelected: function(value) {
      var i = this.selectedValues.indexOf(value);
      var unselected = i < 0;
      if (unselected) {
        this.push('selectedValues',value);
      } else {
        this.splice('selectedValues',i,1);
      }
      this._selection.setItemSelected(this._valueToItem(value), unselected);
    }
  };

  /** @polymerBehavior */
  Polymer.IronMultiSelectableBehavior = [
    Polymer.IronSelectableBehavior,
    Polymer.IronMultiSelectableBehaviorImpl
  ];

</script>
<script>
  /**
  `iron-selector` is an element which can be used to manage a list of elements
  that can be selected.  Tapping on the item will make the item selected.  The `selected` indicates
  which item is being selected.  The default is to use the index of the item.

  Example:

      <iron-selector selected="0">
        <div>Item 1</div>
        <div>Item 2</div>
        <div>Item 3</div>
      </iron-selector>

  If you want to use the attribute value of an element for `selected` instead of the index,
  set `attrForSelected` to the name of the attribute.  For example, if you want to select item by
  `name`, set `attrForSelected` to `name`.

  Example:

      <iron-selector attr-for-selected="name" selected="foo">
        <div name="foo">Foo</div>
        <div name="bar">Bar</div>
        <div name="zot">Zot</div>
      </iron-selector>

  `iron-selector` is not styled. Use the `iron-selected` CSS class to style the selected element.

  Example:

      <style>
        .iron-selected {
          background: #eee;
        }
      </style>

      ...

      <iron-selector selected="0">
        <div>Item 1</div>
        <div>Item 2</div>
        <div>Item 3</div>
      </iron-selector>

  @demo demo/index.html
  */

  Polymer({

    is: 'iron-selector',

    behaviors: [
      Polymer.IronMultiSelectableBehavior
    ]

  });

</script>
<!--
`paper-drawer-panel` contains a drawer panel and a main panel.  The drawer
and the main panel are side-by-side with drawer on the left.  When the browser
window size is smaller than the `responsiveWidth`, `paper-drawer-panel`
changes to narrow layout.  In narrow layout, the drawer will be stacked on top
of the main panel.  The drawer will slide in/out to hide/reveal the main
panel.

Use the attribute `drawer` to indicate that the element is the drawer panel and
`main` to indicate that the element is the main panel.

Example:

    <paper-drawer-panel>
      <div drawer> Drawer panel... </div>
      <div main> Main panel... </div>
    </paper-drawer-panel>

The drawer and the main panels are not scrollable.  You can set CSS overflow
property on the elements to make them scrollable or use `paper-header-panel`.

Example:

    <paper-drawer-panel>
      <paper-header-panel drawer>
        <paper-toolbar></paper-toolbar>
        <div> Drawer content... </div>
      </paper-header-panel>
      <paper-header-panel main>
        <paper-toolbar></paper-toolbar>
        <div> Main content... </div>
      </paper-header-panel>
    </paper-drawer-panel>

An element that should toggle the drawer will automatically do so if it's
given the `paper-drawer-toggle` attribute.  Also this element will automatically
be hidden in wide layout.

Example:

    <paper-drawer-panel>
      <paper-header-panel drawer>
        <paper-toolbar>
          <div>Application</div>
        </paper-toolbar>
        <div> Drawer content... </div>
      </paper-header-panel>
      <paper-header-panel main>
        <paper-toolbar>
          <paper-icon-button icon="menu" paper-drawer-toggle></paper-icon-button>
          <div>Title</div>
        </paper-toolbar>
        <div> Main content... </div>
      </paper-header-panel>
    </paper-drawer-panel>

To position the drawer to the right, add `right-drawer` attribute.

    <paper-drawer-panel right-drawer>
      <div drawer> Drawer panel... </div>
      <div main> Main panel... </div>
    </paper-drawer-panel>

Styling `paper-drawer-panel`

To change the main container:

    paper-drawer-panel {
      --paper-drawer-panel-main-container: {
        background-color: gray;
      };
    }

To change the drawer container when it's in the left side:

    paper-drawer-panel {
      --paper-drawer-panel-left-drawer-container: {
        background-color: white;
      };
    }

To change the drawer container when it's in the right side:

    paper-drawer-panel {
      --paper-drawer-panel-right-drawer-container: {
        background-color: white;
      };
    }

@group Paper elements
@element paper-drawer-panel
@demo demo/index.html
@hero hero.svg
-->

<!--
The `<iron-flex-layout>` component provides simple ways to use [CSS flexible box layout](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Flexible_boxes), also known as flexbox. This component provides two different ways to use flexbox:

1. [Layout classes](https://github.com/PolymerElements/iron-flex-layout/tree/master/classes). The layout class stylesheet provides a simple set of class-based flexbox rules. Layout classes let you specify layout properties directly in markup.

2. [Custom CSS mixins](https://github.com/PolymerElements/iron-flex-layout/blob/master/iron-flex-layout.html). The mixin stylesheet includes custom CSS mixins that can be applied inside a CSS rule using the `@apply` function.

A complete [guide](https://elements.polymer-project.org/guides/flex-layout) to `<iron-flex-layout>` is available.

@group Iron Elements
@pseudoElement iron-flex-layout
@demo demo/index.html
-->

<style>
  /* IE 10 support for HTML5 hidden attr */
  [hidden] {
    display: none !important;
  }
</style>

<style is="custom-style">
  :root {

    --layout: {
      display: -ms-flexbox;
      display: -webkit-flex;
      display: flex;
    };

    --layout-inline: {
      display: -ms-inline-flexbox;
      display: -webkit-inline-flex;
      display: inline-flex;
    };

    --layout-horizontal: {
      /* @apply(--layout); */
      display: -ms-flexbox;
      display: -webkit-flex;
      display: flex;

      -ms-flex-direction: row;
      -webkit-flex-direction: row;
      flex-direction: row;
    };

    --layout-horizontal-reverse: {
      -ms-flex-direction: row-reverse;
      -webkit-flex-direction: row-reverse;
      flex-direction: row-reverse;
    };

    --layout-vertical: {
      /* @apply(--layout); */
      display: -ms-flexbox;
      display: -webkit-flex;
      display: flex;

      -ms-flex-direction: column;
      -webkit-flex-direction: column;
      flex-direction: column;
    };

    --layout-vertical-reverse: {
      -ms-flex-direction: column-reverse;
      -webkit-flex-direction: column-reverse;
      flex-direction: column-reverse;
    };

    --layout-wrap: {
      -ms-flex-wrap: wrap;
      -webkit-flex-wrap: wrap;
      flex-wrap: wrap;
    };

    --layout-wrap-reverse: {
      -ms-flex-wrap: wrap-reverse;
      -webkit-flex-wrap: wrap-reverse;
      flex-wrap: wrap-reverse;
    };

    --layout-flex-auto: {
      -ms-flex: 1 1 auto;
      -webkit-flex: 1 1 auto;
      flex: 1 1 auto;
    };

    --layout-flex-none: {
      -ms-flex: none;
      -webkit-flex: none;
      flex: none;
    };

    --layout-flex: {
      -ms-flex: 1 1 0.000000001px;
      -webkit-flex: 1;
      flex: 1;
      -webkit-flex-basis: 0.000000001px;
      flex-basis: 0.000000001px;
    };

    --layout-flex-2: {
      -ms-flex: 2;
      -webkit-flex: 2;
      flex: 2;
    };

    --layout-flex-3: {
      -ms-flex: 3;
      -webkit-flex: 3;
      flex: 3;
    };

    --layout-flex-4: {
      -ms-flex: 4;
      -webkit-flex: 4;
      flex: 4;
    };

    --layout-flex-5: {
      -ms-flex: 5;
      -webkit-flex: 5;
      flex: 5;
    };

    --layout-flex-6: {
      -ms-flex: 6;
      -webkit-flex: 6;
      flex: 6;
    };

    --layout-flex-7: {
      -ms-flex: 7;
      -webkit-flex: 7;
      flex: 7;
    };

    --layout-flex-8: {
      -ms-flex: 8;
      -webkit-flex: 8;
      flex: 8;
    };

    --layout-flex-9: {
      -ms-flex: 9;
      -webkit-flex: 9;
      flex: 9;
    };

    --layout-flex-10: {
      -ms-flex: 10;
      -webkit-flex: 10;
      flex: 10;
    };

    --layout-flex-11: {
      -ms-flex: 11;
      -webkit-flex: 11;
      flex: 11;
    };

    --layout-flex-12: {
      -ms-flex: 12;
      -webkit-flex: 12;
      flex: 12;
    };

    /* alignment in cross axis */

    --layout-start: {
      -ms-flex-align: start;
      -webkit-align-items: flex-start;
      align-items: flex-start;
    };

    --layout-center: {
      -ms-flex-align: center;
      -webkit-align-items: center;
      align-items: center;
    };

    --layout-end: {
      -ms-flex-align: end;
      -webkit-align-items: flex-end;
      align-items: flex-end;
    };

    /* alignment in main axis */

    --layout-start-justified: {
      -ms-flex-pack: start;
      -webkit-justify-content: flex-start;
      justify-content: flex-start;
    };

    --layout-center-justified: {
      -ms-flex-pack: center;
      -webkit-justify-content: center;
      justify-content: center;
    };

    --layout-end-justified: {
      -ms-flex-pack: end;
      -webkit-justify-content: flex-end;
      justify-content: flex-end;
    };

    --layout-around-justified: {
      -ms-flex-pack: around;
      -webkit-justify-content: space-around;
      justify-content: space-around;
    };

    --layout-justified: {
      -ms-flex-pack: justify;
      -webkit-justify-content: space-between;
      justify-content: space-between;
    };

    --layout-center-center: {
      /* @apply(--layout-center --layout-center-justified); */
      -ms-flex-align: center;
      -webkit-align-items: center;
      align-items: center;
      -ms-flex-pack: center;
      -webkit-justify-content: center;
      justify-content: center;
    };

    /* self alignment */

    --layout-self-start: {
      -ms-align-self: flex-start;
      -webkit-align-self: flex-start;
      align-self: flex-start;
    };

    --layout-self-center: {
      -ms-align-self: center;
      -webkit-align-self: center;
      align-self: center;
    };

    --layout-self-end: {
      -ms-align-self: flex-end;
      -webkit-align-self: flex-end;
      align-self: flex-end;
    };

    --layout-self-stretch: {
      -ms-align-self: stretch;
      -webkit-align-self: stretch;
      align-self: stretch;
    };

    /*******************************
              Other Layout
    *******************************/

    --layout-block: {
      display: block;
    };

    --layout-invisible: {
      visibility: hidden !important;
    };

    --layout-relative: {
      position: relative;
    };

    --layout-fit: {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    };

    --layout-scroll: {
      -webkit-overflow-scrolling: touch;
      overflow: auto;
    };

    /* fixed position */

    --layout-fixed-top: {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
    };

    --layout-fixed-right: {
      position: fixed;
      top: 0;
      right: 0;
      bottom: 0;
    };

    --layout-fixed-bottom: {
      position: fixed;
      right: 0;
      bottom: 0;
      left: 0;
    };

    --layout-fixed-left: {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
    };

  }

</style>
<!--
`paper-header-panel` contains a header section and a content panel section.

__Important:__ The `paper-header-panel` will not display if its parent does not have a height.

Using layout classes, you can make the `paper-header-panel` fill the screen

    <body class="fullbleed layout vertical">
      <paper-header-panel class="flex">
        <paper-toolbar>
          <div>Hello World!</div>
        </paper-toolbar>
      </paper-header-panel>
    </body>

Special support is provided for scrolling modes when one uses a paper-toolbar or equivalent for the
header section.

Example:

    <paper-header-panel>
      <paper-toolbar>Header</paper-toolbar>
      <div>Content goes here...</div>
    </paper-header-panel>

If you want to use other than `paper-toolbar` for the header, add `paper-header` class to that
element.

Example:

    <paper-header-panel>
      <div class="paper-header">Header</div>
      <div>Content goes here...</div>
    </paper-header-panel>

To have the content fit to the main area, use the `fit` class.

    <paper-header-panel>
      <div class="paper-header">standard</div>
      <div class="fit">content fits 100% below the header</div>
    </paper-header-panel>

Modes

Controls header and scrolling behavior. Options are `standard`, `seamed`, `waterfall`, `waterfall-tall`, `scroll` and
`cover`. Default is `standard`.

Mode | Description
----------------|-------------
`standard` | The header is a step above the panel. The header will consume the panel at the point of entry, preventing it from passing through to the opposite side.
`seamed` | The header is presented as seamed with the panel.
`waterfall` | Similar to standard mode, but header is initially presented as seamed with panel, but then separates to form the step.
`waterfall-tall` | The header is initially taller (`tall` class is added to the header). As the user scrolls, the header separates (forming an edge) while condensing (`tall` class is removed from the header).
`scroll` | The header keeps its seam with the panel, and is pushed off screen.
`cover` | The panel covers the whole `paper-header-panel` including the header. This allows user to style the panel in such a way that the panel is partially covering the header.

Example:

    <paper-header-panel mode="waterfall">
      <div class="paper-header">standard</div>
      <div class="content fit">content fits 100% below the header</div>
    </paper-header-panel>


Styling header panel:

To change the shadow that shows up underneath the header:

    paper-header-panel {
      --paper-header-panel-shadow: {
          height: 6px;
          bottom: -6px;
          box-shadow: inset 0px 5px 6px -3px rgba(0, 0, 0, 0.4);
      };
    }

To change the panel container in different modes:

    paper-slider {
      --paper-header-panel-standard-container: {
        border: 1px solid gray;
      };

      --paper-header-panel-seamed-container: {
        border: 1px solid gray;
      };

      --paper-header-panel-waterfall-container: {
        border: 1px solid gray;
      };

      --paper-header-panel-waterfall-tall-container: {
        border: 1px solid gray;
      };

      --paper-header-panel-scroll-container: {
        border: 1px solid gray;
      };

      --paper-header-panel-cover-container: {
        border: 1px solid gray;
      };
    }

@group Paper Elements
@element paper-header-panel
@demo demo/index.html
@hero hero.svg
-->

<style>

  /*******************************
            Flex Layout
  *******************************/

  html /deep/ .layout.horizontal,
  html /deep/ .layout.horizontal-reverse,
  html /deep/ .layout.vertical,
  html /deep/ .layout.vertical-reverse {
    display: -ms-flexbox;
    display: -webkit-flex;
    display: flex;
  }

  html /deep/ .layout.inline {
    display: -ms-inline-flexbox;
    display: -webkit-inline-flex;
    display: inline-flex;
  }

  html /deep/ .layout.horizontal {
    -ms-flex-direction: row;
    -webkit-flex-direction: row;
    flex-direction: row;
  }

  html /deep/ .layout.horizontal-reverse {
    -ms-flex-direction: row-reverse;
    -webkit-flex-direction: row-reverse;
    flex-direction: row-reverse;
  }

  html /deep/ .layout.vertical {
    -ms-flex-direction: column;
    -webkit-flex-direction: column;
    flex-direction: column;
  }

  html /deep/ .layout.vertical-reverse {
    -ms-flex-direction: column-reverse;
    -webkit-flex-direction: column-reverse;
    flex-direction: column-reverse;
  }

  html /deep/ .layout.wrap {
    -ms-flex-wrap: wrap;
    -webkit-flex-wrap: wrap;
    flex-wrap: wrap;
  }

  html /deep/ .layout.wrap-reverse {
    -ms-flex-wrap: wrap-reverse;
    -webkit-flex-wrap: wrap-reverse;
    flex-wrap: wrap-reverse;
  }

  html /deep/ .flex-auto {
    -ms-flex: 1 1 auto;
    -webkit-flex: 1 1 auto;
    flex: 1 1 auto;
  }

  html /deep/ .flex-none {
    -ms-flex: none;
    -webkit-flex: none;
    flex: none;
  }

  html /deep/ .flex,
  html /deep/ .flex-1 {
    -ms-flex: 1;
    -webkit-flex: 1;
    flex: 1;
  }

  html /deep/ .flex-2 {
    -ms-flex: 2;
    -webkit-flex: 2;
    flex: 2;
  }

  html /deep/ .flex-3 {
    -ms-flex: 3;
    -webkit-flex: 3;
    flex: 3;
  }

  html /deep/ .flex-4 {
    -ms-flex: 4;
    -webkit-flex: 4;
    flex: 4;
  }

  html /deep/ .flex-5 {
    -ms-flex: 5;
    -webkit-flex: 5;
    flex: 5;
  }

  html /deep/ .flex-6 {
    -ms-flex: 6;
    -webkit-flex: 6;
    flex: 6;
  }

  html /deep/ .flex-7 {
    -ms-flex: 7;
    -webkit-flex: 7;
    flex: 7;
  }

  html /deep/ .flex-8 {
    -ms-flex: 8;
    -webkit-flex: 8;
    flex: 8;
  }

  html /deep/ .flex-9 {
    -ms-flex: 9;
    -webkit-flex: 9;
    flex: 9;
  }

  html /deep/ .flex-10 {
    -ms-flex: 10;
    -webkit-flex: 10;
    flex: 10;
  }

  html /deep/ .flex-11 {
    -ms-flex: 11;
    -webkit-flex: 11;
    flex: 11;
  }

  html /deep/ .flex-12 {
    -ms-flex: 12;
    -webkit-flex: 12;
    flex: 12;
  }

  /* alignment in cross axis */

  html /deep/ .layout.start {
    -ms-flex-align: start;
    -webkit-align-items: flex-start;
    align-items: flex-start;
  }

  html /deep/ .layout.center,
  html /deep/ .layout.center-center {
    -ms-flex-align: center;
    -webkit-align-items: center;
    align-items: center;
  }

  html /deep/ .layout.end {
    -ms-flex-align: end;
    -webkit-align-items: flex-end;
    align-items: flex-end;
  }

  /* alignment in main axis */

  html /deep/ .layout.start-justified {
    -ms-flex-pack: start;
    -webkit-justify-content: flex-start;
    justify-content: flex-start;
  }

  html /deep/ .layout.center-justified,
  html /deep/ .layout.center-center {
    -ms-flex-pack: center;
    -webkit-justify-content: center;
    justify-content: center;
  }

  html /deep/ .layout.end-justified {
    -ms-flex-pack: end;
    -webkit-justify-content: flex-end;
    justify-content: flex-end;
  }

  html /deep/ .layout.around-justified {
    -ms-flex-pack: around;
    -webkit-justify-content: space-around;
    justify-content: space-around;
  }

  html /deep/ .layout.justified {
    -ms-flex-pack: justify;
    -webkit-justify-content: space-between;
    justify-content: space-between;
  }

  /* self alignment */

  html /deep/ .self-start {
    -ms-align-self: flex-start;
    -webkit-align-self: flex-start;
    align-self: flex-start;
  }

  html /deep/ .self-center {
    -ms-align-self: center;
    -webkit-align-self: center;
    align-self: center;
  }

  html /deep/ .self-end {
    -ms-align-self: flex-end;
    -webkit-align-self: flex-end;
    align-self: flex-end;
  }

  html /deep/ .self-stretch {
    -ms-align-self: stretch;
    -webkit-align-self: stretch;
    align-self: stretch;
  }

  /*******************************
            Other Layout
  *******************************/

  html /deep/ .block {
    display: block;
  }

  /* IE 10 support for HTML5 hidden attr */
  html /deep/ [hidden] {
    display: none !important;
  }

  html /deep/ .invisible {
    visibility: hidden !important;
  }

  html /deep/ .relative {
    position: relative;
  }

  html /deep/ .fit {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }

  body.fullbleed {
    margin: 0;
    height: 100vh;
  }

  html /deep/ .scroll {
    -webkit-overflow-scrolling: touch;
    overflow: auto;
  }

  .fixed-bottom,
  .fixed-left,
  .fixed-right,
  .fixed-top {
    position: fixed;
  }

  html /deep/ .fixed-top {
    top: 0;
    left: 0;
    right: 0;
  }

  html /deep/ .fixed-right {
    top: 0;
    right: 0;
    botttom: 0;
  }

  html /deep/ .fixed-bottom {
    right: 0;
    bottom: 0;
    left: 0;
  }

  html /deep/ .fixed-left {
    top: 0;
    botttom: 0;
    left: 0;
  }

</style>
<style>

  /*******************************
            Flex Layout
  *******************************/

  .layout.horizontal,
  .layout.horizontal-reverse,
  .layout.vertical,
  .layout.vertical-reverse {
    display: -ms-flexbox;
    display: -webkit-flex;
    display: flex;
  }

  .layout.inline {
    display: -ms-inline-flexbox;
    display: -webkit-inline-flex;
    display: inline-flex;
  }

  .layout.horizontal {
    -ms-flex-direction: row;
    -webkit-flex-direction: row;
    flex-direction: row;
  }

  .layout.horizontal-reverse {
    -ms-flex-direction: row-reverse;
    -webkit-flex-direction: row-reverse;
    flex-direction: row-reverse;
  }

  .layout.vertical {
    -ms-flex-direction: column;
    -webkit-flex-direction: column;
    flex-direction: column;
  }

  .layout.vertical-reverse {
    -ms-flex-direction: column-reverse;
    -webkit-flex-direction: column-reverse;
    flex-direction: column-reverse;
  }

  .layout.wrap {
    -ms-flex-wrap: wrap;
    -webkit-flex-wrap: wrap;
    flex-wrap: wrap;
  }

  .layout.wrap-reverse {
    -ms-flex-wrap: wrap-reverse;
    -webkit-flex-wrap: wrap-reverse;
    flex-wrap: wrap-reverse;
  }

  .flex-auto {
    -ms-flex: 1 1 auto;
    -webkit-flex: 1 1 auto;
    flex: 1 1 auto;
  }

  .flex-none {
    -ms-flex: none;
    -webkit-flex: none;
    flex: none;
  }

  .flex,
  .flex-1 {
    -ms-flex: 1;
    -webkit-flex: 1;
    flex: 1;
  }

  .flex-2 {
    -ms-flex: 2;
    -webkit-flex: 2;
    flex: 2;
  }

  .flex-3 {
    -ms-flex: 3;
    -webkit-flex: 3;
    flex: 3;
  }

  .flex-4 {
    -ms-flex: 4;
    -webkit-flex: 4;
    flex: 4;
  }

  .flex-5 {
    -ms-flex: 5;
    -webkit-flex: 5;
    flex: 5;
  }

  .flex-6 {
    -ms-flex: 6;
    -webkit-flex: 6;
    flex: 6;
  }

  .flex-7 {
    -ms-flex: 7;
    -webkit-flex: 7;
    flex: 7;
  }

  .flex-8 {
    -ms-flex: 8;
    -webkit-flex: 8;
    flex: 8;
  }

  .flex-9 {
    -ms-flex: 9;
    -webkit-flex: 9;
    flex: 9;
  }

  .flex-10 {
    -ms-flex: 10;
    -webkit-flex: 10;
    flex: 10;
  }

  .flex-11 {
    -ms-flex: 11;
    -webkit-flex: 11;
    flex: 11;
  }

  .flex-12 {
    -ms-flex: 12;
    -webkit-flex: 12;
    flex: 12;
  }

  /* alignment in cross axis */

  .layout.start {
    -ms-flex-align: start;
    -webkit-align-items: flex-start;
    align-items: flex-start;
  }

  .layout.center,
  .layout.center-center {
    -ms-flex-align: center;
    -webkit-align-items: center;
    align-items: center;
  }

  .layout.end {
    -ms-flex-align: end;
    -webkit-align-items: flex-end;
    align-items: flex-end;
  }

  /* alignment in main axis */

  .layout.start-justified {
    -ms-flex-pack: start;
    -webkit-justify-content: flex-start;
    justify-content: flex-start;
  }

  .layout.center-justified,
  .layout.center-center {
    -ms-flex-pack: center;
    -webkit-justify-content: center;
    justify-content: center;
  }

  .layout.end-justified {
    -ms-flex-pack: end;
    -webkit-justify-content: flex-end;
    justify-content: flex-end;
  }

  .layout.around-justified {
    -ms-flex-pack: around;
    -webkit-justify-content: space-around;
    justify-content: space-around;
  }

  .layout.justified {
    -ms-flex-pack: justify;
    -webkit-justify-content: space-between;
    justify-content: space-between;
  }

  /* self alignment */

  .self-start {
    -ms-align-self: flex-start;
    -webkit-align-self: flex-start;
    align-self: flex-start;
  }

  .self-center {
    -ms-align-self: center;
    -webkit-align-self: center;
    align-self: center;
  }

  .self-end {
    -ms-align-self: flex-end;
    -webkit-align-self: flex-end;
    align-self: flex-end;
  }

  .self-stretch {
    -ms-align-self: stretch;
    -webkit-align-self: stretch;
    align-self: stretch;
  }

  /*******************************
            Other Layout
  *******************************/

  .block {
    display: block;
  }

  /* IE 10 support for HTML5 hidden attr */
  [hidden] {
    display: none !important;
  }

  .invisible {
    visibility: hidden !important;
  }

  .relative {
    position: relative;
  }

  .fit {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }

  body.fullbleed {
    margin: 0;
    height: 100vh;
  }

  .scroll {
    -webkit-overflow-scrolling: touch;
    overflow: auto;
  }

  /* fixed position */

  .fixed-bottom,
  .fixed-left,
  .fixed-right,
  .fixed-top {
    position: fixed;
  }

  .fixed-top {
    top: 0;
    left: 0;
    right: 0;
  }

  .fixed-right {
    top: 0;
    right: 0;
    bottom: 0;
  }

  .fixed-bottom {
    right: 0;
    bottom: 0;
    left: 0;
  }

  .fixed-left {
    top: 0;
    bottom: 0;
    left: 0;
  }

</style>
<style is="custom-style">

  :root {

    /* Material Design color palette for Google products */

    --google-red-100: #f4c7c3;
    --google-red-300: #e67c73;
    --google-red-500: #db4437;
    --google-red-700: #c53929;

    --google-blue-100: #c6dafc;
    --google-blue-300: #7baaf7;
    --google-blue-500: #4285f4;
    --google-blue-700: #3367d6;

    --google-green-100: #b7e1cd;
    --google-green-300: #57bb8a;
    --google-green-500: #0f9d58;
    --google-green-700: #0b8043;

    --google-yellow-100: #fce8b2;
    --google-yellow-300: #f7cb4d;
    --google-yellow-500: #f4b400;
    --google-yellow-700: #f09300;

    --google-grey-100: #f5f5f5;
    --google-grey-300: #e0e0e0;
    --google-grey-500: #9e9e9e;
    --google-grey-700: #616161;
    
    /* Material Design color palette from online spec document */

    --paper-red-50: #ffebee;
    --paper-red-100: #ffcdd2;
    --paper-red-200: #ef9a9a;
    --paper-red-300: #e57373;
    --paper-red-400: #ef5350;
    --paper-red-500: #f44336;
    --paper-red-600: #e53935;
    --paper-red-700: #d32f2f;
    --paper-red-800: #c62828;
    --paper-red-900: #b71c1c;
    --paper-red-a100: #ff8a80;
    --paper-red-a200: #ff5252;
    --paper-red-a400: #ff1744;
    --paper-red-a700: #d50000;
 
    --paper-pink-50: #fce4ec;
    --paper-pink-100: #f8bbd0;
    --paper-pink-200: #f48fb1;
    --paper-pink-300: #f06292;
    --paper-pink-400: #ec407a;
    --paper-pink-500: #e91e63;
    --paper-pink-600: #d81b60;
    --paper-pink-700: #c2185b;
    --paper-pink-800: #ad1457;
    --paper-pink-900: #880e4f;
    --paper-pink-a100: #ff80ab;
    --paper-pink-a200: #ff4081;
    --paper-pink-a400: #f50057;
    --paper-pink-a700: #c51162;
 
    --paper-purple-50: #f3e5f5;
    --paper-purple-100: #e1bee7;
    --paper-purple-200: #ce93d8;
    --paper-purple-300: #ba68c8;
    --paper-purple-400: #ab47bc;
    --paper-purple-500: #9c27b0;
    --paper-purple-600: #8e24aa;
    --paper-purple-700: #7b1fa2;
    --paper-purple-800: #6a1b9a;
    --paper-purple-900: #4a148c;
    --paper-purple-a100: #ea80fc;
    --paper-purple-a200: #e040fb;
    --paper-purple-a400: #d500f9;
    --paper-purple-a700: #aa00ff;
 
    --paper-deep-purple-50: #ede7f6;
    --paper-deep-purple-100: #d1c4e9;
    --paper-deep-purple-200: #b39ddb;
    --paper-deep-purple-300: #9575cd;
    --paper-deep-purple-400: #7e57c2;
    --paper-deep-purple-500: #673ab7;
    --paper-deep-purple-600: #5e35b1;
    --paper-deep-purple-700: #512da8;
    --paper-deep-purple-800: #4527a0;
    --paper-deep-purple-900: #311b92;
    --paper-deep-purple-a100: #b388ff;
    --paper-deep-purple-a200: #7c4dff;
    --paper-deep-purple-a400: #651fff;
    --paper-deep-purple-a700: #6200ea;
 
    --paper-indigo-50: #e8eaf6;
    --paper-indigo-100: #c5cae9;
    --paper-indigo-200: #9fa8da;
    --paper-indigo-300: #7986cb;
    --paper-indigo-400: #5c6bc0;
    --paper-indigo-500: #3f51b5;
    --paper-indigo-600: #3949ab;
    --paper-indigo-700: #303f9f;
    --paper-indigo-800: #283593;
    --paper-indigo-900: #1a237e;
    --paper-indigo-a100: #8c9eff;
    --paper-indigo-a200: #536dfe;
    --paper-indigo-a400: #3d5afe;
    --paper-indigo-a700: #304ffe;
 
    --paper-blue-50: #e3f2fd;
    --paper-blue-100: #bbdefb;
    --paper-blue-200: #90caf9;
    --paper-blue-300: #64b5f6;
    --paper-blue-400: #42a5f5;
    --paper-blue-500: #2196f3;
    --paper-blue-600: #1e88e5;
    --paper-blue-700: #1976d2;
    --paper-blue-800: #1565c0;
    --paper-blue-900: #0d47a1;
    --paper-blue-a100: #82b1ff;
    --paper-blue-a200: #448aff;
    --paper-blue-a400: #2979ff;
    --paper-blue-a700: #2962ff;
 
    --paper-light-blue-50: #e1f5fe;
    --paper-light-blue-100: #b3e5fc;
    --paper-light-blue-200: #81d4fa;
    --paper-light-blue-300: #4fc3f7;
    --paper-light-blue-400: #29b6f6;
    --paper-light-blue-500: #03a9f4;
    --paper-light-blue-600: #039be5;
    --paper-light-blue-700: #0288d1;
    --paper-light-blue-800: #0277bd;
    --paper-light-blue-900: #01579b;
    --paper-light-blue-a100: #80d8ff;
    --paper-light-blue-a200: #40c4ff;
    --paper-light-blue-a400: #00b0ff;
    --paper-light-blue-a700: #0091ea;
 
    --paper-cyan-50: #e0f7fa;
    --paper-cyan-100: #b2ebf2;
    --paper-cyan-200: #80deea;
    --paper-cyan-300: #4dd0e1;
    --paper-cyan-400: #26c6da;
    --paper-cyan-500: #00bcd4;
    --paper-cyan-600: #00acc1;
    --paper-cyan-700: #0097a7;
    --paper-cyan-800: #00838f;
    --paper-cyan-900: #006064;
    --paper-cyan-a100: #84ffff;
    --paper-cyan-a200: #18ffff;
    --paper-cyan-a400: #00e5ff;
    --paper-cyan-a700: #00b8d4;
 
    --paper-teal-50: #e0f2f1;
    --paper-teal-100: #b2dfdb;
    --paper-teal-200: #80cbc4;
    --paper-teal-300: #4db6ac;
    --paper-teal-400: #26a69a;
    --paper-teal-500: #009688;
    --paper-teal-600: #00897b;
    --paper-teal-700: #00796b;
    --paper-teal-800: #00695c;
    --paper-teal-900: #004d40;
    --paper-teal-a100: #a7ffeb;
    --paper-teal-a200: #64ffda;
    --paper-teal-a400: #1de9b6;
    --paper-teal-a700: #00bfa5;
 
    --paper-green-50: #e8f5e9;
    --paper-green-100: #c8e6c9;
    --paper-green-200: #a5d6a7;
    --paper-green-300: #81c784;
    --paper-green-400: #66bb6a;
    --paper-green-500: #4caf50;
    --paper-green-600: #43a047;
    --paper-green-700: #388e3c;
    --paper-green-800: #2e7d32;
    --paper-green-900: #1b5e20;
    --paper-green-a100: #b9f6ca;
    --paper-green-a200: #69f0ae;
    --paper-green-a400: #00e676;
    --paper-green-a700: #00c853;
 
    --paper-light-green-50: #f1f8e9;
    --paper-light-green-100: #dcedc8;
    --paper-light-green-200: #c5e1a5;
    --paper-light-green-300: #aed581;
    --paper-light-green-400: #9ccc65;
    --paper-light-green-500: #8bc34a;
    --paper-light-green-600: #7cb342;
    --paper-light-green-700: #689f38;
    --paper-light-green-800: #558b2f;
    --paper-light-green-900: #33691e;
    --paper-light-green-a100: #ccff90;
    --paper-light-green-a200: #b2ff59;
    --paper-light-green-a400: #76ff03;
    --paper-light-green-a700: #64dd17;
 
    --paper-lime-50: #f9fbe7;
    --paper-lime-100: #f0f4c3;
    --paper-lime-200: #e6ee9c;
    --paper-lime-300: #dce775;
    --paper-lime-400: #d4e157;
    --paper-lime-500: #cddc39;
    --paper-lime-600: #c0ca33;
    --paper-lime-700: #afb42b;
    --paper-lime-800: #9e9d24;
    --paper-lime-900: #827717;
    --paper-lime-a100: #f4ff81;
    --paper-lime-a200: #eeff41;
    --paper-lime-a400: #c6ff00;
    --paper-lime-a700: #aeea00;
 
    --paper-yellow-50: #fffde7;
    --paper-yellow-100: #fff9c4;
    --paper-yellow-200: #fff59d;
    --paper-yellow-300: #fff176;
    --paper-yellow-400: #ffee58;
    --paper-yellow-500: #ffeb3b;
    --paper-yellow-600: #fdd835;
    --paper-yellow-700: #fbc02d;
    --paper-yellow-800: #f9a825;
    --paper-yellow-900: #f57f17;
    --paper-yellow-a100: #ffff8d;
    --paper-yellow-a200: #ffff00;
    --paper-yellow-a400: #ffea00;
    --paper-yellow-a700: #ffd600;
 
    --paper-amber-50: #fff8e1;
    --paper-amber-100: #ffecb3;
    --paper-amber-200: #ffe082;
    --paper-amber-300: #ffd54f;
    --paper-amber-400: #ffca28;
    --paper-amber-500: #ffc107;
    --paper-amber-600: #ffb300;
    --paper-amber-700: #ffa000;
    --paper-amber-800: #ff8f00;
    --paper-amber-900: #ff6f00;
    --paper-amber-a100: #ffe57f;
    --paper-amber-a200: #ffd740;
    --paper-amber-a400: #ffc400;
    --paper-amber-a700: #ffab00;
 
    --paper-orange-50: #fff3e0;
    --paper-orange-100: #ffe0b2;
    --paper-orange-200: #ffcc80;
    --paper-orange-300: #ffb74d;
    --paper-orange-400: #ffa726;
    --paper-orange-500: #ff9800;
    --paper-orange-600: #fb8c00;
    --paper-orange-700: #f57c00;
    --paper-orange-800: #ef6c00;
    --paper-orange-900: #e65100;
    --paper-orange-a100: #ffd180;
    --paper-orange-a200: #ffab40;
    --paper-orange-a400: #ff9100;
    --paper-orange-a700: #ff6500;
 
    --paper-deep-orange-50: #fbe9e7;
    --paper-deep-orange-100: #ffccbc;
    --paper-deep-orange-200: #ffab91;
    --paper-deep-orange-300: #ff8a65;
    --paper-deep-orange-400: #ff7043;
    --paper-deep-orange-500: #ff5722;
    --paper-deep-orange-600: #f4511e;
    --paper-deep-orange-700: #e64a19;
    --paper-deep-orange-800: #d84315;
    --paper-deep-orange-900: #bf360c;
    --paper-deep-orange-a100: #ff9e80;
    --paper-deep-orange-a200: #ff6e40;
    --paper-deep-orange-a400: #ff3d00;
    --paper-deep-orange-a700: #dd2c00;
 
    --paper-brown-50: #efebe9;
    --paper-brown-100: #d7ccc8;
    --paper-brown-200: #bcaaa4;
    --paper-brown-300: #a1887f;
    --paper-brown-400: #8d6e63;
    --paper-brown-500: #795548;
    --paper-brown-600: #6d4c41;
    --paper-brown-700: #5d4037;
    --paper-brown-800: #4e342e;
    --paper-brown-900: #3e2723;
 
    --paper-grey-50: #fafafa;
    --paper-grey-100: #f5f5f5;
    --paper-grey-200: #eeeeee;
    --paper-grey-300: #e0e0e0;
    --paper-grey-400: #bdbdbd;
    --paper-grey-500: #9e9e9e;
    --paper-grey-600: #757575;
    --paper-grey-700: #616161;
    --paper-grey-800: #424242;
    --paper-grey-900: #212121;
 
    --paper-blue-grey-50: #eceff1;
    --paper-blue-grey-100: #cfd8dc;
    --paper-blue-grey-200: #b0bec5;
    --paper-blue-grey-300: #90a4ae;
    --paper-blue-grey-400: #78909c;
    --paper-blue-grey-500: #607d8b;
    --paper-blue-grey-600: #546e7a;
    --paper-blue-grey-700: #455a64;
    --paper-blue-grey-800: #37474f;
    --paper-blue-grey-900: #263238;

    /* opacity for dark text on a light background */
    --dark-divider-opacity: 0.12;
    --dark-disabled-opacity: 0.26; /* or hint text */
    --dark-secondary-opacity: 0.54; /* or icon */
    --dark-primary-opacity: 0.87;

    /* opacity for light text on a dark background */
    --light-divider-opacity: 0.12;
    --light-disabled-opacity: 0.3; /* or hint text */
    --light-secondary-opacity: 0.7; /* or icon */
    --light-primary-opacity: 1.0;

  }

</style>
<style is="custom-style">

  :root {

    --dark-primary-color: #303f9f;

    --default-primary-color: #3f51b5;

    --light-primary-color: #c5cae9;

    --text-primary-color: #ffffff;

    --accent-color: #ff4081;

    --primary-background-color: #ffffff;

    --primary-text-color: #212121;

    --secondary-text-color: #757575;

    --disabled-text-color: #bdbdbd;

    --divider-color: #e0e0e0;

  }

</style>
<style is="custom-style">

  :root {

    --shadow-transition: {
      transition: box-shadow 0.28s cubic-bezier(0.4, 0, 0.2, 1);
    };

    --shadow-none: {
      box-shadow: none;
    };

    /* from http://codepen.io/shyndman/pen/c5394ddf2e8b2a5c9185904b57421cdb */

    --shadow-elevation-2dp: {
      box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14),
                  0 1px 5px 0 rgba(0, 0, 0, 0.12),
                  0 3px 1px -2px rgba(0, 0, 0, 0.2);
    };

    --shadow-elevation-3dp: {
      box-shadow: 0 3px 4px 0 rgba(0, 0, 0, 0.14),
                  0 1px 8px 0 rgba(0, 0, 0, 0.12),
                  0 3px 3px -2px rgba(0, 0, 0, 0.4);
    };

    --shadow-elevation-4dp: {
      box-shadow: 0 4px 5px 0 rgba(0, 0, 0, 0.14),
                  0 1px 10px 0 rgba(0, 0, 0, 0.12),
                  0 2px 4px -1px rgba(0, 0, 0, 0.4);
    };

    --shadow-elevation-6dp: {
      box-shadow: 0 6px 10px 0 rgba(0, 0, 0, 0.14),
                  0 1px 18px 0 rgba(0, 0, 0, 0.12),
                  0 3px 5px -1px rgba(0, 0, 0, 0.4);
    };

    --shadow-elevation-8dp: {
      box-shadow: 0 8px 10px 1px rgba(0, 0, 0, 0.14),
                  0 3px 14px 2px rgba(0, 0, 0, 0.12),
                  0 5px 5px -3px rgba(0, 0, 0, 0.4);
    };

    --shadow-elevation-16dp: {
      box-shadow: 0 16px 24px 2px rgba(0, 0, 0, 0.14),
                  0  6px 30px 5px rgba(0, 0, 0, 0.12),
                  0  8px 10px -5px rgba(0, 0, 0, 0.4);
    };

  }

</style>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic,500,500italic,700,700italic">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700">
<style is="custom-style">

  :root {

    /* Shared Styles */

    /*
    Unfortunately, we can't use nested rules
    See https://github.com/Polymer/polymer/issues/1399
    */
    --paper-font-common-base: {
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
    };

    --paper-font-common-code: {
      font-family: 'Roboto Mono', 'Consolas', 'Menlo', monospace;
      -webkit-font-smoothing: antialiased;
    };

    --paper-font-common-expensive-kerning: {
      text-rendering: optimizeLegibility;
    };

    --paper-font-common-nowrap: {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    };

    /* Material Font Styles */

    --paper-font-display4: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;
      /* @apply(--paper-font-common-nowrap); */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;

      font-size: 112px;
      font-weight: 300;
      letter-spacing: -.044em;
      line-height: 120px;
    };

    --paper-font-display3: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;
      /* @apply(--paper-font-common-nowrap); */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;

      font-size: 56px;
      font-weight: 400;
      letter-spacing: -.026em;
      line-height: 60px;
    };

    --paper-font-display2: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;

      font-size: 45px;
      font-weight: 400;
      letter-spacing: -.018em;
      line-height: 48px;
    };

    --paper-font-display1: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;

      font-size: 34px;
      font-weight: 400;
      letter-spacing: -.01em;
      line-height: 40px;
    };

    --paper-font-headline: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;

      font-size: 24px;
      font-weight: 400;
      letter-spacing: -.012em;
      line-height: 32px;
    };

    --paper-font-title: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;
      /* @apply(--paper-font-common-nowrap); */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;

      font-size: 20px;
      font-weight: 500;
      line-height: 28px;
    };

    --paper-font-subhead: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;

      font-size: 16px;
      font-weight: 400;
      line-height: 24px;
    };

    --paper-font-body2: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;

      font-size: 14px;
      font-weight: 500;
      line-height: 24px;
    };

    --paper-font-body1: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;

      font-size: 14px;
      font-weight: 400;
      line-height: 20px;
    };

    --paper-font-caption: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-nowrap); */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;

      font-size: 12px;
      font-weight: 400;
      letter-spacing: 0.011em;
      line-height: 20px;
    };

    --paper-font-menu: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;
      /* @apply(--paper-font-common-nowrap); */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;

      font-size: 13px;
      font-weight: 500;
      line-height: 24px;
    };

    --paper-font-button: {
      /* @apply(--paper-font-common-base) */
      font-family: 'Roboto', 'Noto', sans-serif;
      -webkit-font-smoothing: antialiased;
      /* @apply(--paper-font-common-expensive-kerning); */
      text-rendering: optimizeLegibility;
      /* @apply(--paper-font-common-nowrap); */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;

      font-size: 14px;
      font-weight: 500;
      letter-spacing: 0.018em;
      line-height: 24px;
      text-transform: uppercase;
    };

    --paper-font-code2: {
      /* @apply(--paper-font-common-code); */
      font-family: 'Roboto Mono', 'Consolas', 'Menlo', monospace;
      -webkit-font-smoothing: antialiased;

      font-size: 14px;
      font-weight: 700;
      line-height: 20px;
    };

    --paper-font-code1: {
      /* @apply(--paper-font-common-code); */
      font-family: 'Roboto Mono', 'Consolas', 'Menlo', monospace;
      -webkit-font-smoothing: antialiased;

      font-size: 14px;
      font-weight: 500;
      line-height: 20px;
    };

  }

</style>
<!--
`paper-toolbar` is a horizontal bar containing items that can be used for
label, navigation, search and actions.  The items place inside the
`paper-toolbar` are projected into a `class="horizontal center layout"` container inside of
`paper-toolbar`'s Shadow DOM.  You can use flex attributes to control the items'
sizing.

Example:

    <paper-toolbar>
      <paper-icon-button icon="menu" on-tap="menuAction"></paper-icon-button>
      <div class="title">Title</div>
      <paper-icon-button icon="more-vert" on-tap="moreAction"></paper-icon-button>
    </paper-toolbar>

`paper-toolbar` has a standard height, but can made be taller by setting `tall`
class on the `paper-toolbar`.  This will make the toolbar 3x the normal height.

    <paper-toolbar class="tall">
      <paper-icon-button icon="menu"></paper-icon-button>
    </paper-toolbar>

Apply `medium-tall` class to make the toolbar medium tall.  This will make the
toolbar 2x the normal height.

    <paper-toolbar class="medium-tall">
      <paper-icon-button icon="menu"></paper-icon-button>
    </paper-toolbar>

When `tall`, items can pin to either the top (default), middle or bottom.  Use
`middle` class for middle content and `bottom` class for bottom content.

    <paper-toolbar class="tall">
      <paper-icon-button icon="menu"></paper-icon-button>
      <div class="middle title">Middle Title</div>
      <div class="bottom title">Bottom Title</div>
    </paper-toolbar>

For `medium-tall` toolbar, the middle and bottom contents overlap and are
pinned to the bottom.  But `middleJustify` and `bottomJustify` attributes are
still honored separately.

To make an element completely fit at the bottom of the toolbar, use `fit` along
with `bottom`.

    <paper-toolbar class="tall">
      <div id="progressBar" class="bottom fit"></div>
    </paper-toolbar>

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-toolbar-background` | Toolbar background color     | `--default-primary-color`
`--paper-toolbar-color`      | Toolbar foreground color     | `--text-primary-color`
`--paper-toolbar`            | Mixin applied to the toolbar | `{}`

### Accessibility

`<paper-toolbar>` has `role="toolbar"` by default. Any elements with the class `title` will
be used as the label of the toolbar via `aria-labelledby`.

@demo demo/index.html
-->

<!--
`iron-a11y-announcer` is a singleton element that is intended to add a11y
to features that require on-demand announcement from screen readers. In
order to make use of the announcer, it is best to request its availability
in the announcing element.

Example:

    Polymer({

      is: 'x-chatty',

      attached: function() {
        // This will create the singlton element if it has not
        // been created yet:
        Polymer.IronA11yAnnouncer.requestAvailability();
      }
    });

After the `iron-a11y-announcer` has been made available, elements can
make announces by firing bubbling `iron-announce` events.

Example:

    this.fire('iron-announce', {
      text: 'This is an announcement!'
    }, { bubbles: true });

Note: announcements are only audible if you have a screen reader enabled.

@group Iron Elements
@demo demo/index.html
-->

<!--
`paper-toast` provides a subtle notification toast.

@group Paper Elements
@element paper-toast
@demo demo/index.html
@hero hero.svg
-->
<script>
  Polymer({
    is : 'cwn-region-label',

    properties : {
      prmname : {
        type : String,
        observer : 'prmnameObserver'
      }
    },

    ready : function() {
      this.style.display = 'inline-block';
    },

    prmnameObserver : function() {
      var node = CWN.ds.lookupMap[this.prmname];
      if( !node ) return;

      this.update(node);
    },

    update : function(feature) {
      this.innerHTML = '';
      if( !feature.properties ) return;
      if( !feature.properties.regions ) return;

      var html = [];
      for( var i = 0; i < feature.properties.regions.length; i++ ) {
        var r = feature.properties.regions[i];
        //if( r.toLowerCase() == 'california' ) continue;

        var info = this.getLabel(r);

        html.push('<span class="label label-default">'+info.label+
          (r.toLowerCase() !== 'california' ? ' <a href="#info/'+info.id+'"><i class="fa fa-info-circle"></i></a>' : '')+
          '</span>');
      }


      this.innerHTML = html.join(' <i class="fa fa-angle-right" style="vertical-align:middle"></i> ');

    },

    getLabel : function(name) {
      var region = CWN.ds.regionLookupMap[name];
      if( region && region.geo.properties.name ) {
        return {
          label : region.geo.properties.name,
          id : region.geo.properties.id
        }
      }
      return {
        label : name,
        id : name
      }
    }
  });
</script>
</head><body><div hidden="" by-vulcanize=""><dom-module id="paper-drawer-panel" assetpath="bower_components/paper-drawer-panel/">
  <style>
/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

:host {
  display: block;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

iron-selector > #drawer {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  background-color: white;

  -moz-box-sizing: border-box;
  box-sizing: border-box;

  @apply(--paper-drawer-panel-drawer-container);
}

.transition > #drawer {
  transition: -webkit-transform ease-in-out 0.3s, width ease-in-out 0.3s, visibility 0.3s;
  transition: transform ease-in-out 0.3s, width ease-in-out 0.3s, visibility 0.3s;
}

.left-drawer > #drawer {
  @apply(--paper-drawer-panel-left-drawer-container);
}

.right-drawer > #drawer {
  left: auto;
  right: 0;

  @apply(--paper-drawer-panel-right-drawer-container);
}

iron-selector > #main {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;

  @apply(--paper-drawer-panel-main-container);
}

.transition > #main {
  transition: left ease-in-out 0.3s, padding ease-in-out 0.3s;
}

.right-drawer > #main {
  left: 0;
}

.right-drawer.transition > #main {
  transition: right ease-in-out 0.3s, padding ease-in-out 0.3s;
}

#main > ::content > [main] {
  height: 100%;
}

#drawer > ::content > [drawer] {
  height: 100%;
}

#scrim {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  visibility: hidden;
  opacity: 0;
  transition: opacity ease-in-out 0.38s, visibility ease-in-out 0.38s;
  background-color: rgba(0, 0, 0, 0.3);
}

.narrow-layout > #drawer {
  will-change: transform;
}

.narrow-layout > #drawer.iron-selected {
  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.15);
}

.right-drawer.narrow-layout > #drawer.iron-selected {
  box-shadow: -2px 2px 4px rgba(0, 0, 0, 0.15);
}

.narrow-layout > #drawer > ::content > [drawer] {
  border: 0;
}

.left-drawer.narrow-layout > #drawer:not(.iron-selected) {
  -webkit-transform: translateX(-100%);
  transform: translateX(-100%);
}

.right-drawer.narrow-layout > #drawer:not(.iron-selected) {
  left: auto;
  visibility: hidden;

  -webkit-transform: translateX(100%);
  transform: translateX(100%);
}

.right-drawer.narrow-layout.dragging > #drawer:not(.iron-selected),
.right-drawer.narrow-layout.peeking > #drawer:not(.iron-selected) {
  visibility: visible;
}

.narrow-layout > #main {
  padding: 0;
}

.right-drawer.narrow-layout > #main {
  left: 0;
  right: 0;
}

.narrow-layout > #main:not(.iron-selected) > #scrim,
.dragging > #main > #scrim {
  visibility: visible;
  opacity: var(--paper-drawer-panel-scrim-opacity, 1);
}

.narrow-layout > #main > * {
  margin: 0;
  min-height: 100%;
  left: 0;
  right: 0;

  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

iron-selector:not(.narrow-layout) #main ::content [paper-drawer-toggle] {
  display: none;
}
</style>

  <template>
    <iron-media-query id="mq" on-query-matches-changed="_onQueryMatchesChanged" query="[[_computeMediaQuery(forceNarrow, responsiveWidth)]]">
    </iron-media-query>

    <iron-selector attr-for-selected="id" class$="[[_computeIronSelectorClass(narrow, transition, dragging, rightDrawer, peeking)]]" activate-event="" selected="[[selected]]">

      <div id="main" style$="[[_computeMainStyle(narrow, rightDrawer, drawerWidth)]]">
        <content select="[main]"></content>
        <div id="scrim" on-tap="closeDrawer"></div>
      </div>

      <div id="drawer" style$="[[_computeDrawerStyle(drawerWidth)]]">
        <content select="[drawer]"></content>
      </div>

    </iron-selector>
  </template>

</dom-module>

<script>

  (function() {

    'use strict';

   // this would be the only `paper-drawer-panel` in
   // the whole app that can be in `dragging` state
    var sharedPanel = null;

    function classNames(obj) {
      var classes = [];
      for (var key in obj) {
        if (obj.hasOwnProperty(key) && obj[key]) {
          classes.push(key);
        }
      }

      return classes.join(' ');
    }

    Polymer({

      is: 'paper-drawer-panel',

      /**
       * Fired when the narrow layout changes.
       *
       * @event paper-responsive-change {{narrow: boolean}} detail -
       *     narrow: true if the panel is in narrow layout.
       */

      /**
       * Fired when the a panel is selected.
       *
       * Listening for this event is an alternative to observing changes in the `selected` attribute.
       * This event is fired both when a panel is selected.
       *
       * @event iron-select {{item: Object}} detail -
       *     item: The panel that the event refers to.
       */

      /**
       * Fired when a panel is deselected.
       *
       * Listening for this event is an alternative to observing changes in the `selected` attribute.
       * This event is fired both when a panel is deselected.
       *
       * @event iron-deselect {{item: Object}} detail -
       *     item: The panel that the event refers to.
       */
      properties: {

        /**
         * The panel to be selected when `paper-drawer-panel` changes to narrow
         * layout.
         */
        defaultSelected: {
          type: String,
          value: 'main'
        },

        /**
         * If true, swipe from the edge is disable.
         */
        disableEdgeSwipe: {
          type: Boolean,
          value: false
        },

        /**
         * If true, swipe to open/close the drawer is disabled.
         */
        disableSwipe: {
          type: Boolean,
          value: false
        },

        /**
         * Whether the user is dragging the drawer interactively.
         */
        dragging: {
          type: Boolean,
          value: false,
          readOnly: true,
          notify: true
        },

        /**
         * Width of the drawer panel.
         */
        drawerWidth: {
          type: String,
          value: '256px'
        },

        /**
         * How many pixels on the side of the screen are sensitive to edge
         * swipes and peek.
         */
        edgeSwipeSensitivity: {
          type: Number,
          value: 30
        },

        /**
         * If true, ignore `responsiveWidth` setting and force the narrow layout.
         */
        forceNarrow: {
          type: Boolean,
          value: false
        },

        /**
         * Whether the browser has support for the transform CSS property.
         */
        hasTransform: {
          type: Boolean,
          value: function() {
            return 'transform' in this.style;
          }
        },

        /**
         * Whether the browser has support for the will-change CSS property.
         */
        hasWillChange: {
          type: Boolean,
          value: function() {
            return 'willChange' in this.style;
          }
        },

        /**
         * Returns true if the panel is in narrow layout.  This is useful if you
         * need to show/hide elements based on the layout.
         */
        narrow: {
          reflectToAttribute: true,
          type: Boolean,
          value: false,
          readOnly: true,
          notify: true
        },

        /**
         * Whether the drawer is peeking out from the edge.
         */
        peeking: {
          type: Boolean,
          value: false,
          readOnly: true,
          notify: true
        },

        /**
         * Max-width when the panel changes to narrow layout.
         */
        responsiveWidth: {
          type: String,
          value: '640px'
        },

        /**
         * If true, position the drawer to the right.
         */
        rightDrawer: {
          type: Boolean,
          value: false
        },

        /**
         * The panel that is being selected. `drawer` for the drawer panel and
         * `main` for the main panel.
         */
        selected: {
          reflectToAttribute: true,
          notify: true,
          type: String,
          value: null
        },

        /**
         * The attribute on elements that should toggle the drawer on tap, also elements will
         * automatically be hidden in wide layout.
         */
        drawerToggleAttribute: {
          type: String,
          value: 'paper-drawer-toggle'
        },

        /**
         * Whether the transition is enabled.
         */
        transition: {
          type: Boolean,
          value: false
        },

      },

      listeners: {
        tap: '_onTap',
        track: '_onTrack',
        down: '_downHandler',
        up: '_upHandler'
      },

      observers: [
        '_forceNarrowChanged(forceNarrow, defaultSelected)'
      ],

      /**
       * Toggles the panel open and closed.
       *
       * @method togglePanel
       */
      togglePanel: function() {
        if (this._isMainSelected()) {
          this.openDrawer();
        } else {
          this.closeDrawer();
        }
      },

      /**
       * Opens the drawer.
       *
       * @method openDrawer
       */
      openDrawer: function() {
        this.selected = 'drawer';
      },

      /**
       * Closes the drawer.
       *
       * @method closeDrawer
       */
      closeDrawer: function() {
        this.selected = 'main';
      },

      ready: function() {
        // Avoid transition at the beginning e.g. page loads and enable
        // transitions only after the element is rendered and ready.
        this.transition = true;
      },

      _computeIronSelectorClass: function(narrow, transition, dragging, rightDrawer, peeking) {
        return classNames({
          dragging: dragging,
          'narrow-layout': narrow,
          'right-drawer': rightDrawer,
          'left-drawer': !rightDrawer,
          transition: transition,
          peeking: peeking
        });
      },

      _computeDrawerStyle: function(drawerWidth) {
        return 'width:' + drawerWidth + ';';
      },

      _computeMainStyle: function(narrow, rightDrawer, drawerWidth) {
        var style = '';

        style += 'left:' + ((narrow || rightDrawer) ? '0' : drawerWidth) + ';';

        if (rightDrawer) {
          style += 'right:' + (narrow ? '' : drawerWidth) + ';';
        }

        return style;
      },

      _computeMediaQuery: function(forceNarrow, responsiveWidth) {
        return forceNarrow ? '' : '(max-width: ' + responsiveWidth + ')';
      },

      _computeSwipeOverlayHidden: function(narrow, disableEdgeSwipe) {
        return !narrow || disableEdgeSwipe;
      },

      _onTrack: function(event) {
        if (sharedPanel && this !== sharedPanel) {
          return;
        }
        switch (event.detail.state) {
          case 'start':
            this._trackStart(event);
            break;
          case 'track':
            this._trackX(event);
            break;
          case 'end':
            this._trackEnd(event);
            break;
        }

      },

      _responsiveChange: function(narrow) {
        this._setNarrow(narrow);

        if (this.narrow) {
          this.selected = this.defaultSelected;
        }

        this.setScrollDirection(this._swipeAllowed() ? 'y' : 'all');
        this.fire('paper-responsive-change', {narrow: this.narrow});
      },

      _onQueryMatchesChanged: function(event) {
        this._responsiveChange(event.detail.value);
      },

      _forceNarrowChanged: function() {
        // set the narrow mode only if we reached the `responsiveWidth`
        this._responsiveChange(this.forceNarrow || this.$.mq.queryMatches);
      },

      _swipeAllowed: function() {
        return this.narrow && !this.disableSwipe;
      },

      _isMainSelected: function() {
        return this.selected === 'main';
      },

      _startEdgePeek: function() {
        this.width = this.$.drawer.offsetWidth;
        this._moveDrawer(this._translateXForDeltaX(this.rightDrawer ?
            -this.edgeSwipeSensitivity : this.edgeSwipeSensitivity));
        this._setPeeking(true);
      },

      _stopEdgePeek: function() {
        if (this.peeking) {
          this._setPeeking(false);
          this._moveDrawer(null);
        }
      },

      _downHandler: function(event) {
        if (!this.dragging && this._isMainSelected() && this._isEdgeTouch(event) && !sharedPanel) {
          this._startEdgePeek();
          // cancel selection
          event.preventDefault();
          // grab this panel
          sharedPanel = this;
        }
      },

      _upHandler: function() {
        this._stopEdgePeek();
        // release the panel
        sharedPanel = null;
      },

      _onTap: function(event) {
        var targetElement = Polymer.dom(event).localTarget;
        var isTargetToggleElement = targetElement &&
          this.drawerToggleAttribute &&
          targetElement.hasAttribute(this.drawerToggleAttribute);

        if (isTargetToggleElement) {
          this.togglePanel();
        }
      },

      _isEdgeTouch: function(event) {
        var x = event.detail.x;

        return !this.disableEdgeSwipe && this._swipeAllowed() &&
          (this.rightDrawer ?
            x >= this.offsetWidth - this.edgeSwipeSensitivity :
            x <= this.edgeSwipeSensitivity);
      },

      _trackStart: function(event) {
        if (this._swipeAllowed()) {
          sharedPanel = this;
          this._setDragging(true);

          if (this._isMainSelected()) {
            this._setDragging(this.peeking || this._isEdgeTouch(event));
          }

          if (this.dragging) {
            this.width = this.$.drawer.offsetWidth;
            this.transition = false;
          }
        }
      },

      _translateXForDeltaX: function(deltaX) {
        var isMain = this._isMainSelected();

        if (this.rightDrawer) {
          return Math.max(0, isMain ? this.width + deltaX : deltaX);
        } else {
          return Math.min(0, isMain ? deltaX - this.width : deltaX);
        }
      },

      _trackX: function(event) {
        if (this.dragging) {
          var dx = event.detail.dx;

          if (this.peeking) {
            if (Math.abs(dx) <= this.edgeSwipeSensitivity) {
              // Ignore trackx until we move past the edge peek.
              return;
            }
            this._setPeeking(false);
          }

          this._moveDrawer(this._translateXForDeltaX(dx));
        }
      },

      _trackEnd: function(event) {
        if (this.dragging) {
          var xDirection = event.detail.dx > 0;

          this._setDragging(false);
          this.transition = true;
          sharedPanel = null;
          this._moveDrawer(null);

          if (this.rightDrawer) {
            this[xDirection ? 'closeDrawer' : 'openDrawer']();
          } else {
            this[xDirection ? 'openDrawer' : 'closeDrawer']();
          }
        }
      },

      _transformForTranslateX: function(translateX) {
        if (translateX === null) {
          return '';
        }

        return this.hasWillChange ? 'translateX(' + translateX + 'px)' :
            'translate3d(' + translateX + 'px, 0, 0)';
      },

      _moveDrawer: function(translateX) {
        this.transform(this._transformForTranslateX(translateX), this.$.drawer);
      }

    });

  }());

</script>
<dom-module id="paper-header-panel" assetpath="bower_components/paper-header-panel/">

  <style>
/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE
The complete set of authors may be found at http://polymer.github.io/AUTHORS
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS
*/

:host {
  --paper-header-panel-shadow: {
    height: 6px;
    bottom: -6px;
    box-shadow: inset 0px 5px 6px -3px rgba(0, 0, 0, 0.4);
  };

  @apply(--layout-vertical);

  position: relative;
  height: 100%;
}

#mainContainer {
  @apply(--layout-flex);

  position: relative;
  overflow-y: auto;
  overflow-x: hidden;
  -webkit-overflow-scrolling: touch;
}

#mainPanel {
  @apply(--layout-vertical);
  @apply(--layout-flex);

  position: relative;
}

/*
 * mode: scroll
 */
:host([mode=scroll]) #mainContainer {
  @apply(--paper-header-panel-scroll-container);

  overflow: visible;
}

:host([mode=scroll]) {
  overflow-y: auto;
  overflow-x: hidden;
  -webkit-overflow-scrolling: touch;
}

/*
 * mode: cover
 */
:host([mode=cover]) #mainContainer {
  @apply(--paper-header-panel-cover-container);

  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}

:host([mode=cover]) #mainPanel {
  position: static;
}

/*
 * mode: standard
 */
:host([mode=standard]) #mainContainer {
  @apply(--paper-header-panel-standard-container);
}

/*
 * mode: seamed
 */
:host([mode=seamed]) #mainContainer {
  @apply(--paper-header-panel-seamed-container);
}


/*
 * mode: waterfall
 */
:host([mode=waterfall]) #mainContainer {
  @apply(--paper-header-panel-waterfall-container);
}

/*
 * mode: waterfall-tall
 */
:host([mode=waterfall-tall]) #mainContainer {
  @apply(--paper-header-panel-waterfall-tall-container);
}

#dropShadow {
  @apply(--paper-header-panel-shadow);

  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 6px;
  pointer-events: none;

  -webkit-transition: opacity 0.5s;
  transition: opacity 0.5s;

  opacity: 0;
}

#dropShadow.has-shadow {
  opacity: 1;
}

</style>

  <template>
    <content id="headerContent" select="paper-toolbar, .paper-header"></content>

    <div id="mainPanel">
      <div id="mainContainer" class$="[[_computeMainContainerClass(mode)]]">
        <content id="mainContent" select="*"></content>
      </div>
      <div id="dropShadow"></div>
    </div>
  </template>

</dom-module>

<script>

  (function() {

    'use strict';

    var SHADOW_WHEN_SCROLLING = 1;
    var SHADOW_ALWAYS = 2;


    var MODE_CONFIGS = {

      outerScroll: {
        'scroll': true
      },

      shadowMode: {
        'standard': SHADOW_ALWAYS,
        'waterfall': SHADOW_WHEN_SCROLLING,
        'waterfall-tall': SHADOW_WHEN_SCROLLING
      },

      tallMode: {
        'waterfall-tall': true
      }
    };

    Polymer({

      is: 'paper-header-panel',

      /**
       * Fired when the content has been scrolled.  `event.detail.target` returns
       * the scrollable element which you can use to access scroll info such as
       * `scrollTop`.
       *
       *     <paper-header-panel on-content-scroll="scrollHandler">
       *       ...
       *     </paper-header-panel>
       *
       *
       *     scrollHandler: function(event) {
       *       var scroller = event.detail.target;
       *       console.log(scroller.scrollTop);
       *     }
       *
       * @event content-scroll
       */

      properties: {

        /**
         * Controls header and scrolling behavior. Options are
         * `standard`, `seamed`, `waterfall`, `waterfall-tall`, `scroll` and
         * `cover`. Default is `standard`.
         *
         * `standard`: The header is a step above the panel. The header will consume the
         * panel at the point of entry, preventing it from passing through to the
         * opposite side.
         *
         * `seamed`: The header is presented as seamed with the panel.
         *
         * `waterfall`: Similar to standard mode, but header is initially presented as
         * seamed with panel, but then separates to form the step.
         *
         * `waterfall-tall`: The header is initially taller (`tall` class is added to
         * the header).  As the user scrolls, the header separates (forming an edge)
         * while condensing (`tall` class is removed from the header).
         *
         * `scroll`: The header keeps its seam with the panel, and is pushed off screen.
         *
         * `cover`: The panel covers the whole `paper-header-panel` including the
         * header. This allows user to style the panel in such a way that the panel is
         * partially covering the header.
         *
         *     <paper-header-panel mode="cover">
         *       <paper-toolbar class="tall">
         *         <core-icon-button icon="menu"></core-icon-button>
         *       </paper-toolbar>
         *       <div class="content"></div>
         *     </paper-header-panel>
         */
        mode: {
          type: String,
          value: 'standard',
          observer: '_modeChanged',
          reflectToAttribute: true
        },

        /**
         * If true, the drop-shadow is always shown no matter what mode is set to.
         */
        shadow: {
          type: Boolean,
          value: false
        },

        /**
         * The class used in waterfall-tall mode.  Change this if the header
         * accepts a different class for toggling height, e.g. "medium-tall"
         */
        tallClass: {
          type: String,
          value: 'tall'
        },

        /**
         * If true, the scroller is at the top
         */
        atTop: {
          type: Boolean,
          value: true,
          readOnly: true
        }
      },

      observers: [
        '_computeDropShadowHidden(atTop, mode, shadow)'
      ],

      ready: function() {
        this.scrollHandler = this._scroll.bind(this);
        this._addListener();

        // Run `scroll` logic once to initialze class names, etc.
        this._keepScrollingState();
      },

      detached: function() {
        this._removeListener();
      },

      /**
       * Returns the header element
       *
       * @property header
       * @type Object
       */
      get header() {
        return Polymer.dom(this.$.headerContent).getDistributedNodes()[0];
      },

      /**
       * Returns the scrollable element.
       *
       * @property scroller
       * @type Object
       */
      get scroller() {
        return this._getScrollerForMode(this.mode);
      },

      /**
       * Returns true if the scroller has a visible shadow.
       *
       * @property visibleShadow
       * @type Boolean
       */
      get visibleShadow() {
        return this.$.dropShadow.classList.contains('has-shadow');
      },

      _computeDropShadowHidden: function(atTop, mode, shadow) {

        var shadowMode = MODE_CONFIGS.shadowMode[mode];

        if (this.shadow) {
          this.toggleClass('has-shadow', true, this.$.dropShadow);

        } else if (shadowMode === SHADOW_ALWAYS) {
          this.toggleClass('has-shadow', true, this.$.dropShadow);

        } else if (shadowMode === SHADOW_WHEN_SCROLLING && !atTop) {
          this.toggleClass('has-shadow', true, this.$.dropShadow);

        } else {
          this.toggleClass('has-shadow', false, this.$.dropShadow);

        }
      },

      _computeMainContainerClass: function(mode) {
        // TODO:  It will be useful to have a utility for classes
        // e.g. Polymer.Utils.classes({ foo: true });

        var classes = {};

        classes['flex'] = mode !== 'cover';

        return Object.keys(classes).filter(
          function(className) {
            return classes[className];
          }).join(' ');
      },

      _addListener: function() {
        this.scroller.addEventListener('scroll', this.scrollHandler, false);
      },

      _removeListener: function() {
        this.scroller.removeEventListener('scroll', this.scrollHandler);
      },

      _modeChanged: function(newMode, oldMode) {
        var configs = MODE_CONFIGS;
        var header = this.header;
        var animateDuration = 200;

        if (header) {
          // in tallMode it may add tallClass to the header; so do the cleanup
          // when mode is changed from tallMode to not tallMode
          if (configs.tallMode[oldMode] && !configs.tallMode[newMode]) {
            header.classList.remove(this.tallClass);
            this.async(function() {
              header.classList.remove('animate');
            }, animateDuration);
          } else {
            header.classList.toggle('animate', configs.tallMode[newMode]);
          }
        }
        this._keepScrollingState();
      },

      _keepScrollingState: function() {
        var main = this.scroller;
        var header = this.header;

        this._setAtTop(main.scrollTop === 0);

        if (header && this.tallClass && MODE_CONFIGS.tallMode[this.mode]) {
          this.toggleClass(this.tallClass, this.atTop ||
              header.classList.contains(this.tallClass) &&
              main.scrollHeight < this.offsetHeight, header);
        }
      },

      _scroll: function() {
        this._keepScrollingState();
        this.fire('content-scroll', {target: this.scroller}, {bubbles: false});
      },

      _getScrollerForMode: function(mode) {
        return MODE_CONFIGS.outerScroll[mode] ?
            this : this.$.mainContainer;
      }

    });

  })();

</script>
<dom-module id="paper-toolbar" assetpath="bower_components/paper-toolbar/">

  <style>
    :host {
      /* technical */
      display: block;
      position: relative;
      box-sizing: border-box;
      -moz-box-sizing: border-box;

      /* size */
      height: 64px;

      background: var(--paper-toolbar-background, --default-primary-color);
      color: var(--paper-toolbar-color, --text-primary-color);

      @apply(--paper-toolbar);
    }

    :host(.animate) {
      /* transition */
      transition: height 0.18s ease-in;
    }

    :host(.medium-tall) {
      height: 128px;
    }

    :host(.tall) {
      height: 192px;
    }

    .toolbar-tools {
      position: relative;
      height: 64px;
      padding: 0 16px;
      pointer-events: none;
    }

    /*
     * TODO: Where should media query breakpoints live so they can be shared between elements?
     */

    @media (max-width: 639px) {
      :host {
        height: 56px;
      }

      :host(.medium-tall) {
        height: 112px;
      }

      :host(.tall) {
        height: 168px;
      }

      .toolbar-tools {
        height: 56px;
      }
    }

    #topBar {
      position: relative;
    }

    /* middle bar */
    #middleBar {
      position: absolute;
      top: 0;
      right: 0;
      left: 0;
    }

    :host(.tall) #middleBar,
    :host(.medium-tall) #middleBar {
      -webkit-transform: translateY(100%);
      transform: translateY(100%);
    }

    /* bottom bar */
    #bottomBar {
      position: absolute;
      right: 0;
      bottom: 0;
      left: 0;
    }

    /*
     * make elements (e.g. buttons) respond to mouse/touch events
     *
     * `.toolbar-tools` disables touch events so multiple toolbars can stack and not
     * absorb events. All children must have pointer events re-enabled to work as
     * expected.
     */
    .toolbar-tools > ::content > *:not([disabled]) {
      pointer-events: auto;
    }

    .toolbar-tools > ::content .title {
      @apply(--paper-font-title);
      @apply(--layout-flex);

      pointer-events: none;
      text-overflow: ellipsis;
      white-space: nowrap;
      overflow: hidden;

      /*
       * Polymer/polymer/issues/1525
       * --paper-font-title defines a `font-weight`
       * let's override its value, but we need `important!`
       * because all mixins are resolved in rule's selector that has higher precedence
       * than the current selector.
       */
      font-weight: 400 !important;
    }

    /**
     * TODO: Refactor these selectors
     * Work in progress.
     */
    .toolbar-tools > ::content paper-icon-button[icon=menu] {
      margin-right: 24px;
    }

    .toolbar-tools > ::content > .title,
    .toolbar-tools > ::content[select=".middle"] > .title,
    .toolbar-tools > ::content[select=".bottom"] > .title {
      margin-left: 56px;
    }

    .toolbar-tools > ::content > paper-icon-button + .title,
    .toolbar-tools > ::content[select=".middle"] paper-icon-button + .title,
    .toolbar-tools > ::content[select=".bottom"] paper-icon-button + .title {
      margin-left: 0;
    }

    .toolbar-tools > ::content > .fit {
      position: absolute;
      top: auto;
      right: 0;
      bottom: 0;
      left: 0;
      width: auto;
      margin: 0;
    }

  </style>

  <template>

    <div id="topBar" class$="[[_computeBarClassName(justify)]]">
      <content select=":not(.middle):not(.bottom)"></content>
    </div>

    <div id="middleBar" class$="[[_computeBarClassName(middleJustify)]]">
      <content select=".middle"></content>
    </div>

    <div id="bottomBar" class$="[[_computeBarClassName(bottomJustify)]]">
      <content select=".bottom"></content>
    </div>

  </template>

</dom-module>

<script>

  (function() {

    'use strict';

    function classNames(obj) {
      var classNames = [];
      for (var key in obj) {
        if (obj.hasOwnProperty(key) && obj[key]) {
          classNames.push(key);
        }
      }

      return classNames.join(' ');
    }

    Polymer({

      is: 'paper-toolbar',

      hostAttributes: {
        'role': 'toolbar'
      },

      properties: {

        /**
         * Controls how the items are aligned horizontally when they are placed
         * at the bottom.
         * Options are `start`, `center`, `end`, `justified` and `around`.
         *
         * @attribute bottomJustify
         * @type string
         * @default ''
         */
        bottomJustify: {
          type: String,
          value: ''
        },

        /**
         * Controls how the items are aligned horizontally.
         * Options are `start`, `center`, `end`, `justified` and `around`.
         *
         * @attribute justify
         * @type string
         * @default ''
         */
        justify: {
          type: String,
          value: ''
        },

        /**
         * Controls how the items are aligned horizontally when they are placed
         * in the middle.
         * Options are `start`, `center`, `end`, `justified` and `around`.
         *
         * @attribute middleJustify
         * @type string
         * @default ''
         */
        middleJustify: {
          type: String,
          value: ''
        }

      },

      attached: function() {
        this._observer = this._observe(this);
        this._updateAriaLabelledBy();
      },

      detached: function() {
        if (this._observer) {
          this._observer.disconnect();
        }
      },

      _observe: function(node) {
        var observer = new MutationObserver(function() {
          this._updateAriaLabelledBy();
        }.bind(this));
        observer.observe(node, {
          childList: true,
          subtree: true
        });
        return observer;
      },

      _updateAriaLabelledBy: function() {
        var labelledBy = [];
        var contents = Polymer.dom(this.root).querySelectorAll('content');
        for (var content, index = 0; content = contents[index]; index++) {
          var nodes = Polymer.dom(content).getDistributedNodes();
          for (var node, jndex = 0; node = nodes[jndex]; jndex++) {
            if (node.classList && node.classList.contains('title')) {
              if (node.id) {
                labelledBy.push(node.id);
              } else {
                var id = 'paper-toolbar-label-' + Math.floor(Math.random() * 10000);
                node.id = id;
                labelledBy.push(id);
              }
            }
          }
        }
        if (labelledBy.length > 0) {
          this.setAttribute('aria-labelledby', labelledBy.join(' '));
        }
      },

      _computeBarClassName: function(barJustify) {
        var classObj = {
          'center': true,
          'horizontal': true,
          'layout': true,
          'toolbar-tools': true
        };

        // If a blank string or any falsy value is given, no other class name is
        // added.
        if (barJustify) {
          var justifyClassName = (barJustify === 'justified') ?
              barJustify :
              barJustify + '-justified';

          classObj[justifyClassName] = true;
        }

        return classNames(classObj);
      }

    });

  }());

</script>
<dom-module id="iron-a11y-announcer" assetpath="bower_components/iron-a11y-announcer/">
  <style>
    :host {
      display: inline-block;
      position: fixed;
      clip: rect(0px,0px,0px,0px);
    }
  </style>

  <template>
    <div aria-live$="[[mode]]">[[_text]]</div>
  </template>

  <script>

    (function() {
      'use strict';

      Polymer.IronA11yAnnouncer = Polymer({
        is: 'iron-a11y-announcer',

        properties: {

          /**
           * The value of mode is used to set the `aria-live` attribute
           * for the element that will be announced. Valid values are: `off`,
           * `polite` and `assertive`.
           */
          mode: {
            type: String,
            value: 'polite'
          },

          _text: {
            type: String,
            value: ''
          }
        },

        created: function() {
          if (!Polymer.IronA11yAnnouncer.instance) {
            Polymer.IronA11yAnnouncer.instance = this;
          }

          document.body.addEventListener('iron-announce', this._onIronAnnounce.bind(this));
        },

        /**
         * Cause a text string to be announced by screen readers.
         *
         * @param {string} text The text that should be announced.
         */
        announce: function(text) {
          this._text = '';
          this.async(function() {
            this._text = text;
          }, 100);
        },

        _onIronAnnounce: function(event) {
          if (event.detail && event.detail.text) {
            this.announce(event.detail.text);
          }
        }
      });

      Polymer.IronA11yAnnouncer.instance = null;

      Polymer.IronA11yAnnouncer.requestAvailability = function() {
        if (!Polymer.IronA11yAnnouncer.instance) {
          Polymer.IronA11yAnnouncer.instance = document.createElement('iron-a11y-announcer');
        }

        document.body.appendChild(Polymer.IronA11yAnnouncer.instance);
      };
    })();

  </script>
</dom-module>
<dom-module id="paper-toast" assetpath="bower_components/paper-toast/">
  <style>
    :host {
      display: inline-block;
      position: fixed;

      background: #323232;
      color: #f1f1f1;
      min-height: 48px;
      min-width: 288px;
      padding: 16px 24px 12px;
      box-sizing: border-box;
      box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);
      border-radius: 2px;
      bottom: 12px;
      left: 12px;
      font-size: 14px;
      cursor: default;

      -webkit-transition: visibility 0.3s, -webkit-transform 0.3s;
      transition: visibility 0.3s, transform 0.3s;

      -webkit-transform: translateY(100px);
      transform: translateY(100px);

      visibility: hidden;
    }

    :host(.capsule) {
      border-radius: 24px;
    }

    :host(.fit-bottom) {
      bottom: 0;
      left: 0;
      width: 100%;
      min-width: 0;
      border-radius: 0;
    }

    :host(.paper-toast-open){
      visibility: visible;

      -webkit-transform: translateY(0px);
      transform: translateY(0px);
    }
  </style>
  <template>
    <span id="label">{{text}}</span>
    <content></content>
  </template>
</dom-module>
<script>
(function() {

  var PaperToast = Polymer({
    is: 'paper-toast',

    properties: {
      /**
       * The duration in milliseconds to show the toast.
       */
      duration: {
        type: Number,
        value: 3000
      },

      /**
       * The text to display in the toast.
       */
      text: {
        type: String,
        value: ""
      },

      /**
       * True if the toast is currently visible.
       */
      visible: {
        type: Boolean,
        readOnly: true,
        value: false,
        observer: '_visibleChanged'
      }
    },

    created: function() {
      Polymer.IronA11yAnnouncer.requestAvailability();
    },

    ready: function() {
      this.async(function() {
        this.hide();
      });
    },

    /**
     * Show the toast.
     * @method show
     */
    show: function() {
      if (PaperToast.currentToast) {
        PaperToast.currentToast.hide();
      }
      PaperToast.currentToast = this;
      this.removeAttribute('aria-hidden');
      this._setVisible(true);
      this.fire('iron-announce', {
        text: this.text
      });
      this.debounce('hide', this.hide, this.duration);
    },

    /**
     * Hide the toast
     */
    hide: function() {
      this.setAttribute('aria-hidden', 'true');
      this._setVisible(false);
    },

    /**
     * Toggle the opened state of the toast.
     * @method toggle
     */
    toggle: function() {
      if (!this.visible) {
        this.show();
      } else {
        this.hide();
      }
    },

    _visibleChanged: function(visible) {
      this.toggleClass('paper-toast-open', visible);
    }
  });

  PaperToast.currentToast = null;

})();
</script>
<dom-module id="cwn-info-link" assetpath="elements/widgets/">
    <style>
        span.invalid {
            color: #888;
            font-style: italic;
            vertical-align:super;
        }
        a {
            vertical-align: top;
        }
        :host {
            white-space: nowrap;
            display: inline-block;
        }
    </style>
    <template>
        <span hidden$="{{!valid}}">
            <cwn-app-icon type$="{{type}}" width="22" height="22" fillfromtype="true"></cwn-app-icon>
            <a href="{{link}}">{{prmname}}</a> <span style="vertical-align:top; color: #ccc">{{type}}</span>
        </span>

        <span hidden$="{{!region}}">
            <span>{{label}}</span> <span style="vertical-align:top; color: #ccc">{{type}}</span>
        </span>

        <span hidden$="{{!unknown}}">{{prmname}}</span>
    </template>
</dom-module>


<script>
    Polymer({
        is : 'cwn-info-link',

        properties : {
            prmname : {
              type : String,
              observer : 'update'
            }
        },

        ready : function() {
          this.prmname = '';
          this.link = '';
          this.type = '';
          this.label = '';
          this.reset();
        },

        reset : function() {
          this.valid = false;
          this.unknown = false;
          this.region = false;
        },

        attached : function() {
          if( !this.prmname && this.getAttribute('prmname') ) {
            this.prmname = this.getAttribute('prmname');
          }

          if( CWN.ds.loading ) CWN.ds.on('load', this.update.bind(this));
          else this.update();
        },

        update : function() {
          if( CWN.ds.loading ) return;
          this.reset();

          if( CWN.ds.regionLookupMap[this.prmname] ) {
            this.region = true;
            this.type = 'Region';
            this.label = CWN.ds.regionLookupMap[this.prmname].geo.properties.name;
            return;
          }

          if( !CWN.ds.lookupMap[this.prmname] ) {
              this.unknown = true;
              return;
          }

          this.valid = true;

          this.type = CWN.ds.lookupMap[this.prmname].properties.type;
          this.link = '#info/'+ this.prmname;
        }

    });
</script>
<dom-module id="cwn-dateslider" assetpath="elements/widgets/">
    <style>
        :host {
            display: block;
            position : fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: white;
            border-top: 1px solid #ccc;
            box-shadow: 0 0 5px #888;
        }
        .slider-tabs {
            /*margin-right: 100px;*/
            margin: 20px 30px 0 30px;
            position: relative;

            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -o-user-select: none;
            user-select: none;
        }
        .slider-tab {
            position: absolute;
            top: -15px;
            left: 0;
            z-index: 4;


            transform: translateX(-15px);
            -ms-transform: translateX(-15px);
            -webkit-transform: translateX(-15px);
            -moz-transform: translateX(-15px);

            transition: none;
            -webkit-transition: none;
            -moz-transition: none;
            -ms-transition: none;

            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -o-user-select: none;
            user-select: none;
        }
        .line {
            border-left: 1px dashed #428bca;
            width: 1px;
            z-index: 5;
            position: absolute;
        }
        .progress {
            position: relative !important;
            /*margin-right: 100px;*/
            margin-top: 15px;
        }
        .progress-bar {
            position: absolute !important;
            float: none !important;
            width: auto !important;
        }
    </style>

    <template>
        <div class="slider-tabs">
            <div id="startTab" class="slider-tab btn btn-default">&nbsp;</div>
            <div id="endTab" class="slider-tab btn btn-default">&nbsp;</div>
            <div class="progress">
              <div class="progress-bar" id="slider" style="left:0;right:0"></div>
            </div>
            <div class="layout horizontal center">
              <span id="startTabDate"></span>
              <div style="text-align:center; font-weight:bold" class="flex">Date Range</div>
              <span id="endTabDate"></span>
            </div>
        </div>

    </template>
</dom-module>

<script>
    Polymer({
        is : 'cwn-dateslider',

        properties : {
            start : {
                type : String
            },
            end : {
                type : String
            }
        },

        listeners: {
            mousedown : 'startDrag',
            touchstart : 'startDrag',
            mousemove : 'onDrag',
            touchmove : 'onDrag'
        },


        ready : function() {
          this.numDays = 0;

          this.startDate = new Date();
          this.endDate = new Date();

          this.current = {
              start : new Date(),
              end : new Date()
          };

          this.dragging = null;
          this.dragStartX = 0;
          this.dragStartLeft = 0;
          this.otherStartLeft = 0;

          this.cWidth = 0;
          this.cBarWidth = 0;

            this.reset();

            $(window)
                .on('resize', this.resize.bind(this))
                .on('mouseup touchend touchcancel', this.endDrag.bind(this));

            setTimeout(function(){
                this.resize();
            }.bind(this),500);
        },

        reset : function() {
            this.startDate = this.start ? new Date(this.start) : new Date();
            this.stopDate = this.stop ? new Date(this.stop) : new Date();

            this.numDays = (this.stopDate - this.startDate)/(1000*60*60*24);

            this.current.start = this.startDate;
            this.current.end = this.endDate;
        },

        domReady : function() {
            setTimeout(function(){
                this.resize();
            }.bind(this),1000);
        },

        resize : function() {
            if( this.numDays == 0 ) return;

            this.cWidth = this.querySelector('.slider-tabs').offsetWidth;

            var days = (this.current.start - this.startDate)/(1000*60*60*24);
            var leftPos = this.cWidth * (days / this.numDays);

            days = (this.current.end - this.startDate)/(1000*60*60*24);
            var rightPos = this.cWidth * (days / this.numDays);

            this.setLeftPos(leftPos);
            this.setRightPos(rightPos);

            this.$.startTabDate.innerHTML = this.current.start.toISOString().split('T')[0];
            this.$.endTabDate.innerHTML = this.current.end.toISOString().split('T')[0];
        },

        startDrag : function(e) {
            if( this.dragging ) return;

            if( !e.target.classList.contains('slider-tab') && e.target.id != 'slider' ) {
                return;
            }

            this.cWidth = this.querySelector('.slider-tabs').offsetWidth;
            this.cBarWidth = this.$.slider.offsetWidth;

            this.dragging = e.target;
            this.dragStartLeft = parseInt(e.target.style.left || 0);
            this.dragStartX = this.getX(e);

            if( this.dragging.getAttribute('id') == 'startTab' ) {
                this.otherStartLeft = parseInt(this.$.endTab.style.left || 0 );
            } else if( this.dragging.getAttribute('id') == 'endTab' ) {
                this.otherStartLeft = parseInt(this.$.startTab.style.left || 0 );
            }
            //console.log('Drag start: '+this.dragging.id);
        },

        onDrag : function(e) {
            if( this.dragging == null ) return;
            if( this.dragging.getAttribute('id') == 'slider' ) return this.onSliderDrag(e);

            var pos = this.getPosition(e);

            var cDay = Math.floor(this.numDays * (pos / this.cWidth));
            var result = new Date(this.startDate);
            result.setDate(this.startDate.getDate() + cDay);

            this.$[this.dragging.getAttribute('id')+'Date'].innerHTML = result.toISOString().split('T')[0];

            if( this.dragging.getAttribute('id')== 'startTab' ) {
                this.setLeftPos(pos);
            } else if( this.dragging.getAttribute('id') == 'endTab' ) {
                this.setRightPos(pos);
            }
        },

        onSliderDrag : function(e) {
            var frontPos = this.getPosition(e);
            var backPos = this.cBarWidth + frontPos;

            if( backPos > this.cWidth ) return;

            //this.dragging.style.left = frontPos + 'px';
            //this.dragging.style.right = this.cWidth - backPos + 'px';

            this.setLeftPos(frontPos);
            this.setRightPos(backPos);

            //this.$.startTab.style.left = frontPos+'px';
            var cDay = Math.floor(this.numDays * (frontPos / this.cWidth));
            var result = new Date(this.startDate);
            result.setDate(this.startDate.getDate() + cDay);
            this.$.startTabDate.innerHTML = result.toISOString().split('T')[0];
            this.current.start = result;

            //this.$.endTab.style.left = backPos+'px';
            cDay = Math.floor(this.numDays * (backPos / this.cWidth));
            result = new Date(this.startDate);
            result.setDate(this.startDate.getDate() + cDay);
            this.$.endTabDate.innerHTML = result.toISOString().split('T')[0];
            this.current.end = result;
        },

        endDrag : function() {
            if( this.dragging == null ) return;

            //console.log('Drag end: '+this.dragging.id);

            var parentX = $(this).offset().left;
            var pos = $(this.$[this.dragging.getAttribute('id')]).offset().left - parentX;

            var cDay = Math.floor(this.numDays * (pos / this.cWidth));

            var result = new Date(this.startDate);
            result.setDate(this.startDate.getDate() + cDay);

            if( this.dragging.getAttribute('id') == 'startTab' ) this.current.start = result;
            else if( this.dragging.getAttribute('id') == 'endTab' ) this.current.end = result;

            if( this.dragging.getAttribute('id') != 'slider' ) {
                this.$[this.dragging.getAttribute('id')+'Date'].innerHTML = result.toISOString().split('T')[0];
            }

            this.dragging = null;

            this.fire('values-changed', this.current);
        },

        setLeftPos : function(pos) {
            this.$.startTab.style.left = pos + 'px';
            this.$.slider.style.left = pos + 'px';
        },

        setRightPos : function(pos) {
            this.$.endTab.style.left = pos + 'px';

            pos = this.cWidth - pos;
            this.$.slider.style.right = pos + 'px';
        },

        getPosition : function(e) {
            var pos = this.dragStartLeft + (this.getX(e) - this.dragStartX);


            if( pos < 0 ) pos = 0;
            if( pos > this.cWidth ) pos = this.cWidth;

            if( this.dragging.getAttribute('id') == 'startTab' && pos > this.otherStartLeft ) {
                pos = this.otherStartLeft;
            } else if( this.dragging.getAttribute('id') == 'endTab' && pos < this.otherStartLeft ) {
                pos = this.otherStartLeft;
            }

            return pos;
        },

        // keep track of last touch for trouch end
        lastTouchX : 0,
        getX : function(e) {
            if( e.x !== undefined ) return e.x;
            if( e.touches !== undefined ) {
                if( e.touches.length > 0 ) {
                    this.lastTouchX = e.touches[0].screenX;
                    return e.touches[0].screenX;
                } else {
                    // touchend... I hope
                    return this.lastTouchX;
                }
            }
            if( e.clientX !== undefined ) return e.clientX;
            return 0; // bad
        },

        setFeature : function(feature) {
          if( feature ) this.feature = feature;
          if( !this.feature ) return;

          this._updateVisibility();
        },

        _updateVisibility : function() {
          var respCount = 0;
          var requestCount = 1;
          var hasTimeBounds = false;
          var hasRegionLinkData = false;
          var hasRegionFlowData = false;
          var hasRegionInflowData = false;

          function onResponse() {
            respCount++;
            if( respCount != requestCount ) return;

            var show = false;
            var extras = this.feature.properties.extras;
            if( (extras && (extras.evaporation || extras.inflows || extras.flow)) || hasTimeBounds || hasRegionLinkData || hasRegionFlowData || hasRegionInflowData ) {
              show = true;
            }

            this.style.display = show ? 'block' : 'none';
            if( show ) this.resize();
          }

          // how many requests are we making?
          if( this.feature.properties.type == 'Region Link' ) requestCount++;
          if( this.feature.properties.type == 'Region' ) requestCount += 2;
          if( this.feature.properties.extras && this.feature.properties.extras.bounds ) requestCount++;

          // grab the aggregate region link data
          if( this.feature.properties.type == 'Region Link' ) {
            //CWN.ds.loadAggregate('flow', this.feature.properties.origin, this.feature.properties.terminus, function(resp){
            //  if( Object.keys(resp.origin.flow).length > 0 ) hasRegionLinkData = true;
            //  else if( Object.keys(resp.terminus.flow).length > 0 ) hasRegionLinkData = true;
            hasRegionLinkData = true;
            onResponse.call(this);
            //}.bind(this));
          }

          // grab the aggregate flow data
          if( this.feature.properties.type == 'Region' ) {
            /*CWN.ds.loadAggregate('flow', this.feature.properties.prmname, function(resp){
              if( Object.keys(resp.origins.flow).length > 0 ) hasRegionFlowData = true;
              else if( Object.keys(resp.terminals.flow).length > 0 ) hasRegionFlowData = true;
              onResponse.call(this);
            }.bind(this));

            CWN.ds.loadAggregate('inflows', this.feature.properties.prmname, function(resp){
              if( Object.keys(resp.inflows).length > 0 ) hasRegionInflowData = true;
              onResponse.call(this);
            }.bind(this));*/

            hasRegionInflowData = true;
            onResponse.call(this);
          }

          // grab the bounds data
          if( this.feature.properties.extras && this.feature.properties.extras.bounds ) {
            CWN.ds.loadExtras(this.feature.properties.prmname, function(resp){
              if( !resp.bounds ) return;

              for( var i = 0; i < resp.bounds.length; i++ ) {
                if( resp.bounds[i].type == 'UBT' || resp.bounds[i].type == 'LBT' ||
                    resp.bounds[i].type == 'EQC' || resp.bounds[i].type == 'EQT') {
                  hasTimeBounds = true;
                  break;
                }
              }

              onResponse.call(this);
            }.bind(this));
          }

          // first check
          onResponse.call(this);
        }
    });
</script>
<dom-module id="cwn-app-icon" assetpath="elements/widgets/">
    <style>
        :host {
            display: inline-block;
        }
    </style>

    <template>
        <canvas id="canvas"></canvas>
        <i id="icon" class="fa fa-long-arrow-right" style="vertical-align:super"></i>
        <i id="regionLinkIcon" class="fa fa-exchange"></i>
        <span id="regionIcon"><i id="regionIconSub" style="vertical-align:bottom">i</i></span>
    </template>
</dom-module>


<script>
    Polymer({
        is: 'cwn-app-icon',

        properties : {
            type : {
                reflect : true,
                type : String,
                observer : 'onTypeChange'
            },
            width : {
                type: String,
                observer : 'redraw'
            },
            height : {
                type: String,
                observer : 'redraw'
            },
            fillStyle : String,
            fillFromType : Boolean,
            fontSize : {
                type : String,
                observer : 'onFontSizeChange'
            }
        },

        ready : function() {
          this.fillStyle = '#fffff';
          this.fillFromType = false;
          this.fontSize = 14;

          this.styles = {
            'Power Plant' : '#3366cc',
            'Agricultural Demand' : '#ff9900',
            'Junction' : '#109618',
            'Pump Plant' : '#990099',
            'Water Treatment' : '#0099c6',
            'Surface Storage' : '#dd4477',
            'Urban Demand' : '#66aa00',
            'Sink' : '#b82e2e',
            'Groundwater Storage' : '#316395',
            'Non-Standard Demand' : '#22aa99'
          };
        },

        attached : function() {
            this.redraw();
        },

        onFontSizeChange : function() {
            if( !this.$.icon ) return;

            this.$.icon.style.fontSize = this.fontSize+'px';
            this.$.regionLinkIcon.style.fontSize = this.fontSize+'px';
            this.$.regionIcon.style.fontSize = this.fontSize+'px';
            this.$.regionIconSub.style.fontSize = Math.ceil(this.fontSize*.6)+'px';
        },

        onTypeChange : function() {
          $(this.$.canvas).hide();
          $(this.$.regionLinkIcon).hide();
          $(this.$.regionIcon).hide();
          $(this.$.icon).hide();

          if( this.type == 'Diversion' || this.type == 'Return Flow' ) {
            $(this.$.icon).show();
          } else if( this.type == 'Region Link' ) {
            $(this.$.regionLinkIcon).show();
          } else if( this.type == 'Region' ) {
            $(this.$.regionIcon).show();
          } else {
            $(this.$.canvas).show();
            this.redraw();
          }
        },

        redraw : function() {
            if( !this.$.canvas ) return;
            if( this.height === undefined || this.width == undefined ) return;

            this.fontSize = this.width-15;
            if( this.fontSize < 14 ) this.fontSize = 14;

            if( !CWN.render[this.type] ) return;

            this.$.canvas.setAttribute('height', this.height);
            this.$.canvas.setAttribute('width', this.width);

            var ctx = this.$.canvas.getContext('2d');
            ctx.clearRect(0, 0, this.width, this.height);

            CWN.render[this.type](ctx, {
                x: 2,
                y: 2,
                width: this.width-4,
                height: this.height-4
            });
        }
    });
</script>
<dom-module id="cwn-date-linechart" assetpath="elements/widgets/">
    <style>
        :host {
            display: block;
        }

    </style>
    <template>
        <div id="root" style="height:400px"></div>
    </template>
</dom-module>

<script>
    Polymer({
        is : 'cwn-date-linechart',
/*
        properties : {
            label : String,
            xlabel : String,
            ylabel : String,
            data : Object,
            height : {
                type : Number,
                observer : 'setHeight'
            },
            options : Object,
            cols: Object,
            startDate : Date,
            stopDate : Date,
            type: String,
            animate : {
              type: Boolean,
              notify : true
            }
        },
*/
        ready : function() {

            this.options = null;
            this.type = '';
            this.ctype = '';
            this.cols = null;
            this.dt = null;
            this.chart = null;
            this.height = 400;
            this.data = [];
            this.startDate = null;
            this.stopDate = null;
            this.animate = false;
            this.onClick = null;

            this.updateTimer = -1;

            this.onLoadHandlerSet = false;
        },

        attached : function() {
            $(window).on('resize', function(){
              if( this.isPaper ) return;
              this.redraw();
            }.bind(this));

            setTimeout(function(){
                // see if we have initial state
                var slider = document.querySelector('cwn-dateslider');
                if( slider && slider.current) {
                    this.startDate = slider.current.start;
                    this.stopDate = slider.current.end;
                }

                this.update();
            }.bind(this), 50);
        },

        onStop : function() {
            this.update();
        },

        setHeight : function(height) {
            if( height ) this.height = height;

            this.$.root.style.height = this.height+'px';
            this.redraw();
        },

        setOnloadHandler : function() {
            if( this.onLoadHandlerSet ) return;

            // put in global scope by cwn-datastore
            CWN.chartLoadHandlers.push(function(){
                this.update();
            }.bind(this));
        },

        update : function(data) {
            if( data ) this.data = data;

            if( !window.google.visualization ) return this.setOnloadHandler();
            if( !window.google.visualization.LineChart ) return this.setOnloadHandler();
            if( !this.$ ) return;

            if( !this.chart || this.type != this.ctype ) {
                this.$.root.innerHTML = '';
                if( this.type ) {
                    this.chart = new google.visualization[this.type](this.$.root);
                } else {
                    this.chart = new google.visualization.LineChart(this.$.root);
                }
                if( this.onClick ) {
                  google.visualization.events.addListener(this.chart, 'select', function(e){
                    var row = this.chart.getSelection()[0].row+1;
                    this.onClick(this.filteredData[row]);
                  }.bind(this));
                }
                this.ctype = this.type;
            }

            if( !this.cols ) {
                if( !this.data ) this.data = ['date', 'value'];
                else if( this.data.length == 0 ) this.data = ['date', 'value'];

                try {
                    if( typeof this.data[0][1] != 'string' ) this.data.splice(0, 0, ['date', 'value']);
                } catch(e) {
                    debugger;
                }
            }


            if( this.updateTimer == -1 ) clearTimeout(this.updateTimer);
            this.updateTimer = setTimeout(function() {
                this.updateTimer = -1;
                this._update();
            }.bind(this), 500);
        },

        _setDataTable : function(data) {
          this.filteredData = data;
          try {
            if( this.cols ) {
                this.dt = new google.visualization.DataTable();
                for( var i = 0; i < this.cols.length; i++ ) {
                    this.dt.addColumn(this.cols[i]);
                }
                this.dt.addRows(data);
            } else {
                this.dt = google.visualization.arrayToDataTable(data);
            }
          } catch(e) {
            return false;
          }
          return true;
        },

        _update : function() {
            if( !this.startDate && !this.stopDate ) {
                this._setDataTable(this.data);
                this.redraw();
                return;
            }

            var filteredData;
            if( !this.cols ) {
                filteredData = [this.data[0]];
            } else {
                filteredData = [];
            }
            var d;
            for( var i = 1; i < this.data.length; i++ ) {
                d = new Date(this.data[i][0]).getTime();

                if( this.startDate && this.stopDate ) {
                    if( d >= this.startDate.getTime() && d <= this.stopDate.getTime() ) {
                        filteredData.push(this.data[i]);
                    }
                } else if ( this.startDate ) {
                    if( d >= this.startDate.getTime() ) {
                        filteredData.push(this.data[i]);
                    }
                } else {
                    if( d <= this.stopDate.getTime()  ) {
                        filteredData.push(this.data[i]);
                    }
                }
            }

            var success = this._setDataTable(filteredData);
            if( success ) this.redraw();
        },

        redraw : function() {
            if( !this.chart || !this.dt ) return;

            var options = {
                legend : {
                    position : 'none'
                }
            };

            if( !this.options ) {
                options.vAxis = {};
                options.hAxis = {};

                if( this.label && this.label != '' ) {
                    options.title = this.label;
                }
                if( this.xlabel && this.xlabel != '' ) {
                    options.hAxis.title = this.xlabel;
                }
                if( this.ylabel && this.ylabel != '' ) {
                    options.vAxis.title = this.ylabel;
                }
            } else {
                for( var key in this.options ) {
                    options[key] = this.options[key];
                }
            }


            if( this.animate  ) {
                options.animation = {
                    duration : 750,
                    easing : 'out'
                }
            }

            if( this.isPaper ) {
              options = google.charts.Line.convertOptions(options);
            }

            this.chart.draw(this.dt, options);
        }
    });
</script>
<dom-module id="cwn-linechart" assetpath="elements/widgets/">
    <style>
        cwn-linechart {
            display: block;
        }
    </style>
    <template>
        <div id="root" style="height:400px"></div>
    </template>
</dom-module>

<script>
    Polymer({
        is : 'cwn-linechart',

        properties : {
            label : String,
            xlabel : String,
            ylabel : String,
            height : Number,
            animate : {
              notify: true,
              type: Boolean
            },
            options : Object,
            cols : Object,
            type : String
        },

        ready : function() {
          this.onLoadHandlerSet = false;
          this.dt = null;
          this.chart = null;
          this.height = 400;
          this.updateTimer = -1;
          this.options = null;
          this.cols = null;
          this.data = null;

          $(window).on('resize', function(){
            if( this.isPaper ) return;
            this.redraw();
          }.bind(this));

          this.async(function(){
              this.redraw();
          });
        },

        setHeight : function(height) {
            if( height ) this.height = height;

            this.$.root.style.height = this.height+'px';
            this.redraw();
        },

        setOnloadHandler : function() {
            if( this.onLoadHandlerSet ) return;

            // put in global scope by cwn-datastore
            chartLoadHandlers.push(function(){
                this.update(this.data);
            }.bind(this));
        },


        update : function(data) {
            this.data = data;
            if( !window.google.visualization ) return this.setOnloadHandler();
            if( !window.google.visualization.LineChart ) return this.setOnloadHandler();

            this.isPaper = false;
            if( !this.chart ) {
                if( this.type ) {
                    this.chart = new google.visualization[this.type](this.$.root);
                } else {
                    //this.isPaper = true;
                    //this.chart = new google.charts.Line(this.$.root);
                    this.chart = new google.visualization.LineChart(this.$.root);
                }
            }

            if( this.updateTimer == -1 ) clearTimeout(this.updateTimer);
            this.updateTimer = setTimeout(function() {
                this.updateTimer = -1;
                this._update(this.data);
            }.bind(this), 500);
        },

        _update : function(data) {
            if( this.cols ) {
                this.dt = new google.visualization.DataTable();
                for( var i = 0; i < this.cols.length; i++ ) {
                    this.dt.addColumn(this.cols[i]);
                }
                this.dt.addRows(data);
            } else {
                this.dt = google.visualization.arrayToDataTable(data);
            }

            this.redraw();
        },

        redraw : function() {
            if( !this.chart || !this.dt ) return;

            var options = {
                legend : {
                    position : 'none'
                }
            };

            if( !this.options ) {
                options.vAxis = {};
                options.hAxis = {};

                if( this.label && this.label != '' ) {
                    options.title = this.label;
                }
                if( this.xlabel && this.xlabel != '' ) {
                    options.hAxis.title = this.xlabel;
                }
                if( this.ylabel && this.ylabel != '' ) {
                    options.vAxis.title = this.ylabel;
                }
            } else {
                for( var key in this.options ) {
                    options[key] = this.options[key];
                }
            }

            if( (this.options && !this.options.height) && this.height ) {
              this.options.height = this.height;
            }

            if( this.animate ) {
                options.animation = {
                    duration : 750,
                    easing : 'out'
                }
            }

            if( this.isPaper ) {
              options = google.charts.Line.convertOptions(options);
            }

            this.chart.draw(this.dt, options);
        }
    });
</script>
<dom-module id="cwn-popup" assetpath="elements/widgets/">
    <style>
      cwn-popup {
        overflow: auto !important;
        z-index: 10050 !important;
      }
      .modal-content {
        box-shadow: 0 0 15px black;
      }
    </style>
    <template>

        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header" id="header" hidden$="{{!showHeader}}">
              <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true"></span><span class="sr-only">Close</span></button>
              <h4 class="modal-title"><span>{{header}}</span><span id="header-html"></span></h4>
            </div>
            <div class="modal-body" id="body">
              <content select=".popup-body"></content>
            </div>
            <div class="modal-footer" id="footer" hidden$="{{noFooter}}">
              <content select=".popup-footer"></content>
            </div>
          </div><!-- /.modal-content -->
        </div><!-- /.modal-dialog -->

    </template>
</dom-module>

<script>
  Polymer({
      is : 'cwn-popup',

      properties : {
        header : {
          type : String,
          observer : 'onHeaderUpdate'
        },
        noFooter : {
          type : Boolean,
          value : true
        },
        showing : {
          type : Boolean,
          value : false
        }
      },

      ready : function() {
        this.classList.add('modal');
        this.classList.add('fade');
      },

      init : function() {
        $(this).modal({show: false, backdrop:'static'});

        /*$(this.querySelectorAll('[data-dismiss="modal"]'))
          .on('click', function(){
              this.hide();
          }.bind(this));*/
      },

      onHeaderUpdate : function() {
        if( !this.header ) return;

        if( this.header.length > 0 ) this.showHeader = true;
        else this.showHeader = false;
      },

      show: function() {
          if( this.showing ) return;
          this.showing = true;

          $(this).modal('show');
      },

      hide: function(e) {
        if( !this.showing ) return;
        this.showing = false;

        $(this).modal('hide');
      }
  });
</script>
<dom-module id="cwn-region-selector" assetpath="elements/widgets/">
  <template>
    <cwn-popup id="popup" style="z-index: 10000">
      <div class="popup-body" id="body"></div>
    </cwn-popup>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'cwn-region-selector',

    ready : function() {
      this.$.popup.header = 'Select';
    },

    init : function(map, markerLayer) {
      this.map = map;
      this.markerLayer = markerLayer;
    },

    onClick : function(features) {
      this.features = features;
      this.renderFeatures();
      this.$.popup.show();
    },

    renderFeatures : function() {
      var table = '';
      for (var i = 0; i < this.features.length; i++) {
        table += this.renderFeature(this.features[i], i);
      }

      this.$.body.innerHTML = table;

      $(this.$.body)
        .find('a')
        .on('click', function(e){
          if( !$(e.currentTarget).hasClass('region') ) {
            this.$.popup.hide();
            return;
          }

          var index = parseInt(e.currentTarget.getAttribute('index'));
          var feature = this.features[index];

          if( feature.geometry.type == 'Polygon') {
            this.map.onRegionClick(feature.properties.id);
            this.$.popup.hide();
          } else {
            alert("Not implemented yet :(");
          }

        }.bind(this));
    },

    renderFeature : function(feature, i) {
      var link, icon = '', regionLinks = '';

      if( feature.properties.type == 'Region Link' ) {
        link = '<cwn-app-icon type="Region Link" height="26" width="26"></cwn-app-icon> <a style="font-size:18px;text-transform:capitalize" href="#info/'+feature.properties.prmname+'">'+feature.properties.prmname.replace(/_/g,' ').replace(/--/g,' to ')+'</a> ';
      } else if ( feature.properties.type == 'Region' ) {
        link = '<cwn-app-icon type="Region" height="26" width="26"></cwn-app-icon> '+feature.properties.name;
        regionLinks = '<div style="padding-left:15px"><a class="region btn btn-link" index="'+i+'" style="cusor:pointer"><i class="fa fa-expand"></i> Open</a> '+
                      ' <a href="#info/'+feature.properties.id+'" class="btn btn-link"><i class="fa fa-info"></i> Info</a></div>'
      } else {
        link = '<a href="#info/'+feature.properties.prmname+'" style="font-size:18px">'+feature.properties.prmname+'</a>';
        icon = '<cwn-app-icon type="'+feature.properties.type+'" height="26" width="26"></cwn-app-icon>';
      }

      return '<div class="layout horizontal" style="margin-bottom: 15px">'+
        '<div style="padding:15px 5px; width: 50px">'+icon+'</div>'+
        '<div class="flex">'+
          '<h4>'+link+' <small>'+feature.properties.type+'</small></h4>'+regionLinks+
          (feature.properties.description ? '<div style="color: #888">'+feature.properties.description+'</div>' : '')+
          (feature.properties.regions ? '<div><cwn-region-label prmname="'+feature.properties.prmname+'"></cwn-region-label></div>' : '')+
        '</div>'+
      '</div>'
    }
  })
</script>
<dom-module id="cwn-app-layout" assetpath="elements/">
    <style>
        .navbar-inverse {
            box-shadow: 0 0 5px black;
        }
        li {
            cursor: pointer;
        }
        .full-height {
            width: 100%;
            height: 100%;
            display: block;
            position: absolute;
            top: 0px;
            left: 0px;
        }
        ::content .nav-right a {
            margin: 8px 5px;
            padding: 7px 10px;
            line-height: 20px;
            position: relative;
            display: inline-block;
            color: white !important;
            cursor: pointer;

            background-color: rgba(255,255,255,.1);
            border-radius: 3px;
        }

        .logo {
            font-size: 16px;
            padding: 18px 10px;
            color: white !important;
            display: inline-block;
        }
        .nav-left {
            padding: 18px 10px;
            color: white !important;
            display: inline-block;
        }
        .nav-right {
            padding: 6px 0;
            color: white !important;
            display: inline-block;
            text-align: right;
        }

        #mapLayout {
          background-color: white;
          height: 100%;
          display: none;
        }

        #layout {
          display: none;
        }



    </style>

    <template>

      <div id="navBtns">
        <content select="[right-nav]"></content>
      </div>

      <paper-drawer-panel id="mapLayout" responsive-width="768px">
        <paper-header-panel drawer="" class="drawer">
          <paper-toolbar style="background-color: #2196f3">
            <div class="hidden-xs">CALVIN Water Network <span class="devTitle"></span></div>
          </paper-toolbar>

          <content select="cwn-map-menu"></content>
        </paper-header-panel>

        <paper-header-panel main="" style="height:100%">
          <paper-toolbar style="background-color: #2196f3">
            <a class="btn btn-link" paper-drawer-toggle="" style="color:white"><i class="fa fa-bars" paper-drawer-toggle=""></i></a>

            <div class="visible-xs-inline-block">CWN <span class="devTitle"></span></div>

            <div class="nav-right flex" id="mapBtns"></div>
          </paper-toolbar>

          <div class="fullbleed">
            <content select="cwn-map"></content>
          </div>


        </paper-header-panel>
      </paper-drawer-panel>


        <div class="full-height" id="layout">
            <div class="vertical layout" style="height:100%">
                <div style="height:62px">
                    <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
                        <div class="logo">
                            <span class="hidden-xs">CALVIN Water Network <span class="devTitle"></span></span>
                            <span class="visible-xs">CWN <span class="devTitle"></span></span>
                        </div>

                        <div id="leftNav" class="nav-left"></div>
                        <div class="nav-right" style="float:right" id="layoutBtns"></div>
                    </nav>
                </div>
                <div class="flex" style="position:relative">
                    <div class="full-height">
                        <content select="[content]"></content>
                    </div>
                </div>
            </div>
        </div>

    </template>
</dom-module>

<script>
    Polymer({
        is : 'cwn-app-layout',

        updateView : function(page) {
          $(this.$.navBtns).remove();

          if( page == 'map' ) {
            this.$.mapLayout.style.display = 'block';
            this.$.layout.style.display = 'none';
            this.$.mapBtns.appendChild(this.$.navBtns);
          } else {
            this.$.mapLayout.style.display = 'none';
            this.$.layout.style.display = 'block';
            this.$.layoutBtns.appendChild(this.$.navBtns);
          }
        }
    });
</script>
<dom-module id="cwn-filters" assetpath="elements/">
    <style>
        .cb-border {
            display:inline-block;
            padding:2px 2px 0 2px;
            border-radius:4px;
        }
        .showControls {
            -webkit-transform: translate3d(0, -1000px, 0);
            transform: translate3d(0, -1000px, 0);
            transition: all 250ms;
        }
        .showControls.show {
            -webkit-transform: translate3d(0, 0, 0);
            transform: translate3d(0, 0, 0);
        }
    </style>

    <template>
      <cwn-popup id="popup" style="z-index: 10000">
        <div class="popup-body" id="body">
            <div class="row">
                <div class="col-md-10 col-md-offset-1">
                  <div class="form-horizontal">

                    <div class="form-group">
                      <label for="filter-input" class="col-sm-3 control-label">Filter</label>
                      <div class="col-sm-9">
                        <input type="text" id="filter-input" class="form-control" on-change="updateFilterText" on-keyup="onKeyUp">
                        <p class="help-block">By name or description.</p>
                      </div>

                      <div class="form-group">
                        <label for="in-out-input" class="col-sm-3 control-label">Inflow / Sink Mode</label>
                        <div class="col-sm-9">
                          <input type="checkbox" id="in-out-input" on-change="updateInOutMode">
                          <p class="help-block">Only show network inflows and sinks.</p>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="filter-types" class="col-sm-2 control-label">Types</label>
                        <div class="col-sm-10" id="filter-types">

                            <template is="dom-repeat" items="{{legendArr}}">
                              <div>
                                <label class="checkbox-inline">
                                    <input type="checkbox" name="[[item.name]]" checked="[[item.checked]]" on-change="_updateCheckbox">

                                    <div class="cb-border">
                                        <cwn-app-icon width="[[item.iconSize]]" height="[[item.iconSize]]" type="[[item.name]]"></cwn-app-icon>
                                        <div style="vertical-align:top;display:inline-block;padding:2px 0 0 2px">[[item.name]]</div>
                                    </div>
                                </label>
                              </div>
                            </template>

                        </div>
                    </div>

                  </div>
                </div>
            </div>
        </div>
      
    </div></cwn-popup></template>
</dom-module>

<script>
    Polymer({
        is : 'cwn-filters',

        ready : function() {
          this.legendArr = [];
          this.iconSize = 22;

          this.filters = {
              calibrationMode : true,
              oneStepMode : true,
              inflowSinkMode : false,
              text : '',
          };
        },

        setLegend : function(legend) {
          this.legend = legend;

          var tmp = [];
          for( var key in this.legend ) {
              this.filters[key.replace(' ','_').replace('-','_')] = true;
              tmp.push({
                  iconSize : this.iconSize,
                  name : key,
                  checked : true
              });
          }
          this.legendArr = tmp;
        },

        updateInOutMode : function() {
          this.filters.inflowSinkMode = $(this.$['in-out-input']).is(':checked');
          this.fire('update', this.filters);
        },

        _updateCheckbox : function(e) {
            var name = e.currentTarget.getAttribute('name');
            var value = $(e.currentTarget).is(':checked');
            this.filters[name.replace(' ','_').replace('-','_')] = value;

            this.fire('update', this.filters);
        },

        show : function() {
          this.$.popup.show();
        },

        hide : function() {
          this.$.popup.hide();
        },

        setCalibrationMode : function(e) {
            this.filters.calibrationMode = $(e.currentTarget).is(':checked');
            this.fire('update', this.filters);
        },

        setOneStepMode : function(e) {
            this.filters.oneStepMode = $(e.currentTarget).is(':checked');
            this.fire('update', this.filters);
        },

        onKeyUp : function(e) {
            if( e.which != 13 ) return;
            this.updateFilterText(e);
        },

        updateFilterText : function(e) {
            this.filters.text = e.currentTarget.value;
            this.fire('update', this.filters);
        }
    });
</script>
<dom-module id="cwn-search" assetpath="elements/">
  <template>
    <cwn-popup id="popup" style="z-index: 10000">
      <div class="popup-body" id="body">

        <div class="form-horizontal">
          <div class="form-group">
            <label for="input" class="col-sm-2 control-label">Search</label>
            <div class="col-sm-10">
              <input type="input" class="form-control" id="input" placeholder="Search Text" on-keyup="onKeypress">
            </div>
          </div>
        </div>

        <div id="results"></div>

      </div>
    </cwn-popup>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'cwn-search',

    ready : function() {
      this.$.popup.header = 'Find Node or Link';
      this.MAX_RESULTS = 50;
    },

    show : function() {
      this.$.popup.show();
      setTimeout(function(){
        this.$.input.focus();
      }.bind(this), 200);

    },

    onKeypress : function(e) {
      this.search(e.currentTarget.value);
    },

    search : function(txt) {
      txt = txt.toLowerCase();

      var matchCount = 0;
      this.prmnameMatches = [];
      this.otherMatches = [];


      var types = ['nodes', 'links'];

      types.forEach(function(type){
        var arr = CWN.ds.data[type];
        for( var i = 0; i < arr.length; i++ ) {
          if( arr[i].properties.prmname.toLowerCase().indexOf(txt) > -1 ) {
            if( matchCount > this.MAX_RESULTS ) break;
            matchCount++;
            this.prmnameMatches.push(arr[i]);
          }
        }
      }.bind(this));

      var types = ['nodes', 'links'];

      if( matchCount < this.MAX_RESULTS ) {
        types.forEach(function(type){
          var arr = CWN.ds.data[type];
          for( var i = 0; i < arr.length; i++ ) {
            if( arr[i].properties.description.toLowerCase().indexOf(txt) > -1 ) {
              if( matchCount > this.MAX_RESULTS ) break;
              matchCount++;
              this.otherMatches.push(arr[i]);
            }
          }
        }.bind(this));
      }

      this.renderResults();
    },

    renderResults : function() {
      var list = '';
      for( var i = 0; i < this.prmnameMatches.length; i++ ) {
        list += this.renderResult(this.prmnameMatches[i]);
      }
      for( var i = 0; i < this.otherMatches.length; i++ ) {
        list += this.renderResult(this.otherMatches[i]);
      }

      this.$.results.innerHTML = list;
      $(this.$.results).find('a').on('click', function(){
        this.$.popup.hide();
      }.bind(this));
    },

    renderResult : function(feature) {
      return '<div class="layout horizontal">'+
        '<div style="padding:15px 5px; width: 50px"><cwn-app-icon type="'+feature.properties.type+'" height="26" width="26"></cwn-app-icon></div>'+
        '<div class="flex">'+
          '<h4><a style="font-size: 18px" href="#info/'+feature.properties.prmname+'">'+feature.properties.prmname+'</a> <small>'+feature.properties.type+'</small></h4>'+
          (feature.properties.description ? '<div style="color: #888">'+feature.properties.description+'</div>' : '')+
          '<div><cwn-region-label prmname="'+feature.properties.prmname+'"></cwn-region-label></div>'+
        '</div>'+
      '</div>'
    }

  })
</script>
<dom-module id="cwn-about" assetpath="elements/">
  <template>
    <cwn-popup id="popup" style="z-index: 10000">
      <div class="popup-body" id="body">
        <div>
          <p>
            All data can be accessed via the
            <a href="https://github.com/ucd-cws/calvin-network-data" target="_blank"><i class="fa fa-github"></i> GitHub Repository.</a>
            Tickets for data issues should be made <a href="https://github.com/ucd-cws/calvin-network-data/issues" target="_blank">here.</a>
          </p>

          <p>
            Please report application bugs
            <a href="https://github.com/ucd-cws/ca-water-network/issues" target="_blank"><i class="fa fa-bug"></i> here.</a>
          </p>

          <p>
            Created by the UC Davis <a href="https://watershed.ucdavis.edu/" target="_blank">Center for Watershed Sciences</a>
          </p>
        </div>

      </div>
    </cwn-popup>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'cwn-about',

    ready : function() {
      this.$.popup.$['header-html'].innerHTML = 'CALVIN Water Network '+
        '<small><a href="http://calvin.ucdavis.edu/" target="_blank"><i class="fa fa-globe"></i> Homepage</a></small>';
    },

    show : function() {
      this.$.popup.show();
    }

  });
</script>
<dom-module id="cwn-node-info-btns" assetpath="elements/cwn-info-page/node/">
  <template>
    <style>
      :host {
        display: block;
      }
      .info-btn {
        background-color: #2196f3;
        color: white;
      }
      .btn-circle {
        width: 30px;
        height: 30px;
        text-align: center;
        padding: 6px 0;
        font-size: 12px;
        line-height: 1.428571429;
        border-radius: 15px;
        margin: 0 7px;
      }
      .btn-circle.btn-lg {
        width: 50px;
        height: 50px;
        padding: 8px 14px;
        font-size: 22px;
        line-height: 1.5;
        border-radius: 25px;
      }
      .btn-circle.btn-xl {
        width: 70px;
        height: 70px;
        padding: 10px 16px;
        font-size: 24px;
        line-height: 1.5;
        border-radius: 35px;
      }
    </style>

    <a class="btn btn-circle btn-lg info-btn" hidden$="{{!showNavLinks}}" on-click="goToGraph" name="View Network Graph" on-mouseenter="onMouseEnter" on-mouseleave="onMouseLeave">
      <i class="fa fa-code-fork"></i>
    </a>
    <a class="btn btn-circle btn-lg info-btn" hidden$="{{!showNavLinks}}" on-click="goTo" name="Show on Map" on-mouseenter="onMouseEnter" on-mouseleave="onMouseLeave">
      <i class="fa fa-map-marker"></i>
    </a>
    <a class="btn btn-circle btn-lg info-btn" id="githubLink" target="_blank" name="Show on GitHub" on-mouseenter="onMouseEnter" on-mouseleave="onMouseLeave">
      <i class="fa fa-github"></i>
    </a>
    <a class="btn btn-circle btn-lg info-btn" id="excelLink" target="_blank" name="Download Excel Data File" on-mouseenter="onMouseEnter" on-mouseleave="onMouseLeave">
      <i class="fa fa-download"></i>
    </a>

    <div style="height:40px; padding-top:10px; font-weight: bold">
      <div id="message" class="animated fadeInUp" style="display:none"></div>
    </div>


  </template>
  <script>
    Polymer({
      is: 'cwn-node-info-btns',

      ready : function() {
        this.showNavLinks = true;
      },

      onMouseEnter : function(e) {
        this.$.message.innerHTML = e.currentTarget.getAttribute('name');
        this.$.message.style.display = 'block';
      },

      onMouseLeave : function() {
        this.$.message.style.display = 'none';
      },

      update : function(feature) {
        if( !feature ) return;
        this.feature = feature;

        this.showNavLinks = true;

        if( this.feature.properties.type == 'Diversion' || this.feature.properties.type == 'Return Flow' ) {
          this.showNavLinks = false;
        } else if( this.feature.properties.type == 'Region Link' || this.feature.properties.type == 'Region' ) {
          this.showNavLinks = false;
        }

        if( feature.properties.repo ) {
          this.$.githubLink.style.display = 'inline-block';
          this.$.githubLink.setAttribute('href', feature.properties.repo.github);

          if( feature.properties.repo.files && feature.properties.repo.files.length > 0 ) {
            this.$.excelLink.setAttribute('href', '/excel/create?prmname='+feature.properties.prmname);
            this.$.excelLink.style.display = 'inline-block';
          } else {
            this.$.excelLink.style.display = 'none';
          }

        } else {
          this.$.githubLink.style.display = 'none';
          this.$.excelLink.style.display = 'none';
        }
      },

      goTo : function() {
        window.location.hash = 'map';
        this.async(function() {
          var pts = this.feature.geometry.coordinates;
          this.leaflet.setView([pts[1], pts[0]], 12);
        });
      },

      goToGraph : function() {
        window.location.hash = 'graph/'+this.feature.properties.prmname;
      }
    });
  </script>
</dom-module>
<dom-module id="cwn-node-info" assetpath="elements/cwn-info-page/node/">
    <style>
        #middleCol {
            transition: margin-top linear 200ms;
            -webkit-transition: margin-top linear 200ms;
            -moz-transition: margin-top linear 200ms;
            -ms-transition: margin-top linear 200ms;
        }
        .border {
          padding: 5px;
          display: inline-block;
          /*border-radius: 6px;
          border: 1px solid #eee;*/
          margin-top: 25px;
        }
        .description {
          font-size: 12px;
          color: #888;
        }
        :host {
            display: block;
        }
        [hidden] {
          display:none;
        }
        .overflow {
          max-height: 300px;
          overflow: auto;
        }
    </style>

    <template>
        <div class="row">

          <!-- Start Origins -->
          <div class="col-md-4 no-float">
            <h4 class="page-header node-info-header" style="text-align:right">Origins</h4>
            <div>

              <div id="origin">
                <div style="text-align:right">
                  <div>
                    <cwn-info-link prmname$="{{feature.properties.origin}}"></cwn-info-link>
                  </div>
                  <div hidden$="{{!hasOriginDescription}}">
                    <div class="description">{{originDescription}}</div>
                  </div>
                </div>
              </div>

              <div id="originExtra" style="text-align:right"></div>

              <div class="node-info-list">
                <template is="dom-repeat" items="{{origins}}">
                  <div style="text-align:right;margin-bottom:20px">
                    <div>
                      <cwn-info-link prmname$="{{item.name}}"></cwn-info-link>&nbsp;&nbsp;&nbsp;

                      <span hidden$="{{item.hideArrow}}">
                        <a href="{{item.link}}" hidden$="{{!item.hasLink}}">
                          <i class="fa fa-long-arrow-right" style="font-size:32px;display:inline-block;"></i>
                        </a>

                        <span hidden$="{{item.hasLink}}">
                            <i class="fa fa-long-arrow-right" style="color:#888;font-size:32px;display:inline-block;"></i>
                        </span>
                      </span>

                    </div>
                    <div class="description" hidden$="{{!item.description}}" style="margin-right: 55px">{{item.description}}</div>
                  </div>
                </template>
              </div>
            </div>
          </div>
          <!-- End Origins -->

          <!-- Start Feature -->
          <div class="col-md-4" style="text-align:center" id="middleCol">
              <div class="border">
                <table style="margin: 0 auto">
                  <tbody><tr>
                    <td>
                      <cwn-app-icon type$="{{type}}" width="72" height="72" fillfromtype="true" style="margin:35px 15px 0 15px"></cwn-app-icon>
                    </td><td>
                      <h3 id="label" style="text-transform: capitalize"></h3>
                      <div><b>{{feature.properties.type}}</b></div>
                    </td>
                  </tr>
                </tbody></table>
                <div style="padding: 10px 10px 0 10px; color: #888">{{feature.properties.description}}</div>

                <cwn-region-label id="regions"></cwn-region-label>

                <cwn-node-info-btns id="btns" style="margin-top: 20px; padding-top: 10px; border-top: 1px solid #ddd"></cwn-node-info-btns>

              </div>
          </div>
          <!-- End Feature -->

          <!-- Start Terminals -->
          <div class="col-md-4">
            <h4 class="page-header node-info-header">Terminals</h4>

            <div id="terminal">
              <div>
                <cwn-info-link prmname$="{{feature.properties.terminus}}"></cwn-info-link>
              </div>
              <div hidden$="{{!hasTerminalDescription}}">
                <div class="description">{{terminalDescription}}</div>
              </div>
            </div>

            <div id="terminusExtra"></div>

            <div class="node-info-list">
              <template is="dom-repeat" items="{{terminals}}">
                <div style="margin-bottom:20px">
                  <div>

                    <span hidden$="{{item.hideArrow}}">
                      <a href="{{item.link}}" hidden$="{{!item.hasLink}}">
                        <i class="fa fa-long-arrow-right" style="font-size:32px;display:inline-block;"></i>
                      </a>

                      <span hidden$="{{item.hasLink}}">
                          <i class="fa fa-long-arrow-right" style="color:#888;font-size:32px;display:inline-block;"></i>
                      </span>
                    </span>

                    &nbsp;&nbsp;&nbsp;<cwn-info-link prmname$="{{item.name}}"></cwn-info-link>

                  </div>
                  <div hidden$="{{!item.description}}">
                    <div class="description" style="margin-left: 55px">{{item.description}}</div>
                  </div>
                </div>
              </template>
            </div>
          </div>
          <!-- End Terminals -->

        </div>

        <div id="regionNodes"></div>
    </template>
</dom-module>
<script>Polymer({
    is : 'cwn-node-info',

    properties : {
        feature : {
          type : Object,
          observer : 'update'
        },
        ds : {
          type : Object,
          observer : 'update'
        },
        leaflet : {
          type : Object
        },
        islocal : {
          type : Boolean
        }
    },

    ready : function() {
      this.hasOriginDescription = false;
      this.originDescription = '';
      this.editUrl = '';
      this.originUrl = '';
      this.terminalUrl = '';
      this.hasTerminalDescription = false;
      this.terminalDescription = '';
      this.type = '';
      this.origins = [];
      this.terminals = [];

      $(window).on('resize', this.updateSize.bind(this));
    },

    update : function() {
        if( !CWN.ds || !this.feature ) return;

        this.type = this.feature.properties.type;
        this.editUrl = '#edit/'+this.feature.properties.prmname;

        if( this.feature.properties.type == 'Diversion' || this.feature.properties.type == 'Return Flow' ) {
          this.$.label.innerHTML = this.feature.properties.origin.replace(/_/g, ' ')+' <small>to</small> '+this.feature.properties.terminus.replace(/_/g, ' ');
        } else if( this.feature.properties.type == 'Region Link') {
          this.$.label.innerHTML = this.feature.properties.prmname.replace(/--/, ' <small>to/from</small> ').replace(/_/g, ' ');
        } else if( this.feature.properties.type == 'Region') {
          this.$.label.innerHTML = this.feature.properties.label;
        } else {
          this.$.label.innerHTML = this.feature.properties.prmname.replace(/_/g, ' ');
        }

        if( this.feature.properties.type == 'Region Link' ) {
          $(this).find('.node-info-header').css('display','none');
          this.$.origin.style.marginTop = '30px';
          this.$.terminal.style.marginTop = '30px';
        } else {
          $(this).find('.node-info-header').css('display','block');
          this.$.origin.style.marginTop = '0';
          this.$.terminal.style.marginTop = '0';
        }

        if( this.feature.properties.type == 'Region' ) {
          $(this).find('.node-info-list').addClass('overflow');
          this.renderRegionNodes();
        } else {
          $(this).find('.node-info-list').removeClass('overflow');
          this.$.regionNodes.innerHTML = '';
        }


        this.$.regions.update(this.feature);

        this.origins = [];
        this.terminals = [];
        this.$.originExtra.innerHTML = '';
        this.$.terminusExtra.innerHTML = '';

        var link, node, types = ['origins', 'terminals'];
        types.forEach(function(type){
          if( this.feature && this.feature.properties[type] ) {
            for( var i = 0; i < this.feature.properties[type].length; i++ ) {
              link = CWN.ds.lookupMap[this.feature.properties[type][i].link_prmname];
              node = CWN.ds.lookupMap[this.feature.properties[type][i].prmname];

              if( link && node ) {
                this[type].push({
                  name: node.properties.prmname,
                  link: '#info/'+link.properties.prmname,
                  hasLink : true,
                  description: node ? node.properties.description : ''
                });
              } else {
                this[type].push({
                    name: this.feature.properties[type][i].prmname,
                    hasLink : false,
                    link: '',
                    description: ''
                });
              }
            }
          }
        }.bind(this));


        // stupid polymer hack! when will this stop!!!!!!!!!!
        this.origins = $.extend(true, [], this.origins);
        this.terminals = $.extend(true, [], this.terminals);

        $(window).on('resize', this.updateSize.bind(this));

        if( this.$.btns.update ) {
          this.$.btns.update(this.feature);
        }

        this.onOriginUpdate();
        this.onTerminalUpdate();
    },

    createRenderLinks : function(name) {
      var link, i, tmp = [];
      var links = this[name];
      if(!links) return;

      for( i = 0; i < links.length; i++ ) {
        link = links[i];

        tmp.push({
          name: link.properties.prmname,
          link: '#info/'+link.properties.prmname,
          hasLink : true,
          description: link.properties.description ? link.properties.description : ''
        });
      }

      // stupid polymer... when will this crap work right!?
      this[name] = tmp;
    },

    onOriginUpdate : function() {
        if( !CWN.ds ) return;

        if( !this.feature.properties.origin ) return this.$.origin.style.display = 'none';
        else this.$.origin.style.display = 'block';

        this.hasOriginDescription = false;
        this.originDescription = '';

        if( CWN.ds.lookupMap[this.feature.properties.origin] ) {
            this.hasOriginDescription = true;
            this.originDescription = CWN.ds.lookupMap[this.feature.properties.origin].properties.description
        }
    },

    renderRegionNodes : function() {
      var cols = ['','',''], col, node, c = 0;
      for( var i = 0; i < this.feature.properties.nodes.length; i++ ) {
        col = c % 3;

        node = CWN.ds.lookupMap[this.feature.properties.nodes[i]];
        if( !node ) continue;

        cols[col] +=
          '<cwn-info-link prmname="'+node.properties.prmname+'"></cwn-info-link>'+
          '<div class="info-block" style="margin-bottom: 15px">'+(node.properties.description || '')+'</div>';
        c++;
      }

      this.$.regionNodes.innerHTML =
        '<div><a class="btn btn-link btn-toggle">Node List</a></div>'+
        '<div class="well" style="display:none">'+
          '<div class="row">'+
            '<div class="col-sm-4">'+
              cols.join('</div><div class="col-sm-4">')+
            '</div>'+
          '</div>'+
        '</div>';

      $(this.$.regionNodes)
        .find('.btn-toggle')
        .on('click', function(){
          $(this.$.regionNodes).find('.well').toggle('slow');
        }.bind(this));
    },

    onTerminalUpdate : function() {
        if( !CWN.ds ) return;

        if( !this.feature.properties.terminus ) return this.$.terminal.style.display = 'none';
        else this.$.terminal.style.display = 'block';

        this.hasTerminalDescription = false;
        this.terminalDescription = '';

        if( CWN.ds.lookupMap[this.feature.properties.terminus] ) {
            this.hasTerminalDescription = true;
            this.terminalDescription = CWN.ds.lookupMap[this.feature.properties.terminus].properties.description
        }
    },

    updateSize : function() {
      var w = $(window).width();

      if( w < 992 ) {
        this.$.middleCol.style.marginTop = '0px';
        return;
      }

      var ele = $(this.$.middleCol);

      var h = ele.next().height();
      if( h < ele.prev().height() ) h = ele.prev().height();
      if( h < ele.height() ) h = ele.height();


      this.$.middleCol.style.marginTop = Math.floor(((h-ele.height()) / 2)) + 'px';
    },

    setRegionLinkInfo : function(info) {
      var order = 0;
      if( info[0].origin !== this.feature.properties.origin ) {
        order = 1;
      }

      for( var i = 0; i < info[order].included.length; i++ ) {
        this.origins.push({
            name: info[order].included[i],
            hasLink : false,
            hideArrow : true,
            link: '#info/'+info[order].included[i],
            description: ''
        });
      }

      if( info[order].included.length > 0 ) {
        this.$.originExtra.innerHTML = '<h5 class="page-header" style="margin:0;text-transform:capitalize">Links to '+this.feature.properties.terminus.replace(/_/g,' ')+'</h5>';
      }

      if( order === 0 ) order++;
      else order--;

      for( var i = 0; i < info[order].included.length; i++ ) {
        this.terminals.push({
            name: info[order].included[i],
            hasLink : false,
            hideArrow : true,
            link: '#info/'+info[order].included[i],
            description: ''
        });
      }

      if( info[order].included.length > 0 ) {
        this.$.terminusExtra.innerHTML = '<h5 class="page-header" style="margin:0;text-transform:capitalize">Links to '+this.feature.properties.origin.replace(/_/g,' ')+'</h5>';
      }

      this.origins = $.extend(true, [], this.origins);
      this.terminals = $.extend(true, [], this.terminals);
    },

    goTo : function() {
      window.location.hash = 'map';
      this.async(function() {
        var pts = this.feature.geometry.coordinates;
        this.leaflet.setView([pts[1], pts[0]], 12);
      });
    },

    goToGraph : function() {
      window.location.hash = 'graph/'+this.feature.properties.prmname;
    }
});
</script>
<dom-module id="cwn-bound-chart" assetpath="elements/cwn-info-page/cost/">
  <style>
    :host {
      display : block
    }
  </style>
  <template>

    <h5>
      Type: <small>{{type}}</small>
    </h5>

    <div>{{description}}</div>

    <div hidden$="{{!showConstantBounds}}">
      $<span>{{constraintChart.constant}}</span>
    </div>

    <div id="constraintChartAnchor"></div>

    <template is="dom-template" id="constraintChartTimeSeries">
      <cwn-date-linechart animate=""></cwn-date-linechart>
    </template>

    <template is="dom-template" id="constraintChart">
      <cwn-linechart cols="{{cols}}" options="{{options}}" animate="">
      </cwn-linechart>
    </template>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'cwn-bound-chart',

    ready : function() {
      this.showConstantCost = false;
      this.showConstantBounds = false;

      this.constraintChart = {
          constant: -1,
          label : '',
          isTimeSeries : false,
          data : [],
          options : {
              series: [{'color': '#F1CA3A'}],
              intervals: { 'style':'area' },
              vAxis : {
                viewWindow:{ min: 0 }
              }
          }
      };

      this.charts = {};
    },

    /*
      --LBC (Lower Bound Constant),
      --LBM (Lower Bound Monthly Varying)
      --LBT (Lower Bound Time Varying)
      --UBC (Upper Bound Constant)
      --UBM (Upper Bound Monthly Varying)
      --UBT (Upper Bound Time Varying)
      --EQC (Equality Constraint: constant, this requires a time-series data)
         -- is upper and lower bound, single line
      --EQT (Equality Constraint: time, this requires a time-series data)
        -- is upper and lower bound, single line
      --NOB (No Bounds)
    */
    render : function(bound) {
      var data = {
        upper: null,
        lower : null,
        NOB : false,
        EQC : false,
        use : 'constant'
      }
      this.type = bound.type;
      this.description = bound.description || '';

      if( bound.type == 'LBC' || bound.type == 'LBM' || bound.type == 'LBT') {
        data.lower = bound;
        if( bound.type != 'LBC' ) data.use = 'lower';

      } else if ( bound.type == 'UBC' || bound.type == 'UBM' || bound.type == 'UBT' ) {
        data.upper = bound;
        if( bound.type == 'UBM' || bound.type == 'UBT' ) {
          // if lower is date, we want to use the date
          if( !(bound.type != 'UBM' && data.use == 'lower') ) data.use = 'upper';
        }

      } else if ( bound.type == 'NOB' ) {
        data.NOB = true;

      // TODO: this should proly render a special case
      } else if ( bound.type == 'EQC' || bound.type == 'EQT' ) {
        data.EQC = true;
        data.lower = bound;
        data.upper = bound;
        data.use = 'upper';
      }

      if( bound.type == 'UBT' || bound.type == 'LBT' ||
          bound.type == 'EQC' || bound.type == 'EQT') {
        this.constraintChart.isTimeSeries = true;
      }


      //  TODO: if NOB, just quit?
      if( data.NOB ) return;

      var chartData = [];

      var length = 1;
      if( data.upper && data.upper.type != 'UBC') {
        length = data.upper.bound.length;
      }
      if( data.lower && data.lower.type != 'LBC' && data.lower.bound.length > length ) {
        length = data.lower.bound.length;
      }

      var header = ['Date'];
      if( data.upper ) header.push('Upper Bound');
      if( data.lower ) header.push('Lower Bound');

      if( length == 1 ) length = 12;  // TODO: if len == 1, should we just show text?
      for( var i = 0; i < length; i++ ) {
        this.appendBoundsRow(data, chartData, i);
      }

      this.constraintChart.data = chartData;
      this.updateChart();
    },

    appendBoundsRow : function(data, chartData, index) {
      var row = [], ud, ld;

      if( data.upper ) {
        ud = this.getBoundsRow(data.upper, index);
        row.push(ud[1]);
      }
      if( data.lower ) {
        ld = this.getBoundsRow(data.lower, index);
        row.push(ld[1]);
      }

      if( data.use == 'constant' ) row.splice(0, 0, index+'');
      else if( data.use == 'upper' ) row.splice(0, 0, ud[0]);
      else row.splice(0, 0, ld[0]);

      chartData.push(row);
    },

    getBoundsRow : function(data, index) {
      if( data.type == 'LBC' || data.type == 'UBC' ) {
        if( index == 0 ) return ['Constant Lower', 'Constant Lower']
        return ['', data.bound];
      }

      if( index > data.bound.length -1) {
        index = index % 12;
      }
      if( index > data.bound.length -1) {
        return ['Invalid', 0];
      }

      return data.bound[index];
    },

    getContraintsLength : function(bounds) {
      var l = 0;
      if( bounds.lower ) {
        if( bounds.lower.bound_type == 'Constant' ) {
          l = 1;
        } else if ( bounds.lower.bound_type == 'TimeSeries' ) {
          this.constraintChart.isTimeSeries = true;
          this.hasTimeSeries = true;

          l = bounds.lower.bound.length;
        } else if ( bounds.lower.bound_type == 'Monthly' ) {
          l = bounds.lower.bound.length;
        }
      }
      if (bounds.upper ) {
        if( bounds.upper.bound_type == 'Constant' && l == 0 ) {
          l = 1;
        } else if(bounds.upper.bound_type == 'TimeSeries' && l < bounds.upper.bound.length ) {
          this.constraintChart.isTimeSeries = true;
          this.hasTimeSeries = true;

          l = bounds.upper.bound.length;
        } else if ( bounds.upper.bound_type == 'Monthly' && l < bounds.upper.bound.length ) {
          l = bounds.upper.bound.length;
        }
      }
      return l;
    },

    updateChart : function() {
        if( this.constraintChart.data.length != 0 || this.constraintChart.constant != -1 ) {
            this.showBounds = true;
        }

        if( this.constraintChart.constant != -1 ) {
            this.showConstantBounds = true;
        }

        this.$.constraintChartAnchor.innerHTML = '';
        this.charts.constraintChart = null;

        if( this.constraintChart.data.length != 0 ) {
            var isline = false;

            // stamp out cwn-date-linechart instead of just linechart
            if( this.constraintChart.isTimeSeries ) {
                this.hasTimeSeries = true;
                this.charts.constraintChart = this._stamp(this.$.constraintChartTimeSeries, 'cwn-date-linechart', this.constraintChart);
            } else {
                isline = true;
                this.charts.constraintChart = this.$.constraintChart.stamp(this.constraintChart);
            }


            this.$.constraintChartAnchor.appendChild(this.charts.constraintChart.root);

            if( isline ) {
              this.$.constraintChartAnchor.querySelector('cwn-linechart').update(this.constraintChart.data);
            }
        }
    },

    // dom-template: http://polymer.github.io/polymer/
    // doesn't seem to take variables when you stamp now :(
    // setting manually.
    _stamp : function(ele, query, data) {
      var template = ele.stamp();

      if( query && data ) {
        var newEle = template.root.querySelector(query);
        if( newEle ) {
          for( var key in data ) newEle[key] = data[key];
        }
      }

      return template;
    }
  })
</script>
<dom-module id="cwn-cost-info" assetpath="elements/cwn-info-page/cost/">
    <template>
        <h2 class="page-header">Costs</h2>

        <div hidden$="{{!showCostData}}">
          <div hidden$="{{!showMonthlyVariableCost}}">

            <div class="btn-group" id="monthSelector">
              <template is="dom-repeat" items="{{months}}">
                <a class="btn btn-xs btn-primary" on-click="setMonth">{{item}}</a>
              </template>
            </div>

            <cwn-linechart id="lineChart" label="{{costChartLabel}}" xlabel="Capacity (kAF)" ylabel="Cost ($/kAF)" animate="true">
            </cwn-linechart>
          </div>

          <div hidden$="{{!showConstantCost}}">
            <h5>Constant: $<span>{{costs.cost}}</span></h5>
          </div>

        </div>

        <h4 hidden$="{{!showBounds}}" class="page-header">Bounds</h4>

        <div id="boundChartRoot"></div>
    </template>
</dom-module>

<script>
Polymer({
    is : 'cwn-cost-info',

    properties : {
        feature : {
            type : Object,
            observer : 'update'
        }
    },

    ready : function() {
      this.noCostData = true;
      this.costsMonths = [];
      this.costs = {
        label : '',
        data : {},
        cost : 0, // for constant costs
        selected : 0
      };



      this.months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'],

      this.showCostData = false;
      this.showMonthlyVariableCost = false;
      this.showConstantCost = false;
      this.costChartLabel = '';
      this.costChartData = [];
      this.showBounds = false;
      this.showConstantBounds = false;
      this.showTimeSeriesBounds = false;
      this.showChartBounds = false;
      this.hasTimeSeries = false;
      this.charts = {};
    },

    update : function() {
        if( !this.feature ) return;

        this.hasTimeSeries = false;

        this.showCostData = false;
        this.showMonthlyVariableCost = false;

        this.showBounds = false;
        this.nodata = false;

        var hasBounds = false;
        if( this.feature.properties.extras && this.feature.properties.extras.bounds ) {
          hasBounds = true;
        }

        if( !this.feature.properties.costs || !hasBounds ) {
          this.nodata = true;
          $(this).parent().hide();
          this.fire('cost-ready');
          return;
        }

        $(this).parent().show();
        this.showCostData = true;

        if( hasBounds ) this.loadBounds();

        this.renderCostData(this.feature.properties.costs);
        this.fire('cost-ready');
    },



    renderCostData : function(d) {
      this.costs.label = d.type;


      if( d.type == 'Constant' ) {

        this.showConstantCost = true;
        this.costs.cost = d.cost;


      } else if( d.type == 'Monthly Variable' ) {

        this.showMonthlyVariableCost = true;

        this.costsMonths = {};
        var costArr;
        if( !d.costs ) return;

        if( d.costs.data ) {
          this.costMonths = d.costs.data;
        } else {
          this.costMonths = d.costs;
        }
        this.showMonthlyVariableCost = true;
        this.$.monthSelector.style.display = 'inline-block';

        this.setMonth('JAN');

      } else if( d.type == 'Annual Variable' ) {

        if( !d.costs ) return;

        var keys = Object.keys(d.costs);
        if( keys.length == 0 ) return;
        if( keys.length > 1 ) {
          console.log('! cwn-cost-info found multiple keys for costs data');
          console.log(keys);
        }

        this.costChartLabel = d.type+': '+keys[0];
        this.costChartData = d.costs[keys[0]];
        this.$.lineChart.update(this.costChartData);
        this.showMonthlyVariableCost = true;
        this.$.monthSelector.style.display = 'none';

      } else {
        alert('Unknown cost type: '+d.type);
      }
    },

    loadBounds : function() {
      CWN.ds.loadExtras(this.feature.properties.prmname, function(resp){
        this.renderBounds(resp.bounds);
      }.bind(this));
    },

    renderBounds : function(bounds) {
      this.$.boundChartRoot.innerHTML = '';

      if( bounds.length === 0 ) {
        this.showBounds = false;
        return;
      }
      this.showBounds = true;

      for( var i = 0; i < bounds.length; i++ ) {
        var ele = document.createElement('cwn-bound-chart');
        this.$.boundChartRoot.appendChild(ele);
        ele.render(bounds[i]);
      }
    },

    // used by the month selector to update Monthly Variable chart's current month
    // buttons for this UI are generated above.  Can take button click event
    // or month string
    setMonth : function(month) {
      if( typeof month == 'object' ) month = month.currentTarget.innerHTML;
      month = month.toUpperCase();

      this.costChartLabel = this.costs.label+' - '+month;
      this.costChartData = this.costMonths[month];

      // redraw chart
      this.$.lineChart.update(this.costChartData);
    }

});
</script>
<dom-module id="cwn-output-info" assetpath="elements/cwn-info-page/">
  <template>
    <div id="loading" style="display:none">
      <h4><i class="fa fa-circle-o-notch fa-spin"></i> Loading...</h4>
    </div>

    <div id="flow" style="display:none">
      <h4>Flow</h4>
      <cwn-date-linechart id="chart" animate=""></cwn-date-linechart>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
      is : 'cwn-output-info',

      update : function(feature) {
        if( this.feature && feature.properties.prmname == this.feature.properties.prmname ) {
          return;
        }

        this.feature = feature;

        this.$.flow.style.display = 'none';
        this.net = false;

        if( this.feature.properties.extras && this.feature.properties.extras.flow ) {
          $(this).parent().show();
          this.$.loading.style.display = 'block';
          this.load();
        } else {
          $(this).parent().hide();
          this.$.loading.style.display = 'none';
        }
      },

      /*loadAggregate : function() {
        CWN.ds.loadAggregate('flow', this.feature.properties.prmname, function(resp) {
          this.$.loading.style.display = 'none';

          var data = [['date','In','Out','Difference']];

          var oLen = Object.keys(resp.origins.flow).length;
          var tLen = Object.keys(resp.terminals.flow).length;

          if( oLen > 0 || tLen > 0 ) {
            var it = resp.origins.flow, key, o, t;
            if( tLen > oLen ) it = resp.terminals.flow;


            for( var key in it) {
              o = resp.origins.flow[key] || 0;
              t = resp.terminals.flow[key] || 0;
              t *= -1;

              data.push([key, o, t, o+t]);
            }
          }

          this.data = {
            flow : data
          }
          this.renderFlow();
        }.bind(this));
      },*/

      /*loadLinkAggregate : function() {
        // TODO: include units in aggregate response
        CWN.ds.loadAggregate('flow', this.feature.properties.origin, this.feature.properties.terminus, function(resp) {
          this.$.loading.style.display = 'none';

          var data = [[
            'date',
            this.feature.properties.origin+' to '+this.feature.properties.terminus+' (kaf)',
            this.feature.properties.terminus+' to '+this.feature.properties.origin+' (kaf)'
          ]];

          if( resp.origin.flow ) {
            for( var key in resp.origin.flow ) {
              data.push([key, resp.origin.flow[key] || 0, resp.terminus.flow[key] || 0]);
            }
          }

          this.data = {
            flow : data
          }
          this.renderFlow();

          this.fire('region-link-update', {
            origin : {
              prmname : this.feature.properties.origin,
              links : resp.origin.included
            },
            terminus : {
              prmname : this.feature.properties.terminus,
              links : resp.terminus.included
            }
          });
        }.bind(this));
      },*/

      load : function() {
        CWN.ds.loadExtras(this.feature.properties.prmname, function(resp){
          this.$.loading.style.display = 'none';
          if( resp.error ) {
            return alert(resp.message);
          }

          this.data = resp;

          if( this.data.flow ) {
            this.renderFlow();
          }
        }.bind(this));
      },

      renderFlow : function() {
        if( this.data.flow.length <= 1 ) {
          $(this).parent().hide();
          return;
        }
        this.$.flow.style.display = 'block';
        this.$.chart.update(this.data.flow);
      }
  });
</script>
<dom-module id="cwn-climate-info" assetpath="elements/cwn-info-page/">
  <style>
    :host {
      display : block;
    }
  </style>
  <template>

    <h2 class="page-header">Climate</h2>

    <div hidden$="{{!climateLoading}}" style="color:#888">
      Loading climate data...
    </div>

    <div>

      <div hidden$="{{!inflows.length}}">
        <h4>Inflows</h4>
      </div>

      <div id="inflows">
        <h4>Inflows</h4>
        <div id="inflowCharts"></div>
      </div>

      <div id="eacChartRoot"></div>
      <template id="eacChart" is="dom-template">
        <h4>Elevation / Area / Capacity</h4>
        <cwn-linechart data="{{data}}" cols="{{cols}}" options="{{options}}" type="{{type}}">
        </cwn-linechart>
      </template>

      <div id="evaporation" style="display:none">
        <h4>Evaporation</h4>
        <cwn-date-linechart animate="" id="evaporationChart"></cwn-date-linechart>
      </div>

      <div id="storage" style="display:none">
        <h4>Storage</h4>
        <cwn-date-linechart id="storageChart"></cwn-date-linechart>
      </div>


      <div>
        <cwn-output-info id="outputs"></cwn-output-info>
      </div>

    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : 'cwn-climate-info',

    properties : {
      feature : {
        type : Object,
        observer : 'featureObserver'
      }
    },

    ready : function() {
      // Elevation / Area / Capacity charts
      this.eacChart = {
        type : 'ComboChart',
        cols : [
          {id: 'capacity', label: 'capacity', type: 'number'},
          {id: 'elevation', label: 'elevation', type: 'number'},
          {id: 'area', label: 'area', type: 'number'},
          {id: 'initial', type: 'number', label: 'initial'},
          {id: 'tooltip', type: 'string', role:'tooltip'}
        ],
        data : [],
        options : {
          hAxis : {
            title : 'Capacity (kAF)'
          },
          vAxes : [
            {title:'Elevation (ft)'}, // axis 0
            {title:'Area (ac)'} // Axis 1
          ],
          seriesType: "bars",
          series :{
            0: {type: "line", targetAxisIndex:0},
            1: {type: "line", targetAxisIndex:1},
            2: {targetAxisIndex: 0},
          },
          interpolateNulls : true,
          legend : {
            position: 'top'
          }
        }
      };
    },

    featureObserver : function() {

      this.climateLoading = false;
      this.inflows = [];
      this.charts = {};

      this.render();
    },

    render : function() {
      if( !this.feature ) {
        $(this).parent().hide();
        return;
      }

      this.$.outputs.update(this.feature);

      this.$.eacChartRoot.innerHTML = '';
      this.nodata = false;

      var props = this.feature.properties;
      if( (props.extras && props.extras.flow) || (props.extras && props.extras.inflows) || props.el_ar_cap || (props.extras && props.extras.evaporation) ) {
        $(this).parent().css('display','block');
      } else {
        this.nodata = true;
        $(this).parent().hide();
        this.fire('climate-ready');
        return;
      }

      this.renderInflows();
      this.renderEvaporation();
      this.renderStorage();

      this.eacChart.data = [];
      this.renderElArCap();
      this.fire('climate-ready');
    },

    renderElArCap : function() {
      if( !this.feature.properties.el_ar_cap ) return;
      var el_ar_cap = this.feature.properties.el_ar_cap;

      var max = 0;
      var elevationCol = 0, capacityCol = 0, areaCol = 0;

      for( var i = 0; i < el_ar_cap.length; i++ ) {
        // make sure col labels are set correctly
        if( i == 0 ) {
          for( var j = 0; j < el_ar_cap[i].length; j ++ ) {
            if( el_ar_cap[i][j].toLowerCase() == 'elevation' ) elevationCol = j;
            else if( el_ar_cap[i][j].toLowerCase() == 'capacity' ) capacityCol = j;
            else if( el_ar_cap[i][j].toLowerCase() == 'area' ) areaCol = j;
          }
        } else {
          this.eacChart.data.push([
            el_ar_cap[i][capacityCol],
            el_ar_cap[i][elevationCol],
            el_ar_cap[i][areaCol],
            null,
            null
          ]);
        }

        if( el_ar_cap[i][elevationCol] > max ) max = el_ar_cap[i][elevationCol];
      }

      if( this.feature.properties.initialstorage ) {
        this.eacChart.data.push([
          this.feature.properties.initialstorage,
          null,
          null,
          max,
          'Initial: '+this.feature.properties.initialstorage
        ]);
      }

      this.eacChart.data.sort(function(a,b){
        if( a[capacityCol] > b[capacityCol] ) return 1;
        if( a[capacityCol] < b[capacityCol] ) return -1;
        return 0;
      });

      this.stampEacChart();
    },

    renderInflows : function() {
      this.$.inflows.style.display = 'none';

      CWN.ds.loadExtras(this.feature.properties.prmname, function(resp){
        if( resp.inflows ) {
          this.hasInflows = true;
          this.$.inflowCharts.innerHTML = '';

          for( var name in resp.inflows  ) {
            var chart = document.createElement('cwn-date-linechart');
            chart.label = (resp.inflows[name].description || name || ''),
            chart.data = resp.inflows[name].inflow;

            this.$.inflowCharts.appendChild(chart);
          }

          this.$.inflows.style.display = 'block';
        } else {
          this.$.inflows.style.display = 'none';
        }
      }.bind(this));
    },

    renderEvaporation : function() {
      CWN.ds.loadExtras(this.feature.properties.prmname, function(resp){
        var evaporation = resp.evaporation;
        if( evaporation ) {
          this.hasEvaporation = true;
          this.$.evaporationChart.update(evaporation);
          this.evaporationData = evaporation;
          this.$.evaporation.style.display = 'block';
        } else {
          this.$.evaporation.style.display = 'none';
        }
      }.bind(this));
    },

    renderStorage : function() {
      CWN.ds.loadExtras(this.feature.properties.prmname, function(resp){
        var storage = resp.storage;
        if( storage ) {
          this.$.storageChart.update(storage);
          this.$.storage.style.display = 'block';
        } else {
          this.$.storage.style.display = 'none';
        }
      }.bind(this));
    },

    stampEacChart : function() {
      if( !this.eacChart ) return;

        if( this.eacChart.data.length == 0 ) {

            this.charts.eacChart = null;
            this.$.eacChartRoot.innerHTML = '';

        } else if( !this.charts.eacChart ) {

            this.charts.eacChart = this._stamp(this.$.eacChart, 'cwn-linechart', this.eacChart);
            this.$.eacChartRoot.appendChild(this.charts.eacChart.root);

            this.async(function(){
                this.$.eacChartRoot.querySelector('cwn-linechart').update(this.eacChart.data);
            });
        }
    },

    // dom-template: http://polymer.github.io/polymer/
    // doesn't seem to take variables when you stamp now :(
    // setting manually.
    _stamp : function(ele, query, data) {
      var template = ele.stamp();

      if( query && data ) {
        var newEle = template.root.querySelector(query);
        if( newEle ) {
          for( var key in data ) newEle[key] = data[key];
        }
      }

      return template;
    }

  });
</script>
<dom-module id="cwn-flow-info" assetpath="elements/cwn-info-page/">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>

    <h4>Aggregate Flow</h4>

    <div id="loading"><i class="fa fa-circle-o-notch fa-spin"></i> Loading...</div>

    <cwn-date-linechart id="flowChart"></cwn-date-linechart>
    <div class="help-block" style="text-align:right">Click chart point to inspect</div>

    <cwn-date-linechart id="differenceChart" style="display:none"></cwn-date-linechart>

    <div class="modal fade" id="popup">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-label="Close" data-dismiss="modal"><span aria-hidden="true"></span></button>
            <h4 class="modal-title" id="title">Details</h4>
          </div>
          <div class="modal-body">
            <div id="colChartRoot" style="height: 500px"></div>
          </div>
        </div>
      </div>
    </div>


  </template>
  <script>
    Polymer({
      is: 'cwn-flow-info',

      ready : function() {
        this.popup = $(this.$.popup).remove();
        $('body').append(this.popup);
        this.popup.modal({show: false});
      },

      update : function(feature) {
        if( this.feature && feature.properties.prmname == this.feature.properties.prmname ) {
          return;
        }

        this.feature = feature;

        //this.$.flow.style.display = 'none';
        this.net = false;
        var props = this.feature.properties;
        this.$.differenceChart.style.display = 'none';

        if( props.type == 'Region Link' ) {
          $(this).parent().show();
          this.$.loading.style.display = 'block';
          this.loadLinkAggregate();
       } else if( props.type == 'Region' ) {
          $(this).parent().show();
          this.$.loading.style.display = 'block';
          this.loadAggregate();
       } else if( props.extras &&
          (props.extras.inflow || props.extras.flow || props.extras.sinks || props.extras.evaporation) ) {
            $(this).parent().show();
            this.$.loading.style.display = 'block';
            this.load();
        } else {
          $(this).parent().hide();
          this.$.loading.style.display = 'none';
        }
      },

      load : function() {
        CWN.ds.loadExtras(this.feature.properties.prmname, function(resp){
          this.$.loading.style.display = 'none';
          this.data = resp;
          var positive = [];
          var negative = [];

          if( resp.inflows ) {
            for( var name in resp.inflows  ) {
              positive.push(resp.inflows[name].inflow);
            }
          }
          if( resp.sinks ) {
            for( var i = 0; i < resp.sinks.length; i++ ) {
              for( var name in resp.sinks[i] ) {
                negative.push(resp.sinks[i][name].flow);
              }
            }
          }
          if( resp.evaporation ) {
            negative.push(resp.evaporation);
          }
          if( resp.flow ) {
            negative.push(resp.flow);
          }

          if( positive.length + negative.length <= 1 ) {
            $(this).parent().hide();
            return;
          }

          var data = {}, chart;
          for( var i = 0; i < positive.length; i++ ) {
            chart = positive[i];
            for( var j = 1; j < chart.length; j++ ) {
              if( data[chart[j][0]] ) {
                data[chart[j][0]] += chart[j][1];
              } else {
                data[chart[j][0]] = chart[j][1];
              }
            }
          }

          for( var i = 0; i < negative.length; i++ ) {
            chart = negative[i];
            for( var j = 1; j < chart.length; j++ ) {
              if( data[chart[j][0]] ) {
                data[chart[j][0]] += -1 * chart[j][1];
              } else {
                data[chart[j][0]] = -1 * chart[j][1];
              }
            }
          }

          var chartData = [['Date', 'Value']];
          for( var date in data ) {
            chartData.push([date, data[date]]);
          }

          this.$.flowChart.options = {
            isStacked : true,
            height: 500
          }

          this.$.flowChart.setHeight(500);
          this.$.flowChart.type = 'AreaChart';
          this.$.flowChart.onClick = this.onNodeChartClick.bind(this);
          this.$.flowChart.update(chartData);

        }.bind(this));
      },

      loadAggregate : function() {
        $.get('/regions/aggregateRegion?region='+this.feature.properties.prmname, function(resp) {
          this.data = resp;
          this.$.loading.style.display = 'none';
          this.$.differenceChart.style.display = 'block';

          var data = [['Date','Amplitude Loss', 'Local Sinks', 'Evaporation', 'Link Outflows', '', 'Local Inflows', 'Link Inflows']];
          var diffData = [['Date', 'Difference']];

          for( var date in resp.aggregate ) {

            var localInflow = this.data.aggregate[date].inflows || 0;
            var linkInflow = this.data.aggregate[date].regionLinkInflow || 0;

            var sink = this.data.aggregate[date].sinks ? this.data.aggregate[date].sinks*-1 : 0;
            var evaporation = this.data.aggregate[date].evaporation ? this.data.aggregate[date].evaporation*-1 : 0;
            var linkOutflow = this.data.aggregate[date].regionLinkOutflow ? this.data.aggregate[date].regionLinkOutflow*-1 : 0;
            var ampLoss = this.data.aggregate[date].amplitudeLoss ? this.data.aggregate[date].amplitudeLoss*-1 : 0;

            data.push([
              date,
              ampLoss,
              sink,
              evaporation,
              linkOutflow,
              (sink + evaporation + linkOutflow + ampLoss)*-1,
              localInflow,
              linkInflow
            ]);
            diffData.push([
              date,
              ampLoss + sink + evaporation + linkOutflow + localInflow + linkInflow
            ]);
          }

          this.$.flowChart.options = {
            isStacked : true,
            height: 500,
            legend : {
              position: 'right'
            },
            series: {
              4: {
                  visibleInLegend: false,
                  areaOpacity : 0,
                  color : 'transparent'
              }
            }
          }

          this.$.flowChart.setHeight(500);
          this.$.flowChart.onClick = this.onRegionChartClick.bind(this);
          this.$.flowChart.type = 'AreaChart';
          this.$.flowChart.update(data);

          this.$.differenceChart.options = {
            isStacked : true,
            height: 400,
            legend : {
              position: 'right'
            }
          }

          this.$.differenceChart.setHeight(500);
          this.$.differenceChart.onClick = this.onRegionChartClick.bind(this);
          this.$.differenceChart.type = 'AreaChart';
          this.$.differenceChart.update(diffData);

        }.bind(this));
      },

      loadLinkAggregate : function() {
        $.get('/regions/aggregateLinks?n1='+this.feature.properties.origin+'&n2='+this.feature.properties.terminus, function(resp) {
          this.$.loading.style.display = 'none';
          this.data = resp.data;

          this.fire('region-link-update', this.data);

          var data = [['Date','Flow', 'Amplitude Loss', 'Sinks']];

          var total = {};
          for( var date in this.data[0].data ) {
            total[date] = {
              flow : (this.data[0].data[date].flow || 0) - (this.data[1].data[date] ? this.data[1].data[date].flow || 0 : 0),
              amplitudeLoss : -1*((this.data[0].data[date].amplitudeLoss || 0) + (this.data[1].data[date] ? this.data[1].data[date].amplitudeLoss || 0 : 0)),
              sinks : -1*((this.data[0].data[date].sinks || 0) + (this.data[1].data[date] ? this.data[1].data[date].sinks || 0 : 0))
            }
          }

          for( var date in total ) {
            data.push([
              date,
              total[date].flow,
              total[date].amplitudeLoss,
              total[date].sinks
            ]);
          }

          this.$.flowChart.options = {
            title: 'Rendered as '+this.data[0].origin+' to '+this.data[0].terminus,
            isStacked : true,
            height: 500,
            legend : {
              position: 'right'
            }
          }

          this.$.flowChart.setHeight(500);
          this.$.flowChart.onClick = this.onLinkChartClick.bind(this);
          this.$.flowChart.type = 'AreaChart';
          this.$.flowChart.update(data);

        }.bind(this));
      },

      getDateDataPoint : function(data, date) {
        for( var i = 0; i < data.length; i++ ) {
          if( data[i][0] == date ) return data[i][1];
        }
        return 0;
      },

      onNodeChartClick : function(e) {
        var date = e[0];

        this.popup.modal('show');
        this.$.colChartRoot.innerHTML = '';

        var data = [];
        var diff = 0, dp;
        if( this.data.inflows ) {
          for( var name in this.data.inflows  ) {
            dp = this.getDateDataPoint(this.data.inflows[name].inflow, date);

            data.push(['Inflow: '+name, dp,'#4caf50' ]);
            diff += dp;
          }
        }
        if( this.data.sinks ) {
          for( var i = 0; i < this.data.sinks.length; i++ ) {
            for( var name in this.data.sinks[i] ) {
              dp = this.getDateDataPoint(this.data.sinks[i][name].flow, date);

              data.push(['Sink: '+this.data.sinks[i][name].description, -1*dp, '#e51c23' ]);
              diff -= dp;
            }
          }
        }
        if( this.data.evaporation ) {
          dp = this.getDateDataPoint(this.data.evaporation, date);

          data.push(['Evaporation', -1*dp, '#e51c23']);
          diff -= dp;
        }
        if( this.data.flow ) {
          dp = this.getDateDataPoint(this.data.flow, date);

          data.push(['Flow', -1*dp, '#e51c23']);
          diff -= dp;
        }

        data.sort(function(a, b){
          if( a[1] < b[1] ) return -1;
          if( b[1] < a[1] ) return 1;
          return 0;
        });

        data.splice(0,0,['Type', 'Value',{ role: "style" }]);
        data.push(['Difference', diff, '#ff9800']);

        var dt = google.visualization.arrayToDataTable(data);
        var options = {
          title: date,
          height: 500,
          legend: { position: 'none' },
        };

        setTimeout(function(){
            var chart = new google.visualization.ColumnChart(this.$.colChartRoot);
            chart.draw(dt, options);
        }.bind(this), 500);

      },

      onLinkChartClick : function(e) {
        var date = e[0];

        this.popup.modal('show');
        this.$.colChartRoot.innerHTML = '';

        var r1 = {
          flow : 0,
          ampLoss : 0,
          sinks : 0
        }
        var r2 = {
          flow : 0,
          ampLoss : 0,
          sinks : 0
        }

        if( this.data[0].data[date] ) {
          r1.flow = this.data[0].data[date].flow || 0;
          r1.ampLoss = this.data[0].data[date].ampLoss || 0;
          r1.sinks = this.data[0].data[date].sinks || 0;
        }
        if( this.data[1].data[date] ) {
          r2.flow = this.data[1].data[date].flow || 0;
          r2.ampLoss = this.data[1].data[date].ampLoss || 0;
          r2.sinks = this.data[1].data[date].sinks || 0;
        }

        var data = [
          ['Type', 'Value'],
          ['r1 to r2: Flow', r1.flow],
          ['r1 to r2: Amplitude Loss', r1.ampLoss],
          ['r1 to r2: Sinks', r1.sinks],
          ['r2 to r1: Flow', r2.flow],
          ['r2 to r1: Amplitude Loss', r2.ampLoss],
          ['r1 to r2: Sinks', r2.sinks],
          ['Flow Difference (r1 - r2)', r1.flow - r2.flow]
        ];

        var dt = google.visualization.arrayToDataTable(data);
        var options = {
          title: date+': r1='+this.data[0].origin+', r2='+this.data[0].terminus,
          height: 500,
          legend: { position: 'none' },
        };

        setTimeout(function(){
            var chart = new google.visualization.ColumnChart(this.$.colChartRoot);
            chart.draw(dt, options);
        }.bind(this), 500);
      },

      onRegionChartClick : function(e) {
        var date = e[0];

        this.popup.modal('show');
        this.$.colChartRoot.innerHTML = '';

        var localInflow = this.data.aggregate[date].inflows || 0;
        var linkInflow = this.data.aggregate[date].regionLinkInflow || 0;
        var evaporation = this.data.aggregate[date].evaporation ? this.data.aggregate[date].evaporation*-1 : 0;
        var sinks = this.data.aggregate[date].sinks ? this.data.aggregate[date].sinks*-1 : 0;
        var linkOutflow = this.data.aggregate[date].regionLinkOutflow ? this.data.aggregate[date].regionLinkOutflow*-1 : 0;
        var ampLoss = this.data.aggregate[date].amplitudeLoss ? this.data.aggregate[date].amplitudeLoss*-1 : 0;

        var data = [
          ['Local Inflows', localInflow,'#4caf50'],
          ['Link Inflows', linkInflow,'#4caf50'],
          ['Local Sinks', sinks, '#e51c23'],
          ['Evaporation', evaporation, '#e51c23'],
          ['Link Outflows', linkOutflow, '#e51c23'],
          ['Amplitude Loss', ampLoss, '#e51c23']
        ];

        data.sort(function(a, b){
          if( a[1] < b[1] ) return -1;
          if( b[1] < a[1] ) return 1;
          return 0;
        });
        data.splice(0,0,['Type', 'Value',{ role: "style" }]);
        data.push(['Difference', localInflow + linkInflow+evaporation + linkOutflow + ampLoss + sinks, '#ff9800']);

        var dt = google.visualization.arrayToDataTable(data);
        var options = {
          title: date,
          height: 500,
          legend: { position: 'none' },
        };

        setTimeout(function(){
            var chart = new google.visualization.ColumnChart(this.$.colChartRoot);
            chart.draw(dt, options);
        }.bind(this), 500);
      }

    });
  </script>
</dom-module>
<dom-module id="cwn-sink-info" assetpath="elements/cwn-info-page/">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>

    <h4 id="title"></h4>

    <div class="row">
      <div class="col-sm-6">
        <h5 class="page-header">Bounds</h5>
        <div id="boundsRoot"></div>
      </div>
      <div class="col-sm-6">
        <h5 class="page-header">Costs</h5>

        <div>
          <div hidden$="{{!showMonthlyVariableCost}}">

            <div class="btn-group" id="monthSelector">
              <template is="dom-repeat" items="{{months}}">
                <a class="btn btn-xs btn-primary" on-click="setMonth">{{item}}</a>
              </template>
            </div>

            <cwn-linechart id="lineChart" label="{{costChartLabel}}" xlabel="Capacity (kAF)" ylabel="Cost ($/kAF)" animate="true">
            </cwn-linechart>
          </div>

          <div hidden$="{{!showConstantCost}}">
            <h5>Constant: $<span>{{costs.cost}}</span></h5>
          </div>

        </div>
        <div id="noCosts"></div>
      </div>
    </div>

    <h5 class="page-header">Flow</h5>
    <cwn-date-linechart id="chart" animate=""></cwn-date-linechart>
    <div id="noFlow"></div>
  </template>
  <script>
    Polymer({
      is: 'cwn-sink-info',

      ready : function() {
        this.months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      },

      render : function(name, sink) {
        this.$.title.innerHTML = name + (sink.description ? ' <small>'+sink.description+'</small>' : '');
        this.sink = sink;

        this.renderBounds();
        this.renderCosts();

        if( this.sink.flow ) {
          this.$.chart.style.display = 'block';
          this.$.noFlow.innerHTML = '';
          this.$.chart.update(this.sink.flow);
        } else {
          this.$.chart.style.display = 'none';
          this.$.noFlow.innerHTML = 'No Data';
        }

      },

      renderCosts : function() {
        this.noCostData = true;
        this.costsMonths = [];
        this.costs = {
          label : '',
          data : {},
          cost : 0, // for constant costs
          selected : 0
        };

        this.showMonthlyVariableCost = false;
        this.showConstantCost = false;

        if( this.sink.costs ) {
          this.renderCostData(this.sink.costs);
          this.$.noCosts.innerHTML = '';
        } else {
          this.$.noCosts.innerHTML = 'No Data';
        }

      },

      renderCostData : function(d) {
        this.costs.label = d.type;


        if( d.type == 'Constant' ) {

          this.showConstantCost = true;
          this.costs.cost = d.cost;


        } else if( d.type == 'Monthly Variable' ) {

          this.showMonthlyVariableCost = true;

          this.costsMonths = {};
          var costArr;
          if( !d.costs ) return;

          if( d.costs.data ) {
            this.costMonths = d.costs.data;
          } else {
            this.costMonths = d.costs;
          }
          this.showMonthlyVariableCost = true;
          this.$.monthSelector.style.display = 'inline-block';

          this.setMonth('JAN');

        } else if( d.type == 'Annual Variable' ) {

          if( !d.costs ) return;

          var keys = Object.keys(d.costs);
          if( keys.length == 0 ) return;
          if( keys.length > 1 ) {
            console.log('! cwn-cost-info found multiple keys for costs data');
            console.log(keys);
          }

          this.costChartLabel = d.type+': '+keys[0];
          this.costChartData = d.costs[keys[0]];
          this.$.lineChart.update(this.costChartData);
          this.showMonthlyVariableCost = true;
          this.$.monthSelector.style.display = 'none';

        } else {
          alert('Unknown cost type: '+d.type);
        }
      },

      setMonth : function(month) {
        if( typeof month == 'object' ) month = month.currentTarget.innerHTML;
        month = month.toUpperCase();

        this.costChartLabel = this.costs.label+' - '+month;
        this.costChartData = this.costMonths[month];

        // redraw chart
        this.$.lineChart.update(this.costChartData);
      },

      renderBounds : function() {
        if( !this.sink.bounds ) {
          this.$.boundsRoot.innerHTML = 'None';
          return;
        }
        if( this.sink.bounds.length == 0 ) {
          this.$.boundsRoot.innerHTML = 'None';
          return;
        }
        this.$.boundsRoot.innerHTML = '';

        for( var i = 0; i < this.sink.bounds.length; i++ ) {
          var chart = document.createElement('cwn-bound-chart');
          this.$.boundsRoot.appendChild(chart);
          chart.render(this.sink.bounds[i]);
        }

      }
    });
  </script>
</dom-module>
<dom-module id="cwn-info-page" assetpath="elements/cwn-info-page/">


    <template>
      <style>
        :host {
          display: block;
          overflow-x: hidden;
          margin-bottom: 100px;
        }
        .card {
          margin: 10px 10px 10px 10px;
          box-shadow: 0 0 5px #888;
          padding: 15px;
        }
      </style>

      <div class="card" hidden$="{{loading}}" style="margin-top: 25px">
        <cwn-node-info id="nodeInfo" feature="{{feature}}" ds="{{ds}}" leaflet="{{map}}">
        </cwn-node-info>
      </div>

      <!-- End Header Card -->
      <div class="row">
        <div class="col-md-6" id="climateCard">

          <!-- Start Climate -->
          <div class="card">
            <cwn-climate-info id="climate" feature="{{feature}}" on-climate-ready="onClimateReady"></cwn-climate-info>
          </div>
          <!-- End Climate -->

        </div>
        <div class="col-md-6" id="costCard">

          <!-- Start Costs -->
          <div class="card">
            <cwn-cost-info id="costs" feature="{{feature}}" on-cost-ready="onCostsReady"></cwn-cost-info>
          </div>
          <!-- End Costs -->

        </div>
      </div>

      <div class="card" id="sinks">
        <h2 class="page-header">Sinks</h2>
        <div id="sinksRoot"></div>
      </div>

      <div class="card">
        <cwn-flow-info id="flow" on-region-link-update="onRegionLinkUpdate"></cwn-flow-info>
      </div>

      <div class="card" id="readme" style="display:none">
        <h4 class="page-header">README</h4>
        <div id="readmeMarkdown"><h2>Loading</h2></div>
      </div>

      <cwn-dateslider id="dateslider" start="1920-01-01" on-values-changed="updateDateFilters">
      </cwn-dateslider>


    </template>
</dom-module>
<script>
Polymer({
    is : 'cwn-info-page',

    ready : function() {
      this.feature = null;

      //this.hack = '';
      //this.islocal = false;
      //this.tableProperties = ['prmname'];

      // loading flags
      this.costLoadError = false;
      this.costLoading = false;
      this.loading = false;

        // have to do long lookup right now, is there are better way?
      this.origins = [];
      this.terminals = [];

      // render data.  Data in a format ready to draw above
      this.map = {};

      // date filtering
      this.filters = {
        start : null,
        stop : null
      },

      // dom controller stuff
      this.hasTimeSeries = false;
    },

    init : function(map) {
      this.map = map;
      this.islocal = CWN.ds.islocal;

      CWN.ds.on('load', this.onLoad.bind(this));
    },

    onLoad : function() {
      if( CWN.ds.loading ) return;

      var loc = window.location.hash.replace('#','').split('/');
      if( loc[0] == 'info' && loc.length > 1) {
        if( this.feature && this.feature.prmname == loc[1] ) {
          this.update();
        } else {
          this.setFeature(loc[1]);
        }
      }
    },

    setFeature : function(prmname) {
      if( this.prmname == prmname ) return;
      if( prmname ) this.prmname = prmname;

      this.costsReady = false;
      this.climateReady = false;

      if( CWN.ds.lookupMap[prmname] ) {
        this.feature = CWN.ds.lookupMap[prmname];
      } else if( CWN.ds.regionLookupMap[prmname] ) {
        this.setRegion(prmname);
      } else {
        // see if this is a region to feature
        this.setRegionToRegion(prmname);
      }

      this.update();
    },

    onClimateReady : function() {
      this.climateReady = true;
      this.checkLayout();
    },

    onCostsReady : function() {
      this.costsReady = true;
      this.checkLayout();
    },

    checkLayout : function() {
      if( !this.costsReady || !this.climateReady ) return;

      if( this.$.costs.nodata && !this.$.climate.nodata ) {
        this.$.costCard.style.display = 'none';
        this.$.climateCard.className = 'col-md-12';
      } else if( !this.$.costs.nodata && this.$.climate.nodata ) {
        this.$.climateCard.style.display = 'none';
        this.$.costCard.className = 'col-md-12';
      } else {
        this.$.climateCard.style.display = 'block';
        this.$.costCard.style.display = 'block';

        this.$.climateCard.className = 'col-md-6';
        this.$.costCard.className = 'col-md-6';
      }

      // HACKy
      setTimeout(function(){
        $(window).trigger('resize');
      }, 500);
    },

    setRegion : function(prmname) {
      var region = CWN.ds.regionLookupMap[prmname];

      var nodes = {};
      var origins = {};
      var terminals = {};
      var node;

      for( var key in CWN.ds.lookupMap ) {
        node = CWN.ds.lookupMap[key].properties;
        if( !node ) continue;

        if( node.type !== 'Diversion' && node.type !== 'Return Flow' ) {
          if( node.regions && node.regions.indexOf(prmname) > -1 ) {
            nodes[node.prmname] = 1;
          }
        }
      }

      for( var key in CWN.ds.lookupMap ) {
        node = CWN.ds.lookupMap[key].properties;
        if( !node ) continue;
        if( node.type === 'Diversion' || node.type === 'Return Flow' ) {

          if( nodes[node.origin] && nodes[node.terminus] ) continue; // ignore internal

          if( nodes[node.origin] ) {
            terminals[node.terminus] = {
              link_prmname : node.prmname,
              prmname : node.terminus
            }
          } else if( nodes[node.terminus] ) {

            origins[node.origin] = {
              link_prmname : node.prmname,
              prmname : node.origin
            };
          }
        }
      }

      arr = [];
      for( var key in origins ) {
        arr.push(origins[key]);
      }
      origins = arr;

      arr = [];
      for( var key in terminals ) {
        arr.push(terminals[key]);
      }
      terminals = arr;


      this.feature = {
        properties : {
          prmname : prmname,
          type : 'Region',
          nodes : Object.keys(nodes),
          origins : origins,
          terminals : terminals,
          parents : region.parents,
          subregions : region.subregions,
          repo : region.geo.properties.repo,
          label : region.geo.properties.name,
          description : region.geo.properties.region
        }
      };
    },

    setRegionToRegion : function(prmname) {
      var parts = prmname.split('--');

      if( parts.length == 0 ) {
        this.feature = null;
        return;
      }

      var node = {
        properties : {
          prmname : prmname,
          origin : null,
          terminus : null,
          type : 'Region Link'
        }
      };

      if( CWN.ds.lookupMap[parts[0]] ) {
        node.properties.origin = CWN.ds.lookupMap[parts[0]].properties.prmname;
      } else if( CWN.ds.regionLookupMap[parts[0]] ) {
        node.properties.origin = CWN.ds.regionLookupMap[parts[0]].name;
      }

      if( CWN.ds.lookupMap[parts[1]] ) {
        node.properties.terminus = CWN.ds.lookupMap[parts[1]].properties.prmname;
      } else if( CWN.ds.regionLookupMap[parts[1]] ) {
        node.properties.terminus = CWN.ds.regionLookupMap[parts[1]].name;
      }

      if( !node.properties.origin || !node.properties.terminus ) {
        this.feature = null;
        return;
      }

      this.feature = node;
    },

    update : function() {
      if( CWN.ds.loading ) return;

      if( this.feature == null ) return alert('Feature not found');

      this.hasOutputs = false;

      //this.$.outputs.update(this.feature);
      this.$.flow.update(this.feature);

      if( this.feature.properties.hasOutputs ) {
        this.hasOutputs = true;
      }

      this.updateSinks();
      this.updateReadme();
      this.updateDateSliderVisibility();

      this.async(function(){
        this.$.dateslider.resize();
      });
    },

    updateSinks : function() {
      if( this.feature.properties.extras && this.feature.properties.extras.sinks ) {
        this.$.sinks.style.display = 'block';
        this.$.sinksRoot.innerHTML = '';

        CWN.ds.loadExtras(this.feature.properties.prmname, function(resp){
          if( !resp.sinks ) return;
          for( var i = 0; i < resp.sinks.length; i++ ) {
            for( var name in resp.sinks[i] ) {
              var sinkEle = document.createElement('cwn-sink-info');
              this.$.sinksRoot.appendChild(sinkEle);
              sinkEle.render(name, resp.sinks[i][name]);
            }
          }
        }.bind(this));


      } else {
        this.$.sinks.style.display = 'none';
      }
    },

    updateReadme : function() {
        if( this.feature.properties.extras && this.feature.properties.extras.readme ) {
          this.$.readme.style.display = 'block';
          CWN.ds.loadExtras(this.feature.properties.prmname, function(resp){
            this.$.readmeMarkdown.innerHTML = marked(resp.readme);
            $(this.$.readmeMarkdown).find('h2').css('fontSize','28px');
          }.bind(this));
          return;
        }

        this.$.readme.style.display = 'none';
        return;
    },

    updateDateFilters : function(e) {
      var eles = this.querySelectorAll('cwn-date-linechart');

      for( var i = 0; i < eles.length; i++ ) {
        eles[i].startDate = e.detail.start;
        eles[i].stopDate = e.detail.end;

        eles[i].update();
      }

      this.notifyPath('filters.start', e.detail.start);
      this.notifyPath('filters.stop', e.detail.end);
    },

    updateDateSliderVisibility : function() {
      this.$.dateslider.setFeature(this.feature);
    },

    onRegionLinkUpdate : function(e) {
      this.$.nodeInfo.setRegionLinkInfo(e.detail);
    }
});
</script>
<dom-module id="cwn-graph" assetpath="elements/">
  <style>
    #sigma {
        width: 100%;
        height: 100%;
        display: block;
    }
    .maxDepth {
        position: absolute;
        left: 0;
        bottom: 0;
        z-index: 100;
        background-color: rgba(220,220,220,.85);
        color: #888;
        padding: 5px;
        border-radius: 0 3px 0 0;
        box-shadow: 0 0 5px #333;
    }
    .maxDepth input {
        width: 60px !important;
    }
    table td {
        padding: 3px !important;
    }

    input[type="number"] {
      background-color: #eee;
    }
  </style>

  <template>

      <div id="sigma"></div>

      <div class="maxDepth">
          <table>
              <tbody><tr>
                  <td>Max Depth:</td>
                  <td><input type="number" value$="{{maxDepth}}" class="form-control" on-change="maxUpdate"></td>
              </tr>
              <tr>
                  <td>Negative Depth: </td>
                  <td><input type="number" value$="{{negativeDepth}}" class="form-control" on-change="minUpdate"></td>
              
              </tr><tr>
                  <td><a href="#map">Back to Map</a></td>
                  <td></td>
              
          </tr></tbody></table>
      </div>

      <cwn-popup id="popup" nofooter="">
          <div class="popup-body">

            <table style="margin: 0 auto">
              <tbody><tr>
                <td>
                  <cwn-app-icon type$="{{popupType}}" width="72" height="72" fillfromtype="true" style="margin:35px 15px 0 15px"></cwn-app-icon>
                </td><td>
                  <h3>{{popupLabel}}</h3>
                  <div><b>{{popupType}}</b></div>
                </td>
              </tr>
            </tbody></table>


            <div style="text-align:center">
              <div style="padding: 10px 10px 0 10px; color: #888">{{popupDescription}}</div>

              <div id="regions"></div>
            </div>

            <div style="border-top: 1px solid #eee; text-align:center; margin-top: 15px;padding-top: 15px">
              <div style="margin: 0 auto; display: inline-block; text-align: left">
                <div>
                  <a class="btn btn-link" href="{{graphLink}}" on-click="hide">
                          <i class="fa fa-chevron-circle-up fa-fw"></i> Set as Graph Root</a>
                </div>
                <div>
                    <a class="btn btn-link" href="{{infoLink}}" on-click="hide">
                      <i class="fa fa-info fa-fw"></i> View Info</a>
                </div>
                <div>
                    <a class="btn btn-link" on-click="goTo">
                      <i class="fa fa-map-marker fa-fw"></i> Show on Map</a>
                </div>
                <div id="githubLink"></div>
              </div>
            </div>


              <!--<div class="layout horizontal">
                  <div>
                      <cwn-app-icon type="{{popupNode.properties.type}}" width="96" height="96"></cwn-app-icon>
                  </div>
                  <div flex>
                      <div style="padding-left:25px">
                          <div>{{popupNode.properties.description}}</div>
                          <h4 style="margin-top: 30px">Actions</h4>
                          <ul>
                              <li><a
                                      class="btn btn-link"
                                      href="{{graphLink}}"
                                      on-click="hide">
                                      Set as Graph Root</a>
                              </li>
                              <li><a class="btn btn-link" href="{{infoLink}}" on-click="hide">View Info</a></li>
                              <li><a class="btn btn-link" on-click="goTo">View on Map</a></li>
                          </ul>
                      </div>
                  </div>
              </div>-->
          </div>
      </cwn-popup>
  </template>
</dom-module>

<script>
    Polymer({
        is : 'cwn-graph',


        properties : {
            prmname : {
                type : String,
                observer : 'update'
            },
            popupNode : {
                observer : 'setPopupInfo'
            }
        },

        ready : function() {
            this.maxDepth = '6';
            this.negativeDepth = '0';
            this.graph = null;
            this.graphJson = {};
            this.updateTimer = -1;
            this.prmname = '';
            this.popupNode = {};

            this.nodeLevels = {};
            this.negativeLevels = {};
            this.cnodes = [];
            this.graphLink = '';
            this.infoLink = '';

            this.popupLabel = '';
            this.popupDescription = '';
            this.popupType = '';
        },

        attached : function() {
            //this.$.popup.target = this;
            $(window).on('hashchange', this.changeNode.bind(this));
            this.changeNode();

            this.async(function(){
                this.$.popup.init();
            });
        },

        setPopupInfo : function() {
            if( !this.popupNode ) return;
            if( !this.popupNode.properties ) return;
            var props = this.popupNode.properties;


            this.graphLink = '#graph/'+props.prmname;
            this.infoLink = '#info/'+props.prmname;
            this.$.githubLink.innerHTML = '<a class="btn btn-link" href="'+props.repo.github+'" '+
              ' target="_blank"><i class="fa fa-github fa-fw"></i> Show on GitHub</a>';

            this.$.regions.innerHTML = props.regions ?
                '<i>'+props.regions.join(' <i class="fa fa-arrow-right"></i> ')+'</i>' : '';

            this.popupLabel = props.prmname.replace(/_/g, ' ');
            this.popupDescription = props.description || '';
            this.popupType = props.type;
        },

        changeNode : function() {
            if( !this.$ ) return;

            var loc = window.location.hash.replace('#','').split('/');
            if( loc[0] == 'graph' ) {
                this.async(function(){
                    this.prmname = loc.length == 1 ? CWN.ds.data.nodes[0] : loc[1];
                });

                if( !this.graph ) this.render();

                setTimeout(function(){
                    this.update();

                    // make sure it was drawn correctly
                    setTimeout(function(){
                         this.graph.refresh();
                    }.bind(this), 500);
                    setTimeout(function(){
                         this.graph.refresh();
                    }.bind(this), 1000);
                }.bind(this), 200);
            }
        },

        update : function() {
            if( !CWN.ds ) return;
            if( this.prmname == '' ) return;

            this.reset();

            var t1 = new Date().getTime();

            this.walk(this.prmname, 0, 'forward');

            var t2 = new Date().getTime();

            // check max depth
            if( this.negativeDepth && this.negativeDepth.length > 0 ) {
                if( 0 < parseInt(this.negativeDepth) ) {
                    this.walk(this.prmname, 0, 'backward');
                }
            }

            var t3 = new Date().getTime();

            // make sure all links for all node are in tree
            this._addMissingLinks();

            var t4 = new Date().getTime();
            console.log('positive walk time: '+(t4-t1)+'ms');
            console.log('negative walk time: '+(t4-t2)+'ms');
            console.log('missing check time: '+(t4-t3)+'ms');


            this.setPositions();
        },

        reset : function() {
            this.graphJson = {
                nodes : [],
                edges : []
            };
            this.nodeLevels = {};
            this.negativeLevels = {};
            this.cnodes = [];
        },

        walk : function(prmname, level, direction) {
            // has this node already been added to the graph?
            //if( this.cnodes.indexOf(prmname) != -1 ) {
                // if we are walking backward, we need to process the first node again
            //    if( direction == 'forward' || level != 0 ) return;
            //}

            // does the node actually exist?
            if( !CWN.ds.lookupMap[prmname] ) return;

            var node = CWN.ds.lookupMap[prmname];
            // is the node hidden (ie been filtered out)
            if( node.properties._render && !node.properties._render.show && level != 0 ) {
                return;
            }

            // add the node, unless this is level 0 and we are walking backward
            if( (direction == 'forward' || level != 0) && this.cnodes.indexOf(prmname) == -1  ) {
                this._addNode(node, level, direction);
            }

            // find the links by using the datastores lookup indexes
            var links;
            if( direction == 'forward' ) {
                if( !CWN.ds.originLookupMap[prmname] ) return;
                links = CWN.ds.originLookupMap[prmname];
            } else {
                if( !CWN.ds.terminalLookupMap[prmname] ) return;
                links = CWN.ds.terminalLookupMap[prmname];
            }

            // check max depth, quit if we have passed it
            if( direction == 'forward' ) {
                if( this.maxDepth && this.maxDepth.length > 0 ) {
                    if( level >= parseInt(this.maxDepth) ) {
                        return;
                    }
                }
            } else {
                if( this.negativeDepth && this.negativeDepth.length > 0 ) {
                    if( level >= parseInt(this.negativeDepth) ) {
                        return;
                    }
                }
            }


            // increase the level
            level++;
            // add the links to the graph
            for( var i = 0; i < links.length; i++ ) {
                this._addLink(links[i], level, direction);
            }
        },


        _addNode : function(node, level, direction) {
            if( this.cnodes.indexOf(node.properties.prmname) != -1 ) {
                console.log('found repeat: '+node.properties.prmname);
                return;
            }

            var gnode = {
                id : node.properties.prmname,
                calvin : node.properties,
                label : node.properties.prmname,
                type : node.properties.type,
                size : 8,
            };

            // set the graph node to the list at the current later
            // this list will be used later on to render the nodes location
            if( direction == 'forward' ) {
                if( !this.nodeLevels[level] ) {
                    this.nodeLevels[level] = [gnode];
                } else {
                    this.nodeLevels[level].push(gnode);
                }
            } else {
                if( !this.negativeLevels[level] ) {
                    this.negativeLevels[level] = [gnode];
                } else {
                    this.negativeLevels[level].push(gnode);
                }
            }

            // add the nodes name to the list of nodes already in the graph
            this.cnodes.push(node.properties.prmname);
            // add the node to the graph
            this.graphJson.nodes.push(gnode);
        },

        _addLink : function(link, level, direction) {
            // get the links next node
            var tNode = CWN.ds.lookupMap[direction == 'forward' ? link.properties.terminus : link.properties.origin];
            // make sure the next node exists
            if( !tNode ) return;

            // make sure the next node is being shown
            if( tNode.properties._render && !tNode.properties._render.show ) {
                this._followLink(link, level, direction);
                return;
            }

            // make sure the link hasn't already been added
            if( this.cnodes.indexOf(link.properties.prmname) != -1 ) {
                this._followLink(link, level, direction);
                return;
            }

            var edge = this._createEdge(link);

            // add the link to the graph
            this.graphJson.edges.push(edge);

            // add to the list of nodes/links already used
            this.cnodes.push(link.properties.prmname);

            this._followLink(link, level, direction);
        },

        _followLink : function(link, level, direction) {
            // walk the next node in the graph
            if( direction == 'forward' ) {
                this.walk(link.properties.terminus, level, direction);
            } else {
                this.walk(link.properties.origin, level, direction);
            }
        },

        _createEdge : function(link) {
            return {
                id : link.properties.prmname,
                label : link.properties.prmname,
                calvin : link.properties,
                type : 'cwn',
                source : link.properties.origin,
                target : link.properties.terminus,
                color: 'blue'
            };
        },

        // if we are at max depth (positive or negative) we still want add links for the
        // node where the given node links back to nodes we have already added
        _addMissingLinks : function() {
            var i, n, link;
            for( i = 0; i < this.graphJson.nodes.length; i++ ) {
                n = this.graphJson.nodes[i];

                links = CWN.ds.originLookupMap[n.id] || [];
                for( var j = 0; j < links.length; j++ ) {
                    this._addLinkIfMissing(links[j]);
                }
                links = CWN.ds.terminalLookupMap[n.id] || [];
                for( var j = 0; j < links.length; j++ ) {
                    this._addLinkIfMissing(links[j]);
                }
            }
        },

        _addLinkIfMissing : function(link) {
            if( this.cnodes.indexOf(link.properties.origin) != -1 &&
                this.cnodes.indexOf(link.properties.terminus) != -1 &&
                this.cnodes.indexOf(link.properties.prmname) == -1 ) {

                var edge = this._createEdge(link);

                // add the link to the graph
                this.graphJson.edges.push(edge);

                // add to the list of nodes/links already used
                this.cnodes.push(edge.id);
            }
        },

        // set the position for all nodes in the graph
        setPositions : function() {
            var nLevelCount = Object.keys(this.negativeLevels).length;
            var w = $(this.$.sigma).width();
            var top = nLevelCount * 75;

            for( var level in this.negativeLevels ) {
                var row = this.negativeLevels[level];
                var width = w / row.length;
                var left = width / 2;
                if( level > 0 ) left -= Math.random() * 30;

                for( var i = 0; i < row.length; i++ ) {
                    row[i].x = left;
                    row[i].y = top-75;
                    left += width;
                }

                top -= 75;
            }

            top = nLevelCount * 75;

            for( var level in this.nodeLevels ) {
                var row = this.nodeLevels[level];
                var width = w / row.length;
                var left = width / 2;
                if( level > 0 ) left -= Math.random() * 30;

                for( var i = 0; i < row.length; i++ ) {
                    row[i].x = left;
                    row[i].y = top;
                    left += width;
                }

                top += 75;
            }

            //console.log(this.prmname);
            //console.log(this.negativeLevels);
            //console.log(this.nodeLevels);
            console.log(this.graphJson);

            this.render();
        },

        render : function() {
            if( !this.graph ) {
                this.graph = new sigma({
                    graph: this.graphJson,
                    renderer : {
                        container: this.$.sigma,
                        type : 'canvas'
                    },
                    settings: {
                        defaultNodeColor: '#ec5148',
                        minArrowSize : 6,
                        minNodeSize: 10
                    }
                });

                this.graph.bind('clickNode', function(e){
                    //window.location.hash = 'graph/'+e.data.node.id;
                    this.popupNode = CWN.ds.lookupMap[e.data.node.id];

                    this.$.popup.show();
                }.bind(this));
            } else {

                this.graph.graph.clear();
                this.graph.graph.read(this.graphJson);
                // Refresh the display:
                this.graph.refresh();
            }
            // ForceAtlas Layout
            //this.graph.startForceAtlas2();
        },

        goToGraphLink : function() {
          window.location.hash = 'graph/'+this.popupNode.properties.prmname;
          this.hide();
        },

        goToInfoLink : function() {
          window.location.hash = 'info/'+this.popupNode.properties.prmname;
          this.hide();
        },

        goTo : function() {
            window.location.hash = 'map';
            setTimeout(function() {
                var pts = this.popupNode.geometry.coordinates;
                var ele =document.querySelector('cwn-map')
                ele.map.setView([pts[1], pts[0]], 12);
                this.$.popup.hide();
            }.bind(this), 500);
        },

        hide : function() {
            this.$.popup.hide();
        },

        maxUpdate : function(e) {
            this.maxDepth = e.currentTarget.value;
            this.update();
        },

        minUpdate : function(e) {
            this.negativeDepth = e.currentTarget.value;
            this.update();
        }

    });
</script>
<dom-module id="cwn-animation-menu" assetpath="elements/">
  <template>
    <style>
      :host {
        display: block;
      }
      .filterItem {
        padding-left: 8px;
        padding-top: 4px;
      }
    </style>

    <h4 class="page-header">Animation Layer</h4>

    <template is="dom-repeat" items="{{filters}}">
      <div style="padding: 15px 15px">
        <div>
          <input type="checkbox" id$="{{item.type}}" checked$="{{item.value}}" value="{{item.type}}" on-click="update">
          <span style="font-weight: bold; text-transform:capitalize" for$="{{item.type}}">{{item.type}}</span>

          <canvas name$="{{item.type}}" width="26" height="26" style="text-align:middle; padding: 0 15px"></canvas>
        </div>
        <div class="filterItem">
          <table>
            <tbody><tr>
              <td>
                Max Size: <input type="number" class="form-control" style="display:inline-block; width:50px" name$="{{item.type}}" value="{{item.size}}" on-change="updateSize">
              </td>
              <td>px</td>
              <td>
                &nbsp; (<span class="maxLabel" name$="{{item.type}}"></span> kaf)
              </td>
            </tr>
          </tbody></table>
        </div>
        <div class="filterItem">
          Log Scale: <input type="checkbox" name$="{{item.type}}" checked="" on-click="updateLog">
        </div>
      </div>
    </template>


  </template>
  <script>
    Polymer({
      is: 'cwn-animation-menu',

      ready : function() {
        this.filters = [
          {
            type : 'inflows',
            size : 25,
            value : true,
            log : true,
            color : 'rgba(68,138,255,.8)'
          },
          {
            type : 'flow',
            size : 12,
            value : true,
            log : true,
            color : 'rgba(56,142,60,.8)'
          },
          {
            type : 'sinks',
            size : 25,
            value : true,
            log : true,
            color : 'rgba(211,47,47,.8)'
          },
          {
            type : 'storage',
            size : 25,
            value : true,
            log : true,
            color : 'rgba(255,87,34,.8)'
          },
          {
            type : 'evaporation',
            size : 25,
            value : false,
            log : true,
            color : 'rgba(255,235,59,.8)'
          }
        ]
      },

      attached : function() {
        setTimeout(this.renderLegend.bind(this), 500);
      },

      setMax : function(max) {
        for( var key in max ) {
          var ele = this.querySelector('.maxLabel[name="'+key+'"]');
          if( ele ) {
            ele.innerHTML = max[key].max.toFixed(2);
          }
        }
      },

      renderLegend : function() {
        for( var i = 0; i < this.filters.length; i++ ) {
          var canvas = this.querySelector('canvas[name="'+this.filters[i].type+'"]');

          var ctx = canvas.getContext('2d');
          ctx.beginPath();

          if( this.filters[i].type !== 'flow' ) {
            ctx.fillStyle = this.filters[i].color;
            ctx.arc(13, 13, 12, 0, 2*Math.PI);
            ctx.fill();
          } else {
            ctx.strokeStyle = this.filters[i].color;
            ctx.lineCap = 'round';
            ctx.lineWidth = '8';
            ctx.moveTo(4, 13);
            ctx.lineTo(22, 13);
            ctx.stroke();
          }
        }
      },

      update : function(e) {
        var name = e.currentTarget.getAttribute('value');
        var value = $(e.currentTarget).is(':checked');

        for( var i = 0; i < this.filters.length; i++ ) {
          if( this.filters[i].type === name ) {
            this.filters[i].value = value;
            break;
          }
        }

        this.fire('animation-filters-updated');
      },

      updateSize : function(e) {
        var name = e.currentTarget.getAttribute('name');
        var value = Number(e.currentTarget.value);

        for( var i = 0; i < this.filters.length; i++ ) {
          if( this.filters[i].type === name ) {
            this.filters[i].size = value;
            break;
          }
        }

        this.fire('animation-filters-updated');
      },

      updateLog : function(e) {
        var name = e.currentTarget.getAttribute('name');
        var value = $(e.currentTarget).is(':checked');

        for( var i = 0; i < this.filters.length; i++ ) {
          if( this.filters[i].type === name ) {
            this.filters[i].log = value;
            break;
          }
        }

        this.fire('animation-filters-updated');
      }


    });
  </script>
</dom-module>
<dom-module id="cwn-map-menu" assetpath="elements/">
    <style>
        :host {
            display:block;
            overflow: auto;
        }
        .menu-root {
          background-color: rgba(200,200,200, .2);
          padding-left: 10px;
          border-radius: 3px;
        }
        .menu-item {
          padding: 5px;
          font-size: 14px;
        }
        .menu-item:hover {
          color: #2196f3;
          cursor: pointer;
        }
        .linkLegend {
          width: 20px;
          height: 10px;
          display: inline-block;
          margin: 10px;
          vertical-align: middle;
        }
    </style>
    <template>

      <div id="mainMenu">
        <div>
          <a class="btn btn-link" on-click="showAll">Show All</a> <a class="btn btn-link" on-click="hideAll">Hide All</a>
        </div>

        <div id="content"></div>

        <h5>Link Legend</h5>
        <div>
          <div><div class="linkLegend" id="toSink"></div> Flow to Sink</div>
          <div><div class="linkLegend" id="fromDemand"></div> Flow from Demand</div>
          <div><div class="linkLegend" id="groundwaterToDemand"></div> Groundwater to Demand</div>
          <div><div class="linkLegend" id="recharge"></div> Recharge</div>
          <div><div class="linkLegend" id="region"></div> To/from a Region</div>
        </div>
      </div>

      <cwn-animation-menu id="animationMenu" style="display:none"></cwn-animation-menu>

    </template>
</dom-module>

<script>
    Polymer({
        is : 'cwn-map-menu',

        ready : function() {
          this.classList.add('closed');


          this.$.toSink.style.backgroundColor = CWN.colors.darkCyan;
          this.$.fromDemand.style.backgroundColor = CWN.colors.red;
          this.$.groundwaterToDemand.style.backgroundColor = CWN.colors.lightGrey;
          this.$.recharge.style.backgroundColor = CWN.colors.green;
          this.$.region.style.backgroundColor = CWN.colors.orange;
        },

        init : function(state) {
          if( state ) {
            this.state = state;
          } else {
            this.state = {
              enabled : ['California'],
              disabled : []
            };
          }

          this.render();
        },

        setMenu : function(type) {
          if( type === 'animation' ) {
            this.$.animationMenu.style.display = 'block';
            this.$.mainMenu.style.display = 'none';
          } else {
            this.$.animationMenu.style.display = 'none';
            this.$.mainMenu.style.display = 'block';
          }
        },

        getEnabled : function() {
          this.state = {
            enabled : ['California'],
            disabled : []
          };
          this._getEnabled('California');
          return this.state;
        },

        _getEnabled : function(name) {
          var ele = $(this).find('input[name="'+name+'"]');

          if( ele.is(':checked') ) {
            if( name != 'California' ) this.state.enabled.push(name);
            var region = CWN.ds.regionLookupMap[name];

            if( !region ) return;
            if( !region.subregions ) return;

            for( var i = 0; i < region.subregions.length; i++ ) {
              this._getEnabled(region.subregions[i]);
            }
          } else {
            this.state.disabled.push(name);
          }
        },

        render : function() {
            this.$.content.innerHTML = '';
            this.renderRegion('California', this.$.content);
        },

        renderRegion : function(regionName, root) {
            var ref = this;
            var region = CWN.ds.regionLookupMap[regionName];

            var id = region.name;
            var label = id;
            if( region.geo.properties && region.geo.properties.name ) {
              label = region.geo.properties.name;
            }

            var enabled = false;
            if( regionName == 'California' || this.state.enabled.indexOf(regionName) > -1 ) {
              enabled = true;
            }

            var panel = $('<div class="menu-root cwn-map-menu"></div>');
            var input = $('<div class="menu-item cwn-map-menu" name="'+id+'">'+
                          '<input type="checkbox" name="'+id+'" '+(enabled ? 'checked' : '')+' /> '+label+'</div>');


            var children = $('<div style="display:'+( enabled ? 'block' : 'none')+'" name="'+id+'-children" class="menu-children"></div>');
            panel.append(input);
            panel.append(children);

            root.appendChild(panel[0]);

            input.find('input').on('click', function(e){
              e.stopPropagation();

              var ele = $(this);

              if( ele.is(':checked') ) {
                  children.show('fast');
              } else {
                  children.hide('fast');
              }

              ref.fire('select', ref.getEnabled());
            });

            input
              .on('click', function(){
                input.find('input').trigger("click");
              })
              .on('mouseover', function(){
                this.fire('hover', regionName);
              }.bind(this))
              .on('mouseout', function(){
                this.fire('nohover', regionName);
              }.bind(this));


            if( !region.subregions ) return;

            for( var i = 0; i < region.subregions.length; i++ ) {
                this.renderRegion(region.subregions[i], children[0]);
            }
        },

        showAll : function() {
          $(this.$.content)
            .find('input')
            .prop('checked','checked');

          $(this.$.content)
            .find('.menu-children')
            .show();
          this.getEnabled();

          this.fire('select');
        },

        hideAll : function() {
          $(this.$.content)
            .find('input')
            .prop('checked','');

          $(this.$.content)
            .find('.menu-children')
            .hide();

          $(this.$.content).find('input[name="California"]').trigger("click");
        },

        onRegionClick : function(name) {
          var ele = $(this.querySelector('input[name="'+name+'"]'));
          var children = $(this.querySelector('div[name="'+name+'-children"]'));

          if( !ele.is(':checked') ) {
            ele.prop('checked', true);
            children.show('fast');
          } else {
            ele.prop('checked', false);
            children.hide('fast');
          }

          this.fire('select', this.getEnabled());
        },

        setHovered : function(region) {
          if( !region ) {
            $(this).find('.menu-item').removeClass('hovered');
            this.mouseOverRegion = null;
            return;
          }

          if( this.mouseOverRegion && region.name == this.mouseOverRegion.name ) return;

          $(this).find('.menu-item').removeClass('hovered');
          this.mouseOverRegion = region;

          $(this).find('.menu-item[name="'+region.name+'"]').addClass('hovered');
        }
    })
</script>
<dom-module id="cwn-animation-control" assetpath="elements/">
  <template>
    <style>
      :host {
        display: block;
        padding: 7px;
      }
      :host(.active) {
        background-color: rgba(255,255,255, .7);
        border-top: 1px solid white;
        box-shadow: 0 0 5px #333;
      }
      input[type="number"] {
        width: 75px;
        display: inline-block !important;
      }
    </style>

    <div class="layout horizontal">
      <div>
        <input type="checkbox" on-click="toggle"> Animation Layer
      </div>
      <div class="flex" style="display:none; text-align:center" id="controls">
        <a class="btn btn-default" on-click="previous"><i class="fa fa-arrow-left"></i></a>
        <input type="number" id="monthInput" class="form-control" value="1" on-change="onNumInput">
        <input type="number" id="yearInput" class="form-control" value="1922" on-change="onNumInput">
        <a class="btn btn-default" on-click="play"><i id="playIcon" class="fa fa-play"></i></a>
        <a class="btn btn-default" on-click="next"><i class="fa fa-arrow-right"></i></a>
      </div>
    </div>

  </template>
  <script>
    Polymer({
      is: 'cwn-animation-control',

      ready : function() {
        this.showing = false;
        this.playing = false;
        this.cache = {};
        this.date = '1922-01';
        this.animationFrameCount = 0;
        this.speed = 100;
        this.subFrames = 10;

        this.start = new Date(1922,0,1);
        this.end = new Date(2002,0,1);
        this.current = new Date(1922,0,1);
        this.setInputs();

        var oneMonth = 30.4*24*60*60*1000;
        var diffMonths = Math.round(Math.abs((this.start.getTime() - this.end.getTime())/(oneMonth)));
      },

      attached : function() {
        this.mainMenu = document.querySelector('cwn-map-menu');
        this.animationMenu = document.querySelector('cwn-animation-menu');
        this.animationMenu.addEventListener('animation-filters-updated', this.onFiltersUpdated.bind(this));
        this.onFiltersUpdated();
        this.loadMinMax();
      },

      loadMinMax : function() {
        $.get('/network/timesliceMinMax', function(resp){
          this.minMaxOrg = resp;
          this.scaleMinMax();
          this.animationMenu.setMax(this.minMaxOrg);
        }.bind(this));
      },

      scaleMinMax : function() {
        this.minMax = $.extend(true, {}, this.minMaxOrg);

        for( var key in this.minMax ) {
          if( key === 'is' ) continue;
          this.minMax[key].min = Number(this.minMax[key].min);
          this.minMax[key].max = Number(this.minMax[key].max) * 1000;

          if( this.minMax[key].max < 1 ) {
            this.minMax[key].max = 1;
          } else {
            if( this.filters[key] && this.filters[key].log ) {
              this.minMax[key].max = Math.log(this.minMax[key].max);
            }
          }
        }
      },

      onFiltersUpdated : function() {
        this.filters = {};
        var filters = this.animationMenu.filters;
        for( var i = 0; i < filters.length; i++ ) {
          if( filters[i].value ) {
            this.filters[filters[i].type] = {
              size : filters[i].size,
              log : filters[i].log,
            }
          }
        }

        if( this.minMaxOrg ) this.scaleMinMax();
        if( this.timeslice && this.timeslice.features ) {
          for( var i = 0; i < this.timeslice.features.length; i++ ) {
            this.scale(this.timeslice.features[i].geojson.properties);
          }
        }

        if( this.timeslice ) this.timeslice.render();
      },

      play : function() {
        if( this.playing ) {
          clearTimeout(this.playingTimer);
          this.$.playIcon.className = 'fa fa-play';
        } else {
          this.startPlaying();
          this.$.playIcon.className = 'fa fa-pause';
        }
        this.playing = !this.playing;
      },

      startPlaying : function() {
        this.animationFrameCount = 0;
        this.animateNext();
      },

      animateNext : function() {
        this.animationFrameCount++;

        if( this.animationFrameCount === this.subFrames+1 ) {
          this.animationFrameCount = 1;
          this.current = new Date(this.current.getFullYear(), this.current.getMonth()+1, 1);
          this.setDate();
          this.setInputs();
          this.getData(function(){
            if( !this.playing ) return; // the pause button my have been hit
            this.animationTimer = setTimeout(this.animateNext.bind(this), this.speed);
          }.bind(this));
        } else {
          this.timeslice.render();
          this.animationTimer = setTimeout(this.animateNext.bind(this), this.speed);
        }
      },

      onNumInput : function() {
        this.current = new Date(Number(this.$.yearInput.value), Number(this.$.monthInput.value)-1, 1);
        this.setDate();
        this.getData();
      },

      previous : function() {
        this.current = new Date(this.current.getFullYear(), this.current.getMonth()-1,1);
        this.setDate();
        this.setInputs();
        this.getData();
      },

      next : function() {
        this.current = new Date(this.current.getFullYear(), this.current.getMonth()+1,1);
        this.setDate();
        this.setInputs();
        this.getData();
      },

      setInputs : function() {
        this.$.monthInput.value = this.current.getMonth()+1;
        this.$.yearInput.value = this.current.getFullYear();
      },

      setDate : function() {
        var m = this.current.getMonth()+1;
        if( m < 10 ) m = '0'+m;
        this.date = this.current.getFullYear()+'-'+m;
      },

      toggle : function() {
        if( this.showing ) {
          this.$.controls.style.display = 'none';
          this.timeslice.hide();
          this.featureLayer.show();
          this.classList.remove('active');
          if( this.playing ) this.play();
          document.querySelector('cwn-map-menu').setMenu('main');
        } else {
          this.$.controls.style.display = 'block';
          this.timeslice.show();
          this.featureLayer.hide();
          this.getData();
          this.classList.add('active');
          document.querySelector('cwn-map-menu').setMenu('animation');
        }

        this.showing = !this.showing;
      },

      init : function(mapEle) {
        this.mapEle = mapEle;
        this.map = mapEle.map;
        this.featureLayer = mapEle.markerLayer;

        this.timeslice = new L.CanvasGeojsonLayer({
          onMouseMove : this.onMouseMove.bind(this),
          onClick : this.onClick.bind(this),
          zIndex : 10
        });
        this.timeslice.addTo(this.map);
      },

      onClick : function(features, e) {
        if( features.length == 0 ) return;

        if( features.length == 1 && features[0].properties.prmname ) {
          window.location.href = '#info/' + features[0].properties.prmname;
          return;
        }

        // grab real features
        var array = [];
        for( var i = 0; i < features.length; i++ ) {
          array.push(CWN.ds.lookupMap[features[i].properties.prmname]);
        }

        this.mapEle.selector.onClick(array);
      },

      onMouseMove : function(features, e) {
        this.lastMouseEvent = e;
        var label = [], linkLabel = '', regionLabel = '';
        var i, f, key;

        for( i = 0; i < features.length; i++ ) {
          f = features[i].properties;
          label.push('<b>'+f.prmname+':</b> '+f.type+' = '+f[f.type]);
        }

        if( features.length > 0 ) {
          this.mapEle.showHoverLabel(true, label.join('<br />'), e.containerPoint);
          //this.$.leaflet.style.cursor = 'pointer';
        } else {
          this.mapEle.showHoverLabel(false);
          //this.$.leaflet.style.cursor = '-webkit-grab';
        }
      },


      getData : function(callback) {
        if( this.cache[this.date] ) {
          this.onResponse(this.cache[this.date].data);
          if( callback ) callback();
        } else {
          $.get('/network/timeslice?date='+this.date, function(resp){
            this.cache[resp.date] = resp;

            if( resp.error ) {
              console.log('No data for: '+this.date);
              this.timeslice.removeAll();
              if( callback ) callback();
              return;
            }

            resp.lookup = {};
            for( var i = 0; i < resp.data.length; i++ ) {
              var geojson = JSON.parse(resp.data[i]);
              resp.data[i] = geojson;
              resp.lookup[geojson.properties.prmname+'-'+geojson.properties.type] = geojson;
            }

            resp.data.sort(function(a, b){
              if( a.properties.flow ) return -1;
              if( b.properties.flow ) return 1;

              if( a.properties.evaporation ) return -1;
              if( b.properties.evaporation ) return 1;

              if( a.properties.storage ) return -1;
              if( b.properties.storage ) return 1;

              if( a.properties.inflow ) return -1;
              if( b.properties.inflow ) return 1;

              if( a.properties.sinks ) return -1;
              if( b.properties.sinks ) return 1;

              return 0;
            });

            this.onResponse(resp.data);
            if( callback ) callback();
          }.bind(this));
        }
      },

      render : function(ctx, point, map, feature) {
        var color;


        var value = feature.geojson.properties.value;
        if( this.playing && this.animationFrameCount < this.subFrames ) {
          var fCount = this.animationFrameCount;
          if( fCount === 0 ) fCount = 1;
          value = feature.geojson.properties.frames[fCount-1];
        }

        var o = this.getOpacity(feature.geojson.properties, value);

        if( feature.geojson.geometry.type === 'Point' ) {

          if( feature.geojson.properties.type === 'inflows' && this.filters.inflows ) {
            color = 'rgba(68,138,255,'+o+')';
            this.renderPoint(ctx, point, value, color, 'inflows');
          } else if( feature.geojson.properties.type === 'sinks' && this.filters.sinks ) {
            color = 'rgba(211,47,47,'+o+')';
            this.renderPoint(ctx, point, value, color, 'sinks');
          } else if( feature.geojson.properties.type === 'storage' && this.filters.storage ) {
            color = 'rgba(255,87,34,'+o+')';
            this.renderPoint(ctx, point, value, color, 'storage');
          } else if( feature.geojson.properties.type === 'evaporation' && this.filters.evaporation ) {
            color = 'rgba(255,235,59,'+o+')';
            this.renderPoint(ctx, point, value, color, 'evaporation');
          }

        } else if( feature.geojson.properties.type === 'flow' && this.filters.flow ){
          ctx.beginPath();

          ctx.moveTo(point[0].x, point[0].y);
          ctx.lineTo(point[1].x, point[1].y);

          ctx.lineCap = 'round';
          ctx.strokeStyle = 'rgba(56,142,60,'+o+')';

          var width = Math.ceil((this.filters.flow ? this.filters.flow.size : 12)*value);

          if( width < 1 ) width = 1;
          ctx.lineWidth = width;

          ctx.stroke();
        }
      },

      getOpacity : function(properties, value) {
        if( isNaN(value) ) debugger;
        if( this.filters[properties.type] && this.filters[properties.type].log ) {
          value = value * .9;
          if( value < .1 ) return .1;
          return value;
        }

        if( value < .3 ) return .3;
        return value;
      },

      getSize : function(value, type) {
        value = value * (this.filters[type].size || 25);
        if( value < 4 ) return 4;
        return value;
      },

      renderPoint : function(ctx, point, value, color, type) {
        ctx.beginPath();
        ctx.fillStyle = color;
        ctx.arc(point.x, point.y, this.getSize(value, type), 0, 2*Math.PI);
        ctx.fill();
      },

      onResponse : function(data) {
        this.timeslice.removeAll();
        var arr = [], max = 0;

        if( data.length == 0 ) return;

        var previous = new Date(this.current.getFullYear(), this.current.getMonth()-1, 1);
        var m = previous.getMonth()+1;
        if( m < 10 ) m = '0'+m;
        previous = previous.getFullYear()+'-'+m;
        var previousData = this.cache[previous];

        var used = {};

        for( var i = 0; i < data.length; i++ ) {
          // TODO: don't recalc if we don't need to
          //if( !data[i].properties.scaled ) {
            var id = data[i].properties.prmname+'-'+data[i].properties.type;
            used[id] = 1;
            this.scale(data[i].properties, previousData ? previousData.lookup[id] : null);
          //}

          this.timeslice.addFeature({
            geojson: data[i],
            render: this.render.bind(this)
          });
        }

        var disappeared = [];
        if( previousData ) {
          for( var key in previousData.lookup ) {
            if( !used[key] ) {
              // push a new properties with a 0 value
              var newNode = $.extend(true, {}, previousData.lookup[key]);
              newNode.properties[newNode.properties.type] = 0;

              // scale the new node
              this.scale(newNode.properties, previousData.lookup[key]);

              // add to data
              data.push(newNode);
              this.cache[this.date].lookup[key] = newNode;

              // add to layer
              this.timeslice.addFeature({
                geojson: newNode,
                render: this.render.bind(this)
              });
            }
          }
        }
        //console.log(disappeared);


        this.timeslice.render();

        // TODO: make sure mouse is still over map
        // update the hover on animation
        if( this.lastMouseEvent && this.playing ) {
          this.timeslice._intersects(this.lastMouseEvent);
          this.timeslice.onMouseMove(this.timeslice.intersectList, this.lastMouseEvent);
        }
      },

      scale : function(properties, previousData) {
        var previous = 0;
        if( previousData ) {
          previous = previousData.properties.value;
        }

        if( !this.minMax[properties.type] ) return;

        var value = this.calcValue(properties.type, properties[properties.type]);
        properties.value = value;

        properties.frames = [];
        var diff = value - previous;
        for( var i = 1; i < this.subFrames; i++ ) {
          if( diff < 0 ) {
            properties.frames.push(previous + (diff * (1/this.subFrames) * i));
          } else {
            properties.frames.push(previous + (diff * (1/this.subFrames) * i));
          }
        }
      },

      calcValue : function(type, value) {
        value = value * 1000;

        if( value < 1 ) {
          value = 0;
        } else {
          if( this.filters[type] ) {
            if( this.filters[type].log ) {
              value = Math.log(value) / this.minMax[type].max;
            } else {
              value = value / this.minMax[type].max;
            }
          }
        }
        if( value > 1 ) {
          value = 1;
        }

        return value;
      }
    });
  </script>
</dom-module>
<dom-module id="cwn-map" assetpath="elements/">
    <style>
        :host {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        leaflet-map {
            height: 100%;
            display: relative;
            z-index: 100;
        }

        .updating {
            position: absolute;
            height: 100%;
            width: 100%;
            top: 0;
            left: 0;
            z-index: 2;
            background-color: rgba(255,255,255,.6);
        }
        .updating div {
            position: absolute;
            left: 20px;
            bottom: 20px;
            font-size: 36px;
            color: #888;
            text-shadow: 2px 2px white;
        }
        #leaflet {
            width: 100%;
            height: 100%;
            display: block;
        }

        #hoverLabel {
          position: absolute;
          background-color: white;
          padding: 5px;
          border: 1px solid #ccc;
          display: none;
          z-index: 100;
        }

        #animationControl {
          position: absolute;
          left : 0;
          right : 0;
          bottom : 0;
        }
    </style>

    <template>

        <div id="leaflet"></div>

        <div hidden$="{{!updating}}" class="updating">
            <div>Filtering...</div>
        </div>

        <div id="hoverLabel"></div>
        <cwn-animation-control id="animationControl"></cwn-animation-control>
    </template>
</dom-module>

<script>
    Polymer({
        is : 'cwn-map',

        ready : function() {
          this.firstLoad = true;
          this.customLines = {};
          this.shiftPessed = false;

          $(window).on('keydown',function(e){
            if( e.which == 16 && e.shiftKey == true ) {
              this.shiftPessed = true;
            }
          }.bind(this));
          $(window).on('keyup',function(e){
            this.shiftPessed = false;
          }.bind(this));
        },

        init : function(legend, filters) {
          this.map = L.map(this.$.leaflet).setView([40, -121], 5);
          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
              maxZoom: 18
          }).addTo(this.map);

          this.links = [];
          this.mapFilters = filters || {};

          this.legend = legend;

          this.mouseMoveTimer = -1;

          this.renderState = {
            points : [],
            lines : [],
            polygons : []
          }



          var ref = this;

          this.markerLayer = new L.CanvasGeojsonLayer({
            onMouseOver : this.onMouseOver.bind(this),
            onMouseOut : this.onMouseOut.bind(this),
            onMouseMove : this.onMouseMove.bind(this),
            onClick : function(features, e) {
              if( features.length == 0 ) return;

              var type = features[0].geometry.type;

              if( features.length == 1 && type == 'Polygon' || type == 'MultiPolygon' ) {
                if( this.shiftPessed ) {
                  window.location.href = '#info/' + features[0].properties.id;
                  return;
                }

                if( !features[0].properties._render ) features[0].properties._render = {};
                features[0].properties._render.hover = true;
                this.markerLayer.render();

                setTimeout(function(){
                  ref.onRegionClick(features[0].properties.id);

                  features[0].properties._render.hover = false;
                  this.markerLayer.render();

                }.bind(this), 0);
                return;
              }

              if( features.length == 1 && features[0].properties.prmname ) {
                window.location.href = '#info/' + features[0].properties.prmname;
                return;
              }

              this.selector.onClick(features);
            }.bind(this)
          });

          this.$.animationControl.init(this);

          this.markerLayer.addTo(this.map);

          this.selector.init(this, this.markerLayer);

          if( !CWN.ds.loading ) this.process();
          else CWN.ds.on('load', this.process.bind(this));

          setTimeout(function(){
              this.map.invalidateSize();
          }.bind(this), 200);
        },

        renderRegionLine : function(ctx, xyPoints, config, feature) {

          /*ctx.beginPath();
          ctx.strokeStyle = CWN.colors.orange;
          ctx.lineWidth = 6;
          ctx.moveTo(xyPoints[0].x, xyPoints[0].y);
          ctx.lineTo(xyPoints[1].x, xyPoints[1].y);
          ctx.stroke();*/

          ctx.beginPath();
          ctx.strokeStyle = CWN.colors.orange;
          ctx.lineWidth = 2;
          ctx.moveTo(xyPoints[0].x, xyPoints[0].y);
          ctx.lineTo(xyPoints[1].x, xyPoints[1].y);
          ctx.stroke();
        },

        onMouseMove : function(features, e) {
          var label = [], linkLabel = '', regionLabel = '';
          var i, f;

          for( i = 0; i < features.length; i++ ) {
            f = features[i].properties;

            if( f.type == 'Diversion' || f.type == 'Return Flow' ) label.push(f.type+' <b>'+f.prmname+'</b>');
            else if( f.type == 'Link Group' ) label.push(f.type+' <b>Count: '+f.lines.length+'</b>');
            else if ( f.type == 'Region' ) label.push(f.type+' <b>'+f.name+'</b>');
            else label.push(f.type+' <b>'+f.prmname+'</b>');
          }

          if( features.length > 0 ) {
            this.showHoverLabel(true, label.join('<br />'), e.containerPoint);
            this.$.leaflet.style.cursor = 'pointer';
          } else {
            this.showHoverLabel(false);
            this.$.leaflet.style.cursor = '-webkit-grab';
          }
        },

        onMouseOver : function(features, e) {
          var i, f;

          for( i = 0; i < features.length; i++ ) {
            f = features[i].properties;

            if( !f._render ) f._render = {};
            f._render.hover = true;
          }
        },

        onMouseOut : function(features) {
          for( var i = 0; i < features.length; i++ ) {
            if( !features[i].properties._render ) features[i].properties._render = {};
            features[i].properties._render.hover = false;
          }
        },

        showHoverLabel : function(show, label, pos) {
          if( show ) {
            this.$.hoverLabel.style.display = 'block';
            this.$.hoverLabel.style.left = (pos.x+10)+'px';
            this.$.hoverLabel.style.top = (pos.y+10)+'px';
            this.$.hoverLabel.innerHTML = label;
          } else {
            this.$.hoverLabel.style.display = 'none';
          }
        },

        process : function() {
            if( CWN.ds.loading ) return;

            this.edges = [];
            this.knownEdges = [];

            for( var i = 0; i < CWN.ds.data.regions.length; i++ ) {
              this.markerLayer.addFeature({
                geojson: CWN.ds.data.regions[i].geo,
                render: CWN.map.renderer.basic
              })
            }

            for( var i = 0; i < CWN.ds.data.links.length; i++ ) {
              this.markerLayer.addFeature({
                geojson: CWN.ds.data.links[i],
                render: CWN.map.renderer.basic
              })
            }

            for( var i = 0; i < CWN.ds.data.nodes.length; i++ ) {
              this.markerLayer.addFeature({
                geojson: CWN.ds.data.nodes[i],
                render: CWN.map.renderer.basic,
                size: 20
              })
            }

            this.menu.init();
            this.updateRenderState();
            this.update();

            // Set California checked on first load
            if( this.firstLoad ) {
              this.menu.getEnabled();
              this.onRegionSelect();
              this.firstLoad = false;
            }
        },

        update : function() {
            this.updating = true;

            if( !this.mapFilters ) this.mapFilters = {};

            var map = this.map;
            var oneStepMode = this.mapFilters.oneStepMode;

            // update filtering
            this.filter();

            this.links = this.getEdgeMarkers();

            this.updateRenderState();

            this.updating = false;
            this.fire('filtering-complete');
        },

        getEdgeMarkers : function() {
            var x2, y2, i, coord, link, markers = [];

            for( i = 0; i < CWN.ds.data.links.length; i++ ) {
                link = CWN.ds.data.links[i];
                if( !link.properties._render.show ) continue;
                coord = link.geometry.coordinates;

                x2 = (coord[0][0] + coord[1][0]) / 2;
                y2 = (coord[0][1] + coord[1][1]) / 2;

                x2 = (x2 + coord[1][0]) / 2;
                y2 = (y2 + coord[1][1]) / 2;

                markers.push(link);
            }

            return markers;
        },

        checkSinkMode : function(inflowSinkMode,  properties) {
          if( !inflowSinkMode ) {
            properties._render.stroke = null;
            return true;
          }

          if( properties.extras ) {
            if( properties.extras.inflows ) {
              properties._render.stroke = 'green';
              return true;
            } else if( properties.extras.sinks ) {
              properties._render.stroke = 'red';
              return true;
            }
          }

          properties._render.stroke = null;
          return false;
        },

        // marker nodes that are linked to a visible node with the 'nodeStep' attribute
        filter : function() {
            var re, i, d, d2, d3, id;
            // three loops, first mark nodes that match, then mark one step nodes
            // finally mark links to hide and show
            try {
                re = new RegExp('.*'+this.mapFilters.text.toLowerCase()+'.*');
            } catch (e) {}
            for( i = 0; i < CWN.ds.data.nodes.length; i++ ) {
                d = CWN.ds.data.nodes[i];
                if( !d.properties._render ) {
                    d.properties._render = {
                        filter_id : d.properties.type.replace(' ','_').replace('-','_')
                    };
                }
                //d.properties._render.oneStep = false;
                if( this.mapFilters[d.properties._render.filter_id] && this.isTextMatch(re, d.properties) ) {
                    //if( !this.mapFilters.calibrationMode && d.properties.calibrationNode ) {
                    if( !this.checkSinkMode(this.mapFilters.inflowSinkMode,  d.properties) ) {
                        d.properties._render.show = false;
                    } else {
                        d.properties._render.show = true;
                    }
                } else {
                    d.properties._render.show = false;
                }
            }

            // now mark one step nodes
            /*for( i = 0; i < CWN.ds.data.nodes.length; i++ ) {
                d = CWN.ds.data.nodes[i];
                if( d.properties._render.show ) continue;
                if( !this.mapFilters.calibrationMode && d.properties.calibrationNode ) continue;

                if( d.properties.terminals ) {
                    for( var j = 0; j < d.properties.terminals.length; j++ ) {
                        d2 = CWN.ds.lookupMap[d.properties.terminals[j]];
                        if( d2 && d2.properties._render.show ) {
                            d.properties._render.oneStep = true;
                            break;
                        }
                    }
                }
                if( d.properties.origins && !d.properties._render.oneStep) {
                    for( var j = 0; j < d.properties.origins.length; j++ ) {
                        d2 = CWN.ds.lookupMap[d.properties.origins[j]];
                        if( d2 && d2.properties._render.show ) {
                            d.properties._render.oneStep = true;
                            break;
                        }
                    }
                }
            }*/

            // now mark links that should be show
            for( var i = 0; i < CWN.ds.data.links.length; i++ ) {
                d = CWN.ds.data.links[i];
                d2 = CWN.ds.lookupMap[d.properties.origin];
                d3 = CWN.ds.lookupMap[d.properties.terminus];

                this.checkRenderNs(d);
                this.checkRenderNs(d2);
                this.checkRenderNs(d3);

                if( d2 && d3 &&
                    (d2.properties._render.show || (this.mapFilters.oneStepMode && d2.properties._render.oneStep) ) &&
                    (d3.properties._render.show || (this.mapFilters.oneStepMode && d3.properties._render.oneStep) ) &&
                   !(d2.properties._render.oneStep && d3.properties._render.oneStep ) ) {
                    d.properties._render.show = true;
                } else {
                    d.properties._render.show = false;
                }
            }
        },

        checkRenderNs : function(node) {
          if( !node ) return;
          if( !node.properties._render ) {
            node.properties._render = {};
          }
        },

        isTextMatch : function(re, props) {
            if( this.mapFilters.text == '' || !re ) return true;

            if( re.test(props.prmname.toLowerCase()) ) return true;
            if( props.description && re.test(props.description.toLowerCase()) ) return true;
            return false;
        },

        onRegionClick : function(name) {
          this.menu.onRegionClick(name);
          //$('.menu-item[name="'+name+'"]').trigger('click');
        },

        onRegionSelect : function(e) {
          this.updateRenderState();
          this.markerLayer.render();
        },

        updateRenderState : function() {
          this.renderState = {
            points : [],
            lines : [],
            polygons : []
          }
          this.clearCustomLines();

          this._updateRenderState('California');

          var f = null, render;
          for( var i = 0; i < this.markerLayer.features.length; i++ ) {
            f = this.markerLayer.features[i];
            r = f.geojson.properties._render || {};

            if( (this.renderState.points.indexOf(f.geojson) > -1 ||
              this.renderState.lines.indexOf(f.geojson) > -1 ||
              this.renderState.polygons.indexOf(f.geojson) > -1) &&
              r.show !== false ) {
                f.visible = true;
            } else {
              f.visible = false;
            }
          }

          this.markerLayer.render();
        },

        _updateRenderState : function(name) {
          var region = CWN.ds.regionLookupMap[name];
          var state = this.menu.state;

          if( state.enabled.indexOf(name) > -1 ) {
            this._addStateNodes(region.nodes, state);

            if( !region.subregions ) return;

            for( var i = 0; i < region.subregions.length; i++ ) {
              this._updateRenderState(region.subregions[i]);
            }
          } else {

            if( name != 'California' ) this.renderState.polygons.push(region.geo);
          }
        },

        _addStateNodes : function(nodes, state) {
          var self = this;

          // find first region and insert after
          var index = 0, type;
          for( var i = 0; i < this.markerLayer.features.length; i++ ) {
            type = this.markerLayer.features[i].geojson.geometry.type;
            if( type != 'Polygon' && type != 'MultiPolygon' ) {
              index = i;
              break;
            }
          }

          for( var prmname in nodes ) {
            var node = CWN.ds.lookupMap[prmname];

            // TODO: why!?
            if( !node ) continue;

            var render = node.properties._render || {};
            if( render.show === false ) continue;

            if( node.properties.type == 'Diversion' || node.properties.type == 'Return Flow' ) {
              var terminal = this._getStateNodeLocation(node.properties.terminus, state);
              var origin = this._getStateNodeLocation(node.properties.origin, state);

              if( !terminal || !origin ) continue;

              var lineFeature;
              if( terminal.isNode && origin.isNode ) {
                lineFeature = this.createNodeLink(origin.center, terminal.center, node);
                this.customLines[node.properties.origin+'_'+node.properties.terminus] = lineFeature;
              } else {
                // if this line already exists, a null value will be returned
                lineFeature = this.createCustomLink(origin, terminal, node);
              }

              if( lineFeature ) {
                this.renderState.lines.push(lineFeature.geojson);
                this.markerLayer.addFeature(lineFeature, index);
              }

            } else {
              this.renderState.points.push(node);
            }
          }
        },

        createNodeLink : function(origin, terminal, node) {
          return {
            geojson : {
              "type" : "Feature",
              "geometry" : {
                "type" : "LineString",
                coordinates : [origin, terminal]
              },
              properties : $.extend(true, {}, node.properties)
            },
            render : CWN.map.renderer.basic
          };
        },

        createCustomLink : function(origin, terminal, node) {
          var self = this;

          var feature = null;
          if( this.customLines[origin.name+'_'+terminal.name] ) {
            feature = this.customLines[origin.name+'_'+terminal.name];
          } else if ( this.customLines[terminal.name+'_'+origin.name] ) {
            feature = this.customLines[terminal.name+'_'+origin.name];
          }

          if( !feature ) {
            feature = {
              geojson : {
                "type" : "Feature",
                "geometry" : {
                  "type" : "LineString",
                  coordinates : [origin.center, terminal.center]
                },
                properties : {
                  prmname : origin.name+'--'+terminal.name,
                  type : 'Region Link',
                  lines : [$.extend(true, {}, node.properties)],
                }
              },
              render : function(ctx, xyPoints, map) {
                self.renderRegionLine(ctx, xyPoints, map, this);
              }
            }

            this.customLines[origin.name+'_'+terminal.name] = feature;

            return feature;
          }

          feature.geojson.properties.lines.push($.extend(true, {}, node.properties));
        },

        clearCustomLines : function() {
          for( var key in this.customLines ) {
            var index = this.markerLayer.features.indexOf(this.customLines[key]);
            if( index > -1 ) this.markerLayer.features.splice(index, 1);
          }
          this.customLines = {};
        },

        _getStateNodeLocation : function(name, state) {
          var node = CWN.ds.lookupMap[name];

          if( !node ) return null;

          for( var i = 0; i < node.properties.regions.length; i++ ) {
            if( state.disabled.indexOf(node.properties.regions[i]) > -1 ) {
              if( CWN.ds.regionLookupMap[node.properties.regions[i]].center ) {
                return {
                  center: CWN.ds.regionLookupMap[node.properties.regions[i]].center,
                  name: node.properties.regions[i],
                  isRegion : true
                };
              }
            }
          }

          return {
            center : node.geometry.coordinates || [0,0],
            name : name,
            isNode : true
          }
        },

        onMenuRegionHover : function(e) {
          this.hoverRegion = e.detail;
          this.markerLayer.render();
        },

        onMenuRegionNoHover : function(e) {
          if( this.hoverRegion == e.detail ) {
            this.hoverRegion = null;
            this.markerLayer.render();
          }
        }


    });
</script>
<dom-module id="cwn-dev" assetpath="elements/">
  <template>
    <div class="modal fade" id="popup">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true"></span></button>
            <h4 class="modal-title">DEV MODE - Info</h4>
          </div>
          <div class="modal-body">
            <div id="popup-socket-status"></div>

            <h4>Git Info</h4>
            <table class="table">
              <tbody><tr>
                <td>Branch</td>
                <td id="popup-branch"></td>
              </tr>
              <tr>
                <td>Tag</td>
                <td id="popup-tag"></td>
              </tr>
              <tr>
                <td>Commit</td>
                <td id="popup-commit"></td>
              </tr>
              <tr>
                <td>Repo</td>
                <td id="popup-repo"></td>
              </tr>
            </tbody></table>

            <h4>Local Directory</h4>
            <div id="popup-wireto"></div>

            <br><br>
            <button id="refresh" class="btn btn-warning" on-click="refresh">Force Refresh</button>

          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div><!-- /.modal -->
  </template>
</dom-module>

<script>
  Polymer({
    is : 'cwn-dev',

    ready : function() {
      this.testForSocket(function(isDev){
        if( isDev ) this.init();
      }.bind(this));
    },

    testForSocket : function(callback) {
      $.get('/rest/isDev', function(resp){
        if( resp && resp.isDev ) {
          return callback(true);
        }

        callback(false);
      }.bind(this));
    },

    loadLib : function(callback) {
      console.log('Is dev, loading socket.io lib');
      $.get('/socket.io/socket.io.js', function(resp){
        eval(resp);

        callback();
      });
    },

    init : function() {
      this.popup = $(this.$.popup).modal({show: false});

      this.loadLib(function() {
        console.log('Initializing dev socket connection');
        this.toast = document.createElement('paper-toast');

        document.body.appendChild(this.toast);
        this.socket = io(window.location.origin);

        this.socket.on('connect', function() {
          console.log('Dev socket connection established');
          this.setTitle(true);
        }.bind(this));
        this.socket.on('disconnect', function() {
          console.log('Dev socket connection established');
          this.setTitle(false);
        }.bind(this));

        this.socket.on('network-wired-to', function (data) {
          this.$['popup-wireto'].innerHTML = data.dir;
        }.bind(this));

        this.socket.on('network-update-start', function (data) {
          this.refreshing(true);
          this.toast.innerHTML = 'Network data update detected, importing to database...';
          this.toast.duration = 20000;
          this.toast.show();
        }.bind(this));

        this.socket.on('network-update-msg', function (data) {
          this.toast.innerHTML = this.toast.innerHTML + '<br />'+ data.msg;
        }.bind(this));

        this.socket.on('network-update-end', function (data) {
          this.toast.innerHTML = this.toast.innerHTML + '<br />Network data update finished! Client refreshing data...';
          this.toast.duration = 3000;
          this.fire('update');
          this.toast.show();
          this.refreshing(false);
        }.bind(this));
      }.bind(this));
    },

    setTitle : function(connected) {
      $('.devTitle')
        .html('<a style="cursor:pointer">DEV MODE <i class="fa fa-info-circle"></i></a>')
        .find('a')
          .css('color', connected ? '#ccc' : 'red')
          .on('click', this.showInfo.bind(this));

      if( connected ) {
        this.$['popup-socket-status'].className = 'alert alert-success';
        this.$['popup-socket-status'].innerHTML = 'Socket.IO dev channel connected';
      } else {
        this.$['popup-socket-status'].className = 'alert alert-danger';
        this.$['popup-socket-status'].innerHTML = 'Socket.IO dev channel disconnected';
      }
    },

    showInfo : function() {
      this.updatePopupInfo();
      this.popup.modal('show');
    },

    updatePopupInfo : function() {
      if( !CWN.ds.data ) return;
      if( !CWN.ds.data.nodes ) return;
      if( CWN.ds.data.nodes.length == 0 ) return;

      // grab any node, this is generic information
      var repo = CWN.ds.data.nodes[0].properties.repo;

      this.$['popup-branch'].innerHTML = repo.branch;
      this.$['popup-tag'].innerHTML = repo.tag;
      this.$['popup-commit'].innerHTML = repo.commit;
      this.$['popup-repo'].innerHTML = '<a href="https://github.com/'+repo.repo+'" target="_blank">'+repo.repo+'</a>';
    },

    refreshing : function(refreshing) {
      if( refreshing ) {
        this.$.refresh.setAttribute('disabled', 'disabled');
        this.$.refresh.innerHTML = '<i class="fa fa-circle-o-notch fa-spin"></i> Refreshing...';
      } else {
        this.$.refresh.removeAttribute('disabled');
        this.$.refresh.innerHTML = 'Force Refresh';
      }
    },

    refresh : function() {
      this.socket.emit('force-refresh',{});
    }
  });
</script>
<dom-module id="cwn-app" assetpath="elements/">
    <style>
        leaflet-map, core-animated-pages {
            height: 100%
        }

        .splash-screen {
          position: fixed;
          top: 100px;
          text-align: center;
          z-index: 20000;
          width: 100%;
        }

        .splash-screen-text {
          margin: 20px;
          display: inline-block;
          background-color: rgba(0,0,0,.7);
          border-radius: 6px;
          box-shadow: 0 0 5px black;
          padding: 25px;
          color: white;
        }
    </style>

    <template>
        <cwn-search id="search"></cwn-search>
        <cwn-about id="about"></cwn-about>
        <cwn-region-selector id="selector"></cwn-region-selector>
        <cwn-dev on-update="onDataUpdated"></cwn-dev>

        <cwn-filters id="filters" on-update="onFiltersUpdated"></cwn-filters>

        <div class="splash-screen" id="splash">
          <h2 class="splash-screen-text">
            <i class="fa fa-circle-o-notch fa-spin"></i> Loading Network...
          </h2>
        </div>

        <cwn-app-layout id="layout">
          <a right-nav="" href="#map" id="backBtn">
            <span class="hidden-xs"><i class="fa fa-arrow-left"></i> Back</span>
            <span class="visible-xs"><i class="fa fa-arrow-left"></i></span>
          </a>

          <a right-nav="" on-click="showFilters" id="filterBtn">
            <span class="hidden-xs"><i class="fa fa-filter"></i> Filters</span>
            <span class="visible-xs"><i class="fa fa-filter"></i></span>
          </a>

          <a right-nav="" on-click="search">
            <span class="hidden-xs"><i class="fa fa-search"></i> Search</span>
            <span class="visible-xs"><i class="fa fa-search"></i></span>
          </a>

          <a right-nav="" on-click="showAbout">
            <span class="hidden-xs"><i class="fa fa-question"></i> About</span>
            <span class="visible-xs"><i class="fa fa-question"></i></span>
          </a>

          <cwn-map-menu id="menu" on-select="onRegionSelect">
          </cwn-map-menu>


          <cwn-map id="map" on-selected="onFeatureSelected" on-filtering-complete="updateGraph">
          </cwn-map>

          <cwn-info-page content="" id="info">
          </cwn-info-page>

          <cwn-graph content="" class="fit" id="graph">
          </cwn-graph>



        </cwn-app-layout>

    </template>
</dom-module>

<script>
    Polymer({
        is : 'cwn-app',

        ready : function() {
          this.PAGES = {
            map : 0,
            info : 1,
            graph : 2
          };

          this.selectedPage = 0;


          this.loading = true;

          this.dataLoaded = false;
          this.dataLoadHandlers = [];

          this.legend = {
            'Power Plant'         : {
              color : '#3366cc',
              google : 'small_red'
            },
            'Agricultural Demand' : {
                color : '#ff9900',
                google : 'small_yellow'
            },
            'Junction'            : {
                color : '#109618',
                google : 'small_green'
            },
            'Pump Plant'          : {
                color : '#990099',
                google : 'small_blue'
            },
            'Water Treatment'     : {
                color : '#0099c6',
                google : 'small_purple'
            },
            'Surface Storage'     : {
                color : '#dd4477',
                google : 'measle_brown',
            },
            'Urban Demand'        : {
                color : '#66aa00',
                google : 'measle_grey'
            },
            'Sink'                : {
                color : '#b82e2e',
                google : 'measle_white'
            },
            'Groundwater Storage' : {
                color : '#316395',
                google : 'measle_turquoise'
            },
            'Non-Standard Demand' : {
                color : '#22aa99',
                google : 'shaded_dot'
            }
          };

          this.$.map.menu = this.$.menu;
          this.$.map.selector = this.$.selector;
        },

        attached : function() {
          $(window).on('hashchange', function(){
            this.setLocation();
          }.bind(this));

          this.$.filters.setLegend(this.legend);
          this.$.map.init(this.legend, this.$.filters.filters);
          this.$.info.init(this.$.map.map);

          this.setLocation();

          if( CWN.ds.loading ) CWN.ds.on('load', this.onLoadingChange.bind(this));
          else this.onLoadingChange();
        },

        onLoadingChange : function() {
          if( CWN.ds.loading ) {
            this.$.splash.style.display = 'block';
          } else {
            this.$.splash.style.display = 'none';
            this.onDataLoad();
          }
        },

        setLocation : function() {
          var loc = window.location.hash.replace('#','').replace(/\/.*/,'');
          if( loc == '') loc = 'map';
          this.$.backBtn.style.display = 'none';
          this.$.filterBtn.style.display = 'none';

          this.$.layout.updateView(loc);

          if( loc == 'map' ) {
            this.$.filterBtn.style.display = 'inline-block';
            this.selectedPage = this.PAGES.map;
            this.async(function(){
              var ele = this.querySelector('cwn-map');
              if( ele && ele.map ) ele.map.invalidateSize();
            });
          } else if ( loc == 'info' ) {
            this.$.backBtn.style.display = 'inline-block';

            this.selectedPage = this.PAGES.info;
            if( this.dataLoaded ) {
              this.setInfoFeature();
            } else {
              this.dataLoadHandlers.push(this.setInfoFeature.bind(this));
            }
          } else if ( loc == 'graph' ) {
            this.$.backBtn.style.display = 'inline-block';
            this.$.filterBtn.style.display = 'inline-block';
            this.selectedPage = this.PAGES.graph;
          }
          this.setPage();
        },

        setPage : function() {
          for( var key in this.PAGES ) {
            if( this.selectedPage == this.PAGES[key] ) this.$[key].style.display = 'block';
            else $(this.$[key]).hide();
          }
        },

        setInfoFeature : function() {
          var name = window.location.hash.replace('#','').split('/')[1];
          name = decodeURIComponent(name);
          this.$.info.setFeature(name);
        },

        onDataLoad : function() {
          this.dataLoaded = true;
          for( var i = 0; i < this.dataLoadHandlers.length; i++ ) {
            this.dataLoadHandlers[i]();
          }
          this.dataLoadHandlers = [];
        },

        showFilters : function() {
            this.$.filters.show();
        },

        search : function() {
          this.$.search.show();
        },

        showAbout : function() {
          this.$.about.show();
        },

        updateGraph : function() {
          this.$.graph.update();
        },

        onFeatureSelected : function(e) {
          //this.$.pages.selected = this.PAGES.INFO;
          this.selectedPage = this.PAGES.info;
          window.location.hash = 'info/'+e.detail.properties.prmname;
        },

        onFiltersUpdated : function(e) {
          this.$.map.mapFilters = e.detail;

          this.$.map.update();
          this.$.graph.update();
        },

        onRegionSelect : function(e) {
          this.$.map.onRegionSelect(e);
        },

        onDataUpdated : function() {
          var menuState = this.$.menu.getEnabled();

          CWN.ds.reset();
          this.$.map.markerLayer.features = [];

          CWN.ds.reload(function(){
            this.$.menu.init(menuState);
            this.$.map.onRegionSelect();
            $(window).trigger('hashchange');
          }.bind(this));
        }
    });
</script>
</div></body></html>